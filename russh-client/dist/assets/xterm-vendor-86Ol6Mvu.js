var Se = { exports: {} }; (function (ue, pe) {
  (function (ae, ie) { ue.exports = ie() })(self, () => (() => {
    var ae = {
      4567: function (P, t, h) {
        var c = this && this.__decorate || function (r, d, u, p) { var S, a = arguments.length, g = a < 3 ? d : p === null ? p = Object.getOwnPropertyDescriptor(d, u) : p; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") g = Reflect.decorate(r, d, u, p); else for (var w = r.length - 1; w >= 0; w--)(S = r[w]) && (g = (a < 3 ? S(g) : a > 3 ? S(d, u, g) : S(d, u)) || g); return a > 3 && g && Object.defineProperty(d, u, g), g }, f = this && this.__param || function (r, d) { return function (u, p) { d(u, p, r) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.AccessibilityManager = void 0; const n = h(9042), l = h(6114), _ = h(9924), v = h(844), o = h(5596), e = h(4725), s = h(3656); let i = t.AccessibilityManager = class extends v.Disposable {
          constructor(r, d) {
            super(), this._terminal = r, this._renderService = d, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = []; for (let u = 0; u < this._terminal.rows; u++)this._rowElements[u] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[u]); if (this._topBoundaryFocusListener = u => this._handleBoundaryFocus(u, 0), this._bottomBoundaryFocusListener = u => this._handleBoundaryFocus(u, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new _.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open"); this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize(u => this._handleResize(u.rows))), this.register(this._terminal.onRender(u => this._refreshRows(u.start, u.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar(u => this._handleChar(u))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab(u => this._handleTab(u))), this.register(this._terminal.onKey(u => this._handleKey(u.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new o.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, s.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, v.toDisposable)(() => { this._accessibilityContainer.remove(), this._rowElements.length = 0 }))
          } _handleTab(r) { for (let d = 0; d < r; d++)this._handleChar(" ") } _handleChar(r) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== r && (this._charsToAnnounce += r) : this._charsToAnnounce += r, r === `
`&& (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += n.tooMuchOutput)), l.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => { this._accessibilityContainer.appendChild(this._liveRegion) }, 0))
          } _clearLiveRegion() { this._liveRegion.textContent = "", this._liveRegionLineCount = 0, l.isMac && this._liveRegion.remove() } _handleKey(r) { this._clearLiveRegion(), /\p{Control}/u.test(r) || this._charsToConsume.push(r) } _refreshRows(r, d) { this._liveRegionDebouncer.refresh(r, d, this._terminal.rows) } _renderRows(r, d) { const u = this._terminal.buffer, p = u.lines.length.toString(); for (let S = r; S <= d; S++) { const a = u.translateBufferLineToString(u.ydisp + S, !0), g = (u.ydisp + S + 1).toString(), w = this._rowElements[S]; w && (a.length === 0 ? w.innerText = "Â " : w.textContent = a, w.setAttribute("aria-posinset", g), w.setAttribute("aria-setsize", p)) } this._announceCharacters() } _announceCharacters() { this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "") } _handleBoundaryFocus(r, d) { const u = r.target, p = this._rowElements[d === 0 ? 1 : this._rowElements.length - 2]; if (u.getAttribute("aria-posinset") === (d === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || r.relatedTarget !== p) return; let S, a; if (d === 0 ? (S = u, a = this._rowElements.pop(), this._rowContainer.removeChild(a)) : (S = this._rowElements.shift(), a = u, this._rowContainer.removeChild(S)), S.removeEventListener("focus", this._topBoundaryFocusListener), a.removeEventListener("focus", this._bottomBoundaryFocusListener), d === 0) { const g = this._createAccessibilityTreeNode(); this._rowElements.unshift(g), this._rowContainer.insertAdjacentElement("afterbegin", g) } else { const g = this._createAccessibilityTreeNode(); this._rowElements.push(g), this._rowContainer.appendChild(g) } this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(d === 0 ? -1 : 1), this._rowElements[d === 0 ? 1 : this._rowElements.length - 2].focus(), r.preventDefault(), r.stopImmediatePropagation() } _handleResize(r) { this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener); for (let d = this._rowContainer.children.length; d < this._terminal.rows; d++)this._rowElements[d] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[d]); for (; this._rowElements.length > r;)this._rowContainer.removeChild(this._rowElements.pop()); this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions() } _createAccessibilityTreeNode() { const r = document.createElement("div"); return r.setAttribute("role", "listitem"), r.tabIndex = -1, this._refreshRowDimensions(r), r } _refreshRowsDimensions() { if (this._renderService.dimensions.css.cell.height) { this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows); for (let r = 0; r < this._terminal.rows; r++)this._refreshRowDimensions(this._rowElements[r]) } } _refreshRowDimensions(r) { r.style.height = `${this._renderService.dimensions.css.cell.height}px` }
        }; t.AccessibilityManager = i = c([f(1, e.IRenderService)], i)
      }, 3614: (P, t) => { function h(l) { return l.replace(/\r?\n/g, "\r") } function c(l, _) { return _ ? "\x1B[200~" + l + "\x1B[201~" : l } function f(l, _, v, o) { l = c(l = h(l), v.decPrivateModes.bracketedPasteMode && o.rawOptions.ignoreBracketedPasteMode !== !0), v.triggerDataEvent(l, !0), _.value = "" } function n(l, _, v) { const o = v.getBoundingClientRect(), e = l.clientX - o.left - 10, s = l.clientY - o.top - 10; _.style.width = "20px", _.style.height = "20px", _.style.left = `${e}px`, _.style.top = `${s}px`, _.style.zIndex = "1000", _.focus() } Object.defineProperty(t, "__esModule", { value: !0 }), t.rightClickHandler = t.moveTextAreaUnderMouseCursor = t.paste = t.handlePasteEvent = t.copyHandler = t.bracketTextForPaste = t.prepareTextForTerminal = void 0, t.prepareTextForTerminal = h, t.bracketTextForPaste = c, t.copyHandler = function (l, _) { l.clipboardData && l.clipboardData.setData("text/plain", _.selectionText), l.preventDefault() }, t.handlePasteEvent = function (l, _, v, o) { l.stopPropagation(), l.clipboardData && f(l.clipboardData.getData("text/plain"), _, v, o) }, t.paste = f, t.moveTextAreaUnderMouseCursor = n, t.rightClickHandler = function (l, _, v, o, e) { n(l, _, v), e && o.rightClickSelect(l), _.value = o.selectionText, _.select() } }, 7239: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ColorContrastCache = void 0; const c = h(1505); t.ColorContrastCache = class { constructor() { this._color = new c.TwoKeyMap, this._css = new c.TwoKeyMap } setCss(f, n, l) { this._css.set(f, n, l) } getCss(f, n) { return this._css.get(f, n) } setColor(f, n, l) { this._color.set(f, n, l) } getColor(f, n) { return this._color.get(f, n) } clear() { this._color.clear(), this._css.clear() } } }, 3656: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.addDisposableDomListener = void 0, t.addDisposableDomListener = function (h, c, f, n) { h.addEventListener(c, f, n); let l = !1; return { dispose: () => { l || (l = !0, h.removeEventListener(c, f, n)) } } } }, 6465: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Linkifier2 = void 0; const n = h(3656), l = h(8460), _ = h(844), v = h(2585); let o = t.Linkifier2 = class extends _.Disposable { get currentLink() { return this._currentLink } constructor(e) { super(), this._bufferService = e, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._wasResized = !1, this._activeLine = -1, this._onShowLinkUnderline = this.register(new l.EventEmitter), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new l.EventEmitter), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, _.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, _.toDisposable)(() => { this._lastMouseEvent = void 0 })), this.register(this._bufferService.onResize(() => { this._clearCurrentLink(), this._wasResized = !0 })) } registerLinkProvider(e) { return this._linkProviders.push(e), { dispose: () => { const s = this._linkProviders.indexOf(e); s !== -1 && this._linkProviders.splice(s, 1) } } } attachToDom(e, s, i) { this._element = e, this._mouseService = s, this._renderService = i, this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => { this._isMouseOut = !0, this._clearCurrentLink() })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this))) } _handleMouseMove(e) { if (this._lastMouseEvent = e, !this._element || !this._mouseService) return; const s = this._positionFromMouseEvent(e, this._element, this._mouseService); if (!s) return; this._isMouseOut = !1; const i = e.composedPath(); for (let r = 0; r < i.length; r++) { const d = i[r]; if (d.classList.contains("xterm")) break; if (d.classList.contains("xterm-hover")) return } this._lastBufferCell && s.x === this._lastBufferCell.x && s.y === this._lastBufferCell.y || (this._handleHover(s), this._lastBufferCell = s) } _handleHover(e) { if (this._activeLine !== e.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e, !1), void (this._wasResized = !1); this._currentLink && this._linkAtPosition(this._currentLink.link, e) || (this._clearCurrentLink(), this._askForLink(e, !0)) } _askForLink(e, s) { var i, r; this._activeProviderReplies && s || ((i = this._activeProviderReplies) === null || i === void 0 || i.forEach(u => { u?.forEach(p => { p.link.dispose && p.link.dispose() }) }), this._activeProviderReplies = new Map, this._activeLine = e.y); let d = !1; for (const [u, p] of this._linkProviders.entries()) s ? !((r = this._activeProviderReplies) === null || r === void 0) && r.get(u) && (d = this._checkLinkProviderResult(u, e, d)) : p.provideLinks(e.y, S => { var a, g; if (this._isMouseOut) return; const w = S?.map(m => ({ link: m })); (a = this._activeProviderReplies) === null || a === void 0 || a.set(u, w), d = this._checkLinkProviderResult(u, e, d), ((g = this._activeProviderReplies) === null || g === void 0 ? void 0 : g.size) === this._linkProviders.length && this._removeIntersectingLinks(e.y, this._activeProviderReplies) }) } _removeIntersectingLinks(e, s) { const i = new Set; for (let r = 0; r < s.size; r++) { const d = s.get(r); if (d) for (let u = 0; u < d.length; u++) { const p = d[u], S = p.link.range.start.y < e ? 0 : p.link.range.start.x, a = p.link.range.end.y > e ? this._bufferService.cols : p.link.range.end.x; for (let g = S; g <= a; g++) { if (i.has(g)) { d.splice(u--, 1); break } i.add(g) } } } } _checkLinkProviderResult(e, s, i) { var r; if (!this._activeProviderReplies) return i; const d = this._activeProviderReplies.get(e); let u = !1; for (let p = 0; p < e; p++)this._activeProviderReplies.has(p) && !this._activeProviderReplies.get(p) || (u = !0); if (!u && d) { const p = d.find(S => this._linkAtPosition(S.link, s)); p && (i = !0, this._handleNewLink(p)) } if (this._activeProviderReplies.size === this._linkProviders.length && !i) for (let p = 0; p < this._activeProviderReplies.size; p++) { const S = (r = this._activeProviderReplies.get(p)) === null || r === void 0 ? void 0 : r.find(a => this._linkAtPosition(a.link, s)); if (S) { i = !0, this._handleNewLink(S); break } } return i } _handleMouseDown() { this._mouseDownLink = this._currentLink } _handleMouseUp(e) { if (!this._element || !this._mouseService || !this._currentLink) return; const s = this._positionFromMouseEvent(e, this._element, this._mouseService); s && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, s) && this._currentLink.link.activate(e, this._currentLink.link.text) } _clearCurrentLink(e, s) { this._element && this._currentLink && this._lastMouseEvent && (!e || !s || this._currentLink.link.range.start.y >= e && this._currentLink.link.range.end.y <= s) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, _.disposeArray)(this._linkCacheDisposables)) } _handleNewLink(e) { if (!this._element || !this._lastMouseEvent || !this._mouseService) return; const s = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService); s && this._linkAtPosition(e.link, s) && (this._currentLink = e, this._currentLink.state = { decorations: { underline: e.link.decorations === void 0 || e.link.decorations.underline, pointerCursor: e.link.decorations === void 0 || e.link.decorations.pointerCursor }, isHovered: !0 }, this._linkHover(this._element, e.link, this._lastMouseEvent), e.link.decorations = {}, Object.defineProperties(e.link.decorations, { pointerCursor: { get: () => { var i, r; return (r = (i = this._currentLink) === null || i === void 0 ? void 0 : i.state) === null || r === void 0 ? void 0 : r.decorations.pointerCursor }, set: i => { var r, d; !((r = this._currentLink) === null || r === void 0) && r.state && this._currentLink.state.decorations.pointerCursor !== i && (this._currentLink.state.decorations.pointerCursor = i, this._currentLink.state.isHovered && ((d = this._element) === null || d === void 0 || d.classList.toggle("xterm-cursor-pointer", i))) } }, underline: { get: () => { var i, r; return (r = (i = this._currentLink) === null || i === void 0 ? void 0 : i.state) === null || r === void 0 ? void 0 : r.decorations.underline }, set: i => { var r, d, u; !((r = this._currentLink) === null || r === void 0) && r.state && ((u = (d = this._currentLink) === null || d === void 0 ? void 0 : d.state) === null || u === void 0 ? void 0 : u.decorations.underline) !== i && (this._currentLink.state.decorations.underline = i, this._currentLink.state.isHovered && this._fireUnderlineEvent(e.link, i)) } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(i => { if (!this._currentLink) return; const r = i.start === 0 ? 0 : i.start + 1 + this._bufferService.buffer.ydisp, d = this._bufferService.buffer.ydisp + 1 + i.end; if (this._currentLink.link.range.start.y >= r && this._currentLink.link.range.end.y <= d && (this._clearCurrentLink(r, d), this._lastMouseEvent && this._element)) { const u = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService); u && this._askForLink(u, !1) } }))) } _linkHover(e, s, i) { var r; !((r = this._currentLink) === null || r === void 0) && r.state && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(s, !0), this._currentLink.state.decorations.pointerCursor && e.classList.add("xterm-cursor-pointer")), s.hover && s.hover(i, s.text) } _fireUnderlineEvent(e, s) { const i = e.range, r = this._bufferService.buffer.ydisp, d = this._createLinkUnderlineEvent(i.start.x - 1, i.start.y - r - 1, i.end.x, i.end.y - r - 1, void 0); (s ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(d) } _linkLeave(e, s, i) { var r; !((r = this._currentLink) === null || r === void 0) && r.state && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(s, !1), this._currentLink.state.decorations.pointerCursor && e.classList.remove("xterm-cursor-pointer")), s.leave && s.leave(i, s.text) } _linkAtPosition(e, s) { const i = e.range.start.y * this._bufferService.cols + e.range.start.x, r = e.range.end.y * this._bufferService.cols + e.range.end.x, d = s.y * this._bufferService.cols + s.x; return i <= d && d <= r } _positionFromMouseEvent(e, s, i) { const r = i.getCoords(e, s, this._bufferService.cols, this._bufferService.rows); if (r) return { x: r[0], y: r[1] + this._bufferService.buffer.ydisp } } _createLinkUnderlineEvent(e, s, i, r, d) { return { x1: e, y1: s, x2: i, y2: r, cols: this._bufferService.cols, fg: d } } }; t.Linkifier2 = o = c([f(0, v.IBufferService)], o) }, 9042: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.tooMuchOutput = t.promptLabel = void 0, t.promptLabel = "Terminal input", t.tooMuchOutput = "Too much output to announce, navigate to rows manually to read" }, 3730: function (P, t, h) {
        var c = this && this.__decorate || function (o, e, s, i) { var r, d = arguments.length, u = d < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, s) : i; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") u = Reflect.decorate(o, e, s, i); else for (var p = o.length - 1; p >= 0; p--)(r = o[p]) && (u = (d < 3 ? r(u) : d > 3 ? r(e, s, u) : r(e, s)) || u); return d > 3 && u && Object.defineProperty(e, s, u), u }, f = this && this.__param || function (o, e) { return function (s, i) { e(s, i, o) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.OscLinkProvider = void 0; const n = h(511), l = h(2585); let _ = t.OscLinkProvider = class { constructor(o, e, s) { this._bufferService = o, this._optionsService = e, this._oscLinkService = s } provideLinks(o, e) { var s; const i = this._bufferService.buffer.lines.get(o - 1); if (!i) return void e(void 0); const r = [], d = this._optionsService.rawOptions.linkHandler, u = new n.CellData, p = i.getTrimmedLength(); let S = -1, a = -1, g = !1; for (let w = 0; w < p; w++)if (a !== -1 || i.hasContent(w)) { if (i.loadCell(w, u), u.hasExtendedAttrs() && u.extended.urlId) { if (a === -1) { a = w, S = u.extended.urlId; continue } g = u.extended.urlId !== S } else a !== -1 && (g = !0); if (g || a !== -1 && w === p - 1) { const m = (s = this._oscLinkService.getLinkData(S)) === null || s === void 0 ? void 0 : s.uri; if (m) { const C = { start: { x: a + 1, y: o }, end: { x: w + (g || w !== p - 1 ? 0 : 1), y: o } }; let L = !1; if (!d?.allowNonHttpProtocols) try { const R = new URL(m);["http:", "https:"].includes(R.protocol) || (L = !0) } catch { L = !0 } L || r.push({ text: m, range: C, activate: (R, D) => d ? d.activate(R, D, C) : v(0, D), hover: (R, D) => { var M; return (M = d?.hover) === null || M === void 0 ? void 0 : M.call(d, R, D, C) }, leave: (R, D) => { var M; return (M = d?.leave) === null || M === void 0 ? void 0 : M.call(d, R, D, C) } }) } g = !1, u.hasExtendedAttrs() && u.extended.urlId ? (a = w, S = u.extended.urlId) : (a = -1, S = -1) } } e(r) } }; function v(o, e) {
          if (confirm(`Do you want to navigate to ${e}?

WARNING: This link could potentially be dangerous`)) { const s = window.open(); if (s) { try { s.opener = null } catch { } s.location.href = e } else console.warn("Opening link blocked as opener could not be cleared") }
        } t.OscLinkProvider = _ = c([f(0, l.IBufferService), f(1, l.IOptionsService), f(2, l.IOscLinkService)], _)
      }, 6193: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.RenderDebouncer = void 0, t.RenderDebouncer = class { constructor(h, c) { this._parentWindow = h, this._renderCallback = c, this._refreshCallbacks = [] } dispose() { this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0) } addRefreshCallback(h) { return this._refreshCallbacks.push(h), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame } refresh(h, c, f) { this._rowCount = f, h = h !== void 0 ? h : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, h) : h, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())) } _innerRefresh() { if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return void this._runRefreshCallbacks(); const h = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1); this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(h, c), this._runRefreshCallbacks() } _runRefreshCallbacks() { for (const h of this._refreshCallbacks) h(0); this._refreshCallbacks = [] } } }, 5596: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ScreenDprMonitor = void 0; const c = h(844); class f extends c.Disposable { constructor(l) { super(), this._parentWindow = l, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, c.toDisposable)(() => { this.clearListener() })) } setListener(l) { this._listener && this.clearListener(), this._listener = l, this._outerListener = () => { this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr()) }, this._updateDpr() } _updateDpr() { var l; this._outerListener && ((l = this._resolutionMediaMatchList) === null || l === void 0 || l.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener)) } clearListener() { this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0) } } t.ScreenDprMonitor = f }, 3236: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Terminal = void 0; const c = h(3614), f = h(3656), n = h(6465), l = h(9042), _ = h(3730), v = h(1680), o = h(3107), e = h(5744), s = h(2950), i = h(1296), r = h(428), d = h(4269), u = h(5114), p = h(8934), S = h(3230), a = h(9312), g = h(4725), w = h(6731), m = h(8055), C = h(8969), L = h(8460), R = h(844), D = h(6114), M = h(8437), k = h(2584), b = h(7399), E = h(5941), x = h(9074), A = h(2585), B = h(5435), F = h(4567), H = typeof window < "u" ? window.document : null; class W extends C.CoreTerminal { get onFocus() { return this._onFocus.event } get onBlur() { return this._onBlur.event } get onA11yChar() { return this._onA11yCharEmitter.event } get onA11yTab() { return this._onA11yTabEmitter.event } get onWillOpen() { return this._onWillOpen.event } constructor(y = {}) { super(y), this.browser = D, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._accessibilityManager = this.register(new R.MutableDisposable), this._onCursorMove = this.register(new L.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new L.EventEmitter), this.onKey = this._onKey.event, this._onRender = this.register(new L.EventEmitter), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new L.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new L.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new L.EventEmitter), this.onBell = this._onBell.event, this._onFocus = this.register(new L.EventEmitter), this._onBlur = this.register(new L.EventEmitter), this._onA11yCharEmitter = this.register(new L.EventEmitter), this._onA11yTabEmitter = this.register(new L.EventEmitter), this._onWillOpen = this.register(new L.EventEmitter), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(n.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(_.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(x.DecorationService), this._instantiationService.setService(A.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((T, I) => this.refresh(T, I))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport(T => this._reportWindowsOptions(T))), this.register(this._inputHandler.onColor(T => this._handleColorEvent(T))), this.register((0, L.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, L.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, L.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, L.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize(T => this._afterResize(T.cols, T.rows))), this.register((0, R.toDisposable)(() => { var T, I; this._customKeyEventHandler = void 0, (I = (T = this.element) === null || T === void 0 ? void 0 : T.parentNode) === null || I === void 0 || I.removeChild(this.element) })) } _handleColorEvent(y) { if (this._themeService) for (const T of y) { let I, O = ""; switch (T.index) { case 256: I = "foreground", O = "10"; break; case 257: I = "background", O = "11"; break; case 258: I = "cursor", O = "12"; break; default: I = "ansi", O = "4;" + T.index }switch (T.type) { case 0: const z = m.color.toColorRGB(I === "ansi" ? this._themeService.colors.ansi[T.index] : this._themeService.colors[I]); this.coreService.triggerDataEvent(`${k.C0.ESC}]${O};${(0, E.toRgbString)(z)}${k.C1_ESCAPED.ST}`); break; case 1: if (I === "ansi") this._themeService.modifyColors($ => $.ansi[T.index] = m.rgba.toColor(...T.color)); else { const $ = I; this._themeService.modifyColors(V => V[$] = m.rgba.toColor(...T.color)) } break; case 2: this._themeService.restoreColor(T.index) } } } _setup() { super._setup(), this._customKeyEventHandler = void 0 } get buffer() { return this.buffers.active } focus() { this.textarea && this.textarea.focus({ preventScroll: !0 }) } _handleScreenReaderModeOptionChange(y) { y ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(F.AccessibilityManager, this)) : this._accessibilityManager.clear() } _handleTextAreaFocus(y) { this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(k.C0.ESC + "[I"), this.updateCursorStyle(y), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire() } blur() { var y; return (y = this.textarea) === null || y === void 0 ? void 0 : y.blur() } _handleTextAreaBlur() { this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(k.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire() } _syncTextArea() { if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return; const y = this.buffer.ybase + this.buffer.y, T = this.buffer.lines.get(y); if (!T) return; const I = Math.min(this.buffer.x, this.cols - 1), O = this._renderService.dimensions.css.cell.height, z = T.getWidth(I), $ = this._renderService.dimensions.css.cell.width * z, V = this.buffer.y * this._renderService.dimensions.css.cell.height, ee = I * this._renderService.dimensions.css.cell.width; this.textarea.style.left = ee + "px", this.textarea.style.top = V + "px", this.textarea.style.width = $ + "px", this.textarea.style.height = O + "px", this.textarea.style.lineHeight = O + "px", this.textarea.style.zIndex = "-5" } _initGlobal() { this._bindKeys(), this.register((0, f.addDisposableDomListener)(this.element, "copy", T => { this.hasSelection() && (0, c.copyHandler)(T, this._selectionService) })); const y = T => (0, c.handlePasteEvent)(T, this.textarea, this.coreService, this.optionsService); this.register((0, f.addDisposableDomListener)(this.textarea, "paste", y)), this.register((0, f.addDisposableDomListener)(this.element, "paste", y)), D.isFirefox ? this.register((0, f.addDisposableDomListener)(this.element, "mousedown", T => { T.button === 2 && (0, c.rightClickHandler)(T, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord) })) : this.register((0, f.addDisposableDomListener)(this.element, "contextmenu", T => { (0, c.rightClickHandler)(T, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord) })), D.isLinux && this.register((0, f.addDisposableDomListener)(this.element, "auxclick", T => { T.button === 1 && (0, c.moveTextAreaUnderMouseCursor)(T, this.textarea, this.screenElement) })) } _bindKeys() { this.register((0, f.addDisposableDomListener)(this.textarea, "keyup", y => this._keyUp(y), !0)), this.register((0, f.addDisposableDomListener)(this.textarea, "keydown", y => this._keyDown(y), !0)), this.register((0, f.addDisposableDomListener)(this.textarea, "keypress", y => this._keyPress(y), !0)), this.register((0, f.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, f.addDisposableDomListener)(this.textarea, "compositionupdate", y => this._compositionHelper.compositionupdate(y))), this.register((0, f.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, f.addDisposableDomListener)(this.textarea, "input", y => this._inputEvent(y), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements())) } open(y) { var T; if (!y) throw new Error("Terminal requires a parent element."); y.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = y.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), y.appendChild(this.element); const I = H.createDocumentFragment(); this._viewportElement = H.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), I.appendChild(this._viewportElement), this._viewportScrollArea = H.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = H.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = H.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), I.appendChild(this.screenElement), this.textarea = H.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", l.promptLabel), D.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(u.CoreBrowserService, this.textarea, (T = this._document.defaultView) !== null && T !== void 0 ? T : window), this._instantiationService.setService(g.ICoreBrowserService, this._coreBrowserService), this.register((0, f.addDisposableDomListener)(this.textarea, "focus", O => this._handleTextAreaFocus(O))), this.register((0, f.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(r.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(g.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(w.ThemeService), this._instantiationService.setService(g.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(d.CharacterJoinerService), this._instantiationService.setService(g.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(S.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(g.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange(O => this._onRender.fire(O))), this.onResize(O => this._renderService.resize(O.cols, O.rows)), this._compositionView = H.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(s.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(I); try { this._onWillOpen.fire(this.element) } catch { } this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(g.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(v.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines(O => this.scrollLines(O.amount, O.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => { this._renderService.handleCursorMove(), this._syncTextArea() })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(a.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(g.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines(O => this.scrollLines(O.amount, O.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw(O => this._renderService.handleSelectionChanged(O.start, O.end, O.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection(O => { this.textarea.value = O, this.textarea.focus(), this.textarea.select() })), this.register(this._onScroll.event(O => { this.viewport.syncScrollArea(), this._selectionService.refresh() })), this.register((0, f.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(o.BufferDecorationRenderer, this.screenElement)), this.register((0, f.addDisposableDomListener)(this.element, "mousedown", O => this._selectionService.handleMouseDown(O))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(F.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", O => this._handleScreenReaderModeOptionChange(O))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(e.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", O => { !this._overviewRulerRenderer && O && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(e.OverviewRulerRenderer, this._viewportElement, this.screenElement))) }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse() } _createRenderer() { return this._instantiationService.createInstance(i.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2) } bindMouse() { const y = this, T = this.element; function I($) { const V = y._mouseService.getMouseReportCoords($, y.screenElement); if (!V) return !1; let ee, te; switch ($.overrideType || $.type) { case "mousemove": te = 32, $.buttons === void 0 ? (ee = 3, $.button !== void 0 && (ee = $.button < 3 ? $.button : 3)) : ee = 1 & $.buttons ? 0 : 4 & $.buttons ? 1 : 2 & $.buttons ? 2 : 3; break; case "mouseup": te = 0, ee = $.button < 3 ? $.button : 3; break; case "mousedown": te = 1, ee = $.button < 3 ? $.button : 3; break; case "wheel": if (y.viewport.getLinesScrolled($) === 0) return !1; te = $.deltaY < 0 ? 0 : 1, ee = 4; break; default: return !1 }return !(te === void 0 || ee === void 0 || ee > 4) && y.coreMouseService.triggerMouseEvent({ col: V.col, row: V.row, x: V.x, y: V.y, button: ee, action: te, ctrl: $.ctrlKey, alt: $.altKey, shift: $.shiftKey }) } const O = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, z = { mouseup: $ => (I($), $.buttons || (this._document.removeEventListener("mouseup", O.mouseup), O.mousedrag && this._document.removeEventListener("mousemove", O.mousedrag)), this.cancel($)), wheel: $ => (I($), this.cancel($, !0)), mousedrag: $ => { $.buttons && I($) }, mousemove: $ => { $.buttons || I($) } }; this.register(this.coreMouseService.onProtocolChange($ => { $ ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents($)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & $ ? O.mousemove || (T.addEventListener("mousemove", z.mousemove), O.mousemove = z.mousemove) : (T.removeEventListener("mousemove", O.mousemove), O.mousemove = null), 16 & $ ? O.wheel || (T.addEventListener("wheel", z.wheel, { passive: !1 }), O.wheel = z.wheel) : (T.removeEventListener("wheel", O.wheel), O.wheel = null), 2 & $ ? O.mouseup || (T.addEventListener("mouseup", z.mouseup), O.mouseup = z.mouseup) : (this._document.removeEventListener("mouseup", O.mouseup), T.removeEventListener("mouseup", O.mouseup), O.mouseup = null), 4 & $ ? O.mousedrag || (O.mousedrag = z.mousedrag) : (this._document.removeEventListener("mousemove", O.mousedrag), O.mousedrag = null) })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, f.addDisposableDomListener)(T, "mousedown", $ => { if ($.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection($)) return I($), O.mouseup && this._document.addEventListener("mouseup", O.mouseup), O.mousedrag && this._document.addEventListener("mousemove", O.mousedrag), this.cancel($) })), this.register((0, f.addDisposableDomListener)(T, "wheel", $ => { if (!O.wheel) { if (!this.buffer.hasScrollback) { const V = this.viewport.getLinesScrolled($); if (V === 0) return; const ee = k.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + ($.deltaY < 0 ? "A" : "B"); let te = ""; for (let Z = 0; Z < Math.abs(V); Z++)te += ee; return this.coreService.triggerDataEvent(te, !0), this.cancel($, !0) } return this.viewport.handleWheel($) ? this.cancel($) : void 0 } }, { passive: !1 })), this.register((0, f.addDisposableDomListener)(T, "touchstart", $ => { if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart($), this.cancel($) }, { passive: !0 })), this.register((0, f.addDisposableDomListener)(T, "touchmove", $ => { if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove($) ? void 0 : this.cancel($) }, { passive: !1 })) } refresh(y, T) { var I; (I = this._renderService) === null || I === void 0 || I.refreshRows(y, T) } updateCursorStyle(y) { var T; !((T = this._selectionService) === null || T === void 0) && T.shouldColumnSelect(y) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select") } _showCursor() { this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y)) } scrollLines(y, T, I = 0) { var O; I === 1 ? (super.scrollLines(y, T, I), this.refresh(0, this.rows - 1)) : (O = this.viewport) === null || O === void 0 || O.scrollLines(y) } paste(y) { (0, c.paste)(y, this.textarea, this.coreService, this.optionsService) } attachCustomKeyEventHandler(y) { this._customKeyEventHandler = y } registerLinkProvider(y) { return this.linkifier2.registerLinkProvider(y) } registerCharacterJoiner(y) { if (!this._characterJoinerService) throw new Error("Terminal must be opened first"); const T = this._characterJoinerService.register(y); return this.refresh(0, this.rows - 1), T } deregisterCharacterJoiner(y) { if (!this._characterJoinerService) throw new Error("Terminal must be opened first"); this._characterJoinerService.deregister(y) && this.refresh(0, this.rows - 1) } get markers() { return this.buffer.markers } registerMarker(y) { return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + y) } registerDecoration(y) { return this._decorationService.registerDecoration(y) } hasSelection() { return !!this._selectionService && this._selectionService.hasSelection } select(y, T, I) { this._selectionService.setSelection(y, T, I) } getSelection() { return this._selectionService ? this._selectionService.selectionText : "" } getSelectionPosition() { if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } } } clearSelection() { var y; (y = this._selectionService) === null || y === void 0 || y.clearSelection() } selectAll() { var y; (y = this._selectionService) === null || y === void 0 || y.selectAll() } selectLines(y, T) { var I; (I = this._selectionService) === null || I === void 0 || I.selectLines(y, T) } _keyDown(y) { if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && this._customKeyEventHandler(y) === !1) return !1; const T = this.browser.isMac && this.options.macOptionIsMeta && y.altKey; if (!T && !this._compositionHelper.keydown(y)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), !1; T || y.key !== "Dead" && y.key !== "AltGraph" || (this._unprocessedDeadKey = !0); const I = (0, b.evaluateKeyboardEvent)(y, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta); if (this.updateCursorStyle(y), I.type === 3 || I.type === 2) { const O = this.rows - 1; return this.scrollLines(I.type === 2 ? -O : O), this.cancel(y, !0) } return I.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, y) || (I.cancel && this.cancel(y, !0), !I.key || !!(y.key && !y.ctrlKey && !y.altKey && !y.metaKey && y.key.length === 1 && y.key.charCodeAt(0) >= 65 && y.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (I.key !== k.C0.ETX && I.key !== k.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: I.key, domEvent: y }), this._showCursor(), this.coreService.triggerDataEvent(I.key, !0), !this.optionsService.rawOptions.screenReaderMode || y.altKey || y.ctrlKey ? this.cancel(y, !0) : void (this._keyDownHandled = !0)))) } _isThirdLevelShift(y, T) { const I = y.isMac && !this.options.macOptionIsMeta && T.altKey && !T.ctrlKey && !T.metaKey || y.isWindows && T.altKey && T.ctrlKey && !T.metaKey || y.isWindows && T.getModifierState("AltGraph"); return T.type === "keypress" ? I : I && (!T.keyCode || T.keyCode > 47) } _keyUp(y) { this._keyDownSeen = !1, this._customKeyEventHandler && this._customKeyEventHandler(y) === !1 || (function (T) { return T.keyCode === 16 || T.keyCode === 17 || T.keyCode === 18 }(y) || this.focus(), this.updateCursorStyle(y), this._keyPressHandled = !1) } _keyPress(y) { let T; if (this._keyPressHandled = !1, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(y) === !1) return !1; if (this.cancel(y), y.charCode) T = y.charCode; else if (y.which === null || y.which === void 0) T = y.keyCode; else { if (y.which === 0 || y.charCode === 0) return !1; T = y.which } return !(!T || (y.altKey || y.ctrlKey || y.metaKey) && !this._isThirdLevelShift(this.browser, y) || (T = String.fromCharCode(T), this._onKey.fire({ key: T, domEvent: y }), this._showCursor(), this.coreService.triggerDataEvent(T, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0)) } _inputEvent(y) { if (y.data && y.inputType === "insertText" && (!y.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) { if (this._keyPressHandled) return !1; this._unprocessedDeadKey = !1; const T = y.data; return this.coreService.triggerDataEvent(T, !0), this.cancel(y), !0 } return !1 } resize(y, T) { y !== this.cols || T !== this.rows ? super.resize(y, T) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure() } _afterResize(y, T) { var I, O; (I = this._charSizeService) === null || I === void 0 || I.measure(), (O = this.viewport) === null || O === void 0 || O.syncScrollArea(!0) } clear() { var y; if (this.buffer.ybase !== 0 || this.buffer.y !== 0) { this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0; for (let T = 1; T < this.rows; T++)this.buffer.lines.push(this.buffer.getBlankLine(M.DEFAULT_ATTR_DATA)); this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), (y = this.viewport) === null || y === void 0 || y.reset(), this.refresh(0, this.rows - 1) } } reset() { var y, T; this.options.rows = this.rows, this.options.cols = this.cols; const I = this._customKeyEventHandler; this._setup(), super.reset(), (y = this._selectionService) === null || y === void 0 || y.reset(), this._decorationService.reset(), (T = this.viewport) === null || T === void 0 || T.reset(), this._customKeyEventHandler = I, this.refresh(0, this.rows - 1) } clearTextureAtlas() { var y; (y = this._renderService) === null || y === void 0 || y.clearTextureAtlas() } _reportFocus() { var y; !((y = this.element) === null || y === void 0) && y.classList.contains("focus") ? this.coreService.triggerDataEvent(k.C0.ESC + "[I") : this.coreService.triggerDataEvent(k.C0.ESC + "[O") } _reportWindowsOptions(y) { if (this._renderService) switch (y) { case B.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS: const T = this._renderService.dimensions.css.canvas.width.toFixed(0), I = this._renderService.dimensions.css.canvas.height.toFixed(0); this.coreService.triggerDataEvent(`${k.C0.ESC}[4;${I};${T}t`); break; case B.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS: const O = this._renderService.dimensions.css.cell.width.toFixed(0), z = this._renderService.dimensions.css.cell.height.toFixed(0); this.coreService.triggerDataEvent(`${k.C0.ESC}[6;${z};${O}t`) } } cancel(y, T) { if (this.options.cancelEvents || T) return y.preventDefault(), y.stopPropagation(), !1 } } t.Terminal = W }, 9924: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.TimeBasedDebouncer = void 0, t.TimeBasedDebouncer = class { constructor(h, c = 1e3) { this._renderCallback = h, this._debounceThresholdMS = c, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1 } dispose() { this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID) } refresh(h, c, f) { this._rowCount = f, h = h !== void 0 ? h : 0, c = c !== void 0 ? c : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, h) : h, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, c) : c; const n = Date.now(); if (n - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = n, this._innerRefresh(); else if (!this._additionalRefreshRequested) { const l = n - this._lastRefreshMs, _ = this._debounceThresholdMS - l; this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => { this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0 }, _) } } _innerRefresh() { if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0) return; const h = Math.max(this._rowStart, 0), c = Math.min(this._rowEnd, this._rowCount - 1); this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(h, c) } } }, 1680: function (P, t, h) { var c = this && this.__decorate || function (s, i, r, d) { var u, p = arguments.length, S = p < 3 ? i : d === null ? d = Object.getOwnPropertyDescriptor(i, r) : d; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(s, i, r, d); else for (var a = s.length - 1; a >= 0; a--)(u = s[a]) && (S = (p < 3 ? u(S) : p > 3 ? u(i, r, S) : u(i, r)) || S); return p > 3 && S && Object.defineProperty(i, r, S), S }, f = this && this.__param || function (s, i) { return function (r, d) { i(r, d, s) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Viewport = void 0; const n = h(3656), l = h(4725), _ = h(8460), v = h(844), o = h(2585); let e = t.Viewport = class extends v.Disposable { constructor(s, i, r, d, u, p, S, a) { super(), this._viewportElement = s, this._scrollArea = i, this._bufferService = r, this._optionsService = d, this._charSizeService = u, this._renderService = p, this._coreBrowserService = S, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new _.EventEmitter), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(g => this._activeBuffer = g.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange(g => this._renderDimensions = g)), this._handleThemeChange(a.colors), this.register(a.onChangeColors(g => this._handleThemeChange(g))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea()) } _handleThemeChange(s) { this._viewportElement.style.backgroundColor = s.background.css } reset() { this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea()) } _refresh(s) { if (s) return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame)); this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh())) } _innerRefresh() { if (this._charSizeService.height > 0) { this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight; const i = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height); this._lastRecordedBufferHeight !== i && (this._lastRecordedBufferHeight = i, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px") } const s = this._bufferService.buffer.ydisp * this._currentRowHeight; this._viewportElement.scrollTop !== s && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = s), this._refreshAnimationFrame = null } syncScrollArea(s = !1) { if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(s); this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(s) } _handleScroll(s) { if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return; if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: !0 }); const i = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp; this._onRequestScrollLines.fire({ amount: i, suppressScrollEvent: !0 }) } _smoothScroll() { if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1) return; const s = this._smoothScrollPercent(); this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(s * (this._smoothScrollState.target - this._smoothScrollState.origin)), s < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState() } _smoothScrollPercent() { return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1 } _clearSmoothScrollState() { this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1 } _bubbleScroll(s, i) { const r = this._viewportElement.scrollTop + this._lastRecordedViewportHeight; return !(i < 0 && this._viewportElement.scrollTop !== 0 || i > 0 && r < this._lastRecordedBufferHeight) || (s.cancelable && s.preventDefault(), !1) } handleWheel(s) { const i = this._getPixelsScrolled(s); return i !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + i : this._smoothScrollState.target += i, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += i, this._bubbleScroll(s, i)) } scrollLines(s) { if (s !== 0) if (this._optionsService.rawOptions.smoothScrollDuration) { const i = s * this._currentRowHeight; this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + i, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState() } else this._onRequestScrollLines.fire({ amount: s, suppressScrollEvent: !1 }) } _getPixelsScrolled(s) { if (s.deltaY === 0 || s.shiftKey) return 0; let i = this._applyScrollModifier(s.deltaY, s); return s.deltaMode === WheelEvent.DOM_DELTA_LINE ? i *= this._currentRowHeight : s.deltaMode === WheelEvent.DOM_DELTA_PAGE && (i *= this._currentRowHeight * this._bufferService.rows), i } getBufferElements(s, i) { var r; let d, u = ""; const p = [], S = i ?? this._bufferService.buffer.lines.length, a = this._bufferService.buffer.lines; for (let g = s; g < S; g++) { const w = a.get(g); if (!w) continue; const m = (r = a.get(g + 1)) === null || r === void 0 ? void 0 : r.isWrapped; if (u += w.translateToString(!m), !m || g === a.length - 1) { const C = document.createElement("div"); C.textContent = u, p.push(C), u.length > 0 && (d = C), u = "" } } return { bufferElements: p, cursorElement: d } } getLinesScrolled(s) { if (s.deltaY === 0 || s.shiftKey) return 0; let i = this._applyScrollModifier(s.deltaY, s); return s.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (i /= this._currentRowHeight + 0, this._wheelPartialScroll += i, i = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : s.deltaMode === WheelEvent.DOM_DELTA_PAGE && (i *= this._bufferService.rows), i } _applyScrollModifier(s, i) { const r = this._optionsService.rawOptions.fastScrollModifier; return r === "alt" && i.altKey || r === "ctrl" && i.ctrlKey || r === "shift" && i.shiftKey ? s * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : s * this._optionsService.rawOptions.scrollSensitivity } handleTouchStart(s) { this._lastTouchY = s.touches[0].pageY } handleTouchMove(s) { const i = this._lastTouchY - s.touches[0].pageY; return this._lastTouchY = s.touches[0].pageY, i !== 0 && (this._viewportElement.scrollTop += i, this._bubbleScroll(s, i)) } }; t.Viewport = e = c([f(2, o.IBufferService), f(3, o.IOptionsService), f(4, l.ICharSizeService), f(5, l.IRenderService), f(6, l.ICoreBrowserService), f(7, l.IThemeService)], e) }, 3107: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferDecorationRenderer = void 0; const n = h(3656), l = h(4725), _ = h(844), v = h(2585); let o = t.BufferDecorationRenderer = class extends _.Disposable { constructor(e, s, i, r) { super(), this._screenElement = e, this._bufferService = s, this._decorationService = i, this._renderService = r, this._decorationElements = new Map, this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => { this._dimensionsChanged = !0, this._queueRefresh() })), this.register((0, n.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => { this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved(d => this._removeDecoration(d))), this.register((0, _.toDisposable)(() => { this._container.remove(), this._decorationElements.clear() })) } _queueRefresh() { this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => { this._doRefreshDecorations(), this._animationFrame = void 0 })) } _doRefreshDecorations() { for (const e of this._decorationService.decorations) this._renderDecoration(e); this._dimensionsChanged = !1 } _renderDecoration(e) { this._refreshStyle(e), this._dimensionsChanged && this._refreshXPosition(e) } _createElement(e) { var s, i; const r = document.createElement("div"); r.classList.add("xterm-decoration"), r.classList.toggle("xterm-decoration-top-layer", ((s = e?.options) === null || s === void 0 ? void 0 : s.layer) === "top"), r.style.width = `${Math.round((e.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, r.style.height = (e.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", r.style.top = (e.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", r.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`; const d = (i = e.options.x) !== null && i !== void 0 ? i : 0; return d && d > this._bufferService.cols && (r.style.display = "none"), this._refreshXPosition(e, r), r } _refreshStyle(e) { const s = e.marker.line - this._bufferService.buffers.active.ydisp; if (s < 0 || s >= this._bufferService.rows) e.element && (e.element.style.display = "none", e.onRenderEmitter.fire(e.element)); else { let i = this._decorationElements.get(e); i || (i = this._createElement(e), e.element = i, this._decorationElements.set(e, i), this._container.appendChild(i), e.onDispose(() => { this._decorationElements.delete(e), i.remove() })), i.style.top = s * this._renderService.dimensions.css.cell.height + "px", i.style.display = this._altBufferIsActive ? "none" : "block", e.onRenderEmitter.fire(i) } } _refreshXPosition(e, s = e.element) { var i; if (!s) return; const r = (i = e.options.x) !== null && i !== void 0 ? i : 0; (e.options.anchor || "left") === "right" ? s.style.right = r ? r * this._renderService.dimensions.css.cell.width + "px" : "" : s.style.left = r ? r * this._renderService.dimensions.css.cell.width + "px" : "" } _removeDecoration(e) { var s; (s = this._decorationElements.get(e)) === null || s === void 0 || s.remove(), this._decorationElements.delete(e), e.dispose() } }; t.BufferDecorationRenderer = o = c([f(1, v.IBufferService), f(2, v.IDecorationService), f(3, l.IRenderService)], o) }, 5871: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ColorZoneStore = void 0, t.ColorZoneStore = class { constructor() { this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 } } get zones() { return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones } clear() { this._zones.length = 0, this._zonePoolIndex = 0 } addDecoration(h) { if (h.options.overviewRulerOptions) { for (const c of this._zones) if (c.color === h.options.overviewRulerOptions.color && c.position === h.options.overviewRulerOptions.position) { if (this._lineIntersectsZone(c, h.marker.line)) return; if (this._lineAdjacentToZone(c, h.marker.line, h.options.overviewRulerOptions.position)) return void this._addLineToZone(c, h.marker.line) } if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = h.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = h.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = h.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = h.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]); this._zones.push({ color: h.options.overviewRulerOptions.color, position: h.options.overviewRulerOptions.position, startBufferLine: h.marker.line, endBufferLine: h.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++ } } setPadding(h) { this._linePadding = h } _lineIntersectsZone(h, c) { return c >= h.startBufferLine && c <= h.endBufferLine } _lineAdjacentToZone(h, c, f) { return c >= h.startBufferLine - this._linePadding[f || "full"] && c <= h.endBufferLine + this._linePadding[f || "full"] } _addLineToZone(h, c) { h.startBufferLine = Math.min(h.startBufferLine, c), h.endBufferLine = Math.max(h.endBufferLine, c) } } }, 5744: function (P, t, h) { var c = this && this.__decorate || function (d, u, p, S) { var a, g = arguments.length, w = g < 3 ? u : S === null ? S = Object.getOwnPropertyDescriptor(u, p) : S; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, u, p, S); else for (var m = d.length - 1; m >= 0; m--)(a = d[m]) && (w = (g < 3 ? a(w) : g > 3 ? a(u, p, w) : a(u, p)) || w); return g > 3 && w && Object.defineProperty(u, p, w), w }, f = this && this.__param || function (d, u) { return function (p, S) { u(p, S, d) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.OverviewRulerRenderer = void 0; const n = h(5871), l = h(3656), _ = h(4725), v = h(844), o = h(2585), e = { full: 0, left: 0, center: 0, right: 0 }, s = { full: 0, left: 0, center: 0, right: 0 }, i = { full: 0, left: 0, center: 0, right: 0 }; let r = t.OverviewRulerRenderer = class extends v.Disposable { get _width() { return this._optionsService.options.overviewRulerWidth || 0 } constructor(d, u, p, S, a, g, w) { var m; super(), this._viewportElement = d, this._screenElement = u, this._bufferService = p, this._decorationService = S, this._renderService = a, this._optionsService = g, this._coreBrowseService = w, this._colorZoneStore = new n.ColorZoneStore, this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (m = this._viewportElement.parentElement) === null || m === void 0 || m.insertBefore(this._canvas, this._viewportElement); const C = this._canvas.getContext("2d"); if (!C) throw new Error("Ctx cannot be null"); this._ctx = C, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, v.toDisposable)(() => { var L; (L = this._canvas) === null || L === void 0 || L.remove() })) } _registerDecorationListeners() { this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0))) } _registerBufferChangeListeners() { this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => { this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block" })), this.register(this._bufferService.onScroll(() => { this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding()) })) } _registerDimensionChangeListeners() { this.register(this._renderService.onRender(() => { this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight) })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(!0))), this.register((0, l.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(!0))), this._queueRefresh(!0) } _refreshDrawConstants() { const d = Math.floor(this._canvas.width / 3), u = Math.ceil(this._canvas.width / 3); s.full = this._canvas.width, s.left = d, s.center = u, s.right = d, this._refreshDrawHeightConstants(), i.full = 0, i.left = 0, i.center = s.left, i.right = s.left + s.center } _refreshDrawHeightConstants() { e.full = Math.round(2 * this._coreBrowseService.dpr); const d = this._canvas.height / this._bufferService.buffer.lines.length, u = Math.round(Math.max(Math.min(d, 12), 6) * this._coreBrowseService.dpr); e.left = u, e.center = u, e.right = u } _refreshColorZonePadding() { this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length } _refreshCanvasDimensions() { this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding() } _refreshDecorations() { this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear(); for (const u of this._decorationService.decorations) this._colorZoneStore.addDecoration(u); this._ctx.lineWidth = 1; const d = this._colorZoneStore.zones; for (const u of d) u.position !== "full" && this._renderColorZone(u); for (const u of d) u.position === "full" && this._renderColorZone(u); this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1 } _renderColorZone(d) { this._ctx.fillStyle = d.color, this._ctx.fillRect(i[d.position || "full"], Math.round((this._canvas.height - 1) * (d.startBufferLine / this._bufferService.buffers.active.lines.length) - e[d.position || "full"] / 2), s[d.position || "full"], Math.round((this._canvas.height - 1) * ((d.endBufferLine - d.startBufferLine) / this._bufferService.buffers.active.lines.length) + e[d.position || "full"])) } _queueRefresh(d, u) { this._shouldUpdateDimensions = d || this._shouldUpdateDimensions, this._shouldUpdateAnchor = u || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => { this._refreshDecorations(), this._animationFrame = void 0 })) } }; t.OverviewRulerRenderer = r = c([f(2, o.IBufferService), f(3, o.IDecorationService), f(4, _.IRenderService), f(5, o.IOptionsService), f(6, _.ICoreBrowserService)], r) }, 2950: function (P, t, h) { var c = this && this.__decorate || function (o, e, s, i) { var r, d = arguments.length, u = d < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, s) : i; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") u = Reflect.decorate(o, e, s, i); else for (var p = o.length - 1; p >= 0; p--)(r = o[p]) && (u = (d < 3 ? r(u) : d > 3 ? r(e, s, u) : r(e, s)) || u); return d > 3 && u && Object.defineProperty(e, s, u), u }, f = this && this.__param || function (o, e) { return function (s, i) { e(s, i, o) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.CompositionHelper = void 0; const n = h(4725), l = h(2585), _ = h(2584); let v = t.CompositionHelper = class { get isComposing() { return this._isComposing } constructor(o, e, s, i, r, d) { this._textarea = o, this._compositionView = e, this._bufferService = s, this._optionsService = i, this._coreService = r, this._renderService = d, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "" } compositionstart() { this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active") } compositionupdate(o) { this._compositionView.textContent = o.data, this.updateCompositionElements(), setTimeout(() => { this._compositionPosition.end = this._textarea.value.length }, 0) } compositionend() { this._finalizeComposition(!0) } keydown(o) { if (this._isComposing || this._isSendingComposition) { if (o.keyCode === 229 || o.keyCode === 16 || o.keyCode === 17 || o.keyCode === 18) return !1; this._finalizeComposition(!1) } return o.keyCode !== 229 || (this._handleAnyTextareaChanges(), !1) } _finalizeComposition(o) { if (this._compositionView.classList.remove("active"), this._isComposing = !1, o) { const e = { start: this._compositionPosition.start, end: this._compositionPosition.end }; this._isSendingComposition = !0, setTimeout(() => { if (this._isSendingComposition) { let s; this._isSendingComposition = !1, e.start += this._dataAlreadySent.length, s = this._isComposing ? this._textarea.value.substring(e.start, e.end) : this._textarea.value.substring(e.start), s.length > 0 && this._coreService.triggerDataEvent(s, !0) } }, 0) } else { this._isSendingComposition = !1; const e = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end); this._coreService.triggerDataEvent(e, !0) } } _handleAnyTextareaChanges() { const o = this._textarea.value; setTimeout(() => { if (!this._isComposing) { const e = this._textarea.value, s = e.replace(o, ""); this._dataAlreadySent = s, e.length > o.length ? this._coreService.triggerDataEvent(s, !0) : e.length < o.length ? this._coreService.triggerDataEvent(`${_.C0.DEL}`, !0) : e.length === o.length && e !== o && this._coreService.triggerDataEvent(e, !0) } }, 0) } updateCompositionElements(o) { if (this._isComposing) { if (this._bufferService.buffer.isCursorInViewport) { const e = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), s = this._renderService.dimensions.css.cell.height, i = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, r = e * this._renderService.dimensions.css.cell.width; this._compositionView.style.left = r + "px", this._compositionView.style.top = i + "px", this._compositionView.style.height = s + "px", this._compositionView.style.lineHeight = s + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px"; const d = this._compositionView.getBoundingClientRect(); this._textarea.style.left = r + "px", this._textarea.style.top = i + "px", this._textarea.style.width = Math.max(d.width, 1) + "px", this._textarea.style.height = Math.max(d.height, 1) + "px", this._textarea.style.lineHeight = d.height + "px" } o || setTimeout(() => this.updateCompositionElements(!0), 0) } } }; t.CompositionHelper = v = c([f(2, l.IBufferService), f(3, l.IOptionsService), f(4, l.ICoreService), f(5, n.IRenderService)], v) }, 9806: (P, t) => { function h(c, f, n) { const l = n.getBoundingClientRect(), _ = c.getComputedStyle(n), v = parseInt(_.getPropertyValue("padding-left")), o = parseInt(_.getPropertyValue("padding-top")); return [f.clientX - l.left - v, f.clientY - l.top - o] } Object.defineProperty(t, "__esModule", { value: !0 }), t.getCoords = t.getCoordsRelativeToElement = void 0, t.getCoordsRelativeToElement = h, t.getCoords = function (c, f, n, l, _, v, o, e, s) { if (!v) return; const i = h(c, f, n); return i ? (i[0] = Math.ceil((i[0] + (s ? o / 2 : 0)) / o), i[1] = Math.ceil(i[1] / e), i[0] = Math.min(Math.max(i[0], 1), l + (s ? 1 : 0)), i[1] = Math.min(Math.max(i[1], 1), _), i) : void 0 } }, 9504: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.moveToCellSequence = void 0; const c = h(2584); function f(e, s, i, r) { const d = e - n(e, i), u = s - n(s, i), p = Math.abs(d - u) - function (S, a, g) { let w = 0; const m = S - n(S, g), C = a - n(a, g); for (let L = 0; L < Math.abs(m - C); L++) { const R = l(S, a) === "A" ? -1 : 1, D = g.buffer.lines.get(m + R * L); D?.isWrapped && w++ } return w }(e, s, i); return o(p, v(l(e, s), r)) } function n(e, s) { let i = 0, r = s.buffer.lines.get(e), d = r?.isWrapped; for (; d && e >= 0 && e < s.rows;)i++, r = s.buffer.lines.get(--e), d = r?.isWrapped; return i } function l(e, s) { return e > s ? "A" : "B" } function _(e, s, i, r, d, u) { let p = e, S = s, a = ""; for (; p !== i || S !== r;)p += d ? 1 : -1, d && p > u.cols - 1 ? (a += u.buffer.translateBufferLineToString(S, !1, e, p), p = 0, e = 0, S++) : !d && p < 0 && (a += u.buffer.translateBufferLineToString(S, !1, 0, e + 1), p = u.cols - 1, e = p, S--); return a + u.buffer.translateBufferLineToString(S, !1, e, p) } function v(e, s) { const i = s ? "O" : "["; return c.C0.ESC + i + e } function o(e, s) { e = Math.floor(e); let i = ""; for (let r = 0; r < e; r++)i += s; return i } t.moveToCellSequence = function (e, s, i, r) { const d = i.buffer.x, u = i.buffer.y; if (!i.buffer.hasScrollback) return function (a, g, w, m, C, L) { return f(g, m, C, L).length === 0 ? "" : o(_(a, g, a, g - n(g, C), !1, C).length, v("D", L)) }(d, u, 0, s, i, r) + f(u, s, i, r) + function (a, g, w, m, C, L) { let R; R = f(g, m, C, L).length > 0 ? m - n(m, C) : g; const D = m, M = function (k, b, E, x, A, B) { let F; return F = f(E, x, A, B).length > 0 ? x - n(x, A) : b, k < E && F <= x || k >= E && F < x ? "C" : "D" }(a, g, w, m, C, L); return o(_(a, R, w, D, M === "C", C).length, v(M, L)) }(d, u, e, s, i, r); let p; if (u === s) return p = d > e ? "D" : "C", o(Math.abs(d - e), v(p, r)); p = u > s ? "D" : "C"; const S = Math.abs(u - s); return o(function (a, g) { return g.cols - a }(u > s ? e : d, i) + (S - 1) * i.cols + 1 + ((u > s ? d : e) - 1), v(p, r)) } }, 1296: function (P, t, h) { var c = this && this.__decorate || function (C, L, R, D) { var M, k = arguments.length, b = k < 3 ? L : D === null ? D = Object.getOwnPropertyDescriptor(L, R) : D; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") b = Reflect.decorate(C, L, R, D); else for (var E = C.length - 1; E >= 0; E--)(M = C[E]) && (b = (k < 3 ? M(b) : k > 3 ? M(L, R, b) : M(L, R)) || b); return k > 3 && b && Object.defineProperty(L, R, b), b }, f = this && this.__param || function (C, L) { return function (R, D) { L(R, D, C) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.DomRenderer = void 0; const n = h(3787), l = h(2550), _ = h(2223), v = h(6171), o = h(4725), e = h(8055), s = h(8460), i = h(844), r = h(2585), d = "xterm-dom-renderer-owner-", u = "xterm-rows", p = "xterm-fg-", S = "xterm-bg-", a = "xterm-focus", g = "xterm-selection"; let w = 1, m = t.DomRenderer = class extends i.Disposable { constructor(C, L, R, D, M, k, b, E, x, A) { super(), this._element = C, this._screenElement = L, this._viewportElement = R, this._linkifier2 = D, this._charSizeService = k, this._optionsService = b, this._bufferService = E, this._coreBrowserService = x, this._themeService = A, this._terminalClass = w++, this._rowElements = [], this.onRequestRedraw = this.register(new s.EventEmitter).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(u), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(g), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, v.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors(B => this._injectCss(B))), this._injectCss(this._themeService.colors), this._rowFactory = M.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(d + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline(B => this._handleLinkHover(B))), this.register(this._linkifier2.onHideLinkUnderline(B => this._handleLinkLeave(B))), this.register((0, i.toDisposable)(() => { this._element.classList.remove(d + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove() })), this._widthCache = new l.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing() } _updateDimensions() { const C = this._coreBrowserService.dpr; this.dimensions.device.char.width = this._charSizeService.width * C, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * C), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / C), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / C), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows; for (const R of this._rowElements) R.style.width = `${this.dimensions.css.canvas.width}px`, R.style.height = `${this.dimensions.css.cell.height}px`, R.style.lineHeight = `${this.dimensions.css.cell.height}px`, R.style.overflow = "hidden"; this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement)); const L = `${this._terminalSelector} .${u} span { display: inline-block; height: 100%; vertical-align: top;}`; this._dimensionsStyleElement.textContent = L, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px` } _injectCss(C) { this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement)); let L = `${this._terminalSelector} .${u} { color: ${C.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`; L += `${this._terminalSelector} .${u} .xterm-dim { color: ${e.color.multiplyOpacity(C.foreground, .5).css};}`, L += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, L += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", L += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${C.cursor.css};  color: ${C.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${C.cursor.css}; }}`, L += `${this._terminalSelector} .${u}.${a} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${u}.${a} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${u} .xterm-cursor.xterm-cursor-block { background-color: ${C.cursor.css}; color: ${C.cursorAccent.css};}${this._terminalSelector} .${u} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${C.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${u} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${C.cursor.css} inset;}${this._terminalSelector} .${u} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${C.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, L += `${this._terminalSelector} .${g} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${g} div { position: absolute; background-color: ${C.selectionBackgroundOpaque.css};}${this._terminalSelector} .${g} div { position: absolute; background-color: ${C.selectionInactiveBackgroundOpaque.css};}`; for (const [R, D] of C.ansi.entries()) L += `${this._terminalSelector} .${p}${R} { color: ${D.css}; }${this._terminalSelector} .${p}${R}.xterm-dim { color: ${e.color.multiplyOpacity(D, .5).css}; }${this._terminalSelector} .${S}${R} { background-color: ${D.css}; }`; L += `${this._terminalSelector} .${p}${_.INVERTED_DEFAULT_COLOR} { color: ${e.color.opaque(C.background).css}; }${this._terminalSelector} .${p}${_.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${e.color.multiplyOpacity(e.color.opaque(C.background), .5).css}; }${this._terminalSelector} .${S}${_.INVERTED_DEFAULT_COLOR} { background-color: ${C.foreground.css}; }`, this._themeStyleElement.textContent = L } _setDefaultSpacing() { const C = this.dimensions.css.cell.width - this._widthCache.get("W", !1, !1); this._rowContainer.style.letterSpacing = `${C}px`, this._rowFactory.defaultSpacing = C } handleDevicePixelRatioChange() { this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing() } _refreshRowElements(C, L) { for (let R = this._rowElements.length; R <= L; R++) { const D = document.createElement("div"); this._rowContainer.appendChild(D), this._rowElements.push(D) } for (; this._rowElements.length > L;)this._rowContainer.removeChild(this._rowElements.pop()) } handleResize(C, L) { this._refreshRowElements(C, L), this._updateDimensions() } handleCharSizeChanged() { this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing() } handleBlur() { this._rowContainer.classList.remove(a) } handleFocus() { this._rowContainer.classList.add(a), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y) } handleSelectionChanged(C, L, R) { if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(C, L, R), this.renderRows(0, this._bufferService.rows - 1), !C || !L) return; const D = C[1] - this._bufferService.buffer.ydisp, M = L[1] - this._bufferService.buffer.ydisp, k = Math.max(D, 0), b = Math.min(M, this._bufferService.rows - 1); if (k >= this._bufferService.rows || b < 0) return; const E = document.createDocumentFragment(); if (R) { const x = C[0] > L[0]; E.appendChild(this._createSelectionElement(k, x ? L[0] : C[0], x ? C[0] : L[0], b - k + 1)) } else { const x = D === k ? C[0] : 0, A = k === M ? L[0] : this._bufferService.cols; E.appendChild(this._createSelectionElement(k, x, A)); const B = b - k - 1; if (E.appendChild(this._createSelectionElement(k + 1, 0, this._bufferService.cols, B)), k !== b) { const F = M === b ? L[0] : this._bufferService.cols; E.appendChild(this._createSelectionElement(b, 0, F)) } } this._selectionContainer.appendChild(E) } _createSelectionElement(C, L, R, D = 1) { const M = document.createElement("div"); return M.style.height = D * this.dimensions.css.cell.height + "px", M.style.top = C * this.dimensions.css.cell.height + "px", M.style.left = L * this.dimensions.css.cell.width + "px", M.style.width = this.dimensions.css.cell.width * (R - L) + "px", M } handleCursorMove() { } _handleOptionsChanged() { this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing() } clear() { for (const C of this._rowElements) C.replaceChildren() } renderRows(C, L) { const R = this._bufferService.buffer, D = R.ybase + R.y, M = Math.min(R.x, this._bufferService.cols - 1), k = this._optionsService.rawOptions.cursorBlink, b = this._optionsService.rawOptions.cursorStyle, E = this._optionsService.rawOptions.cursorInactiveStyle; for (let x = C; x <= L; x++) { const A = x + R.ydisp, B = this._rowElements[x], F = R.lines.get(A); if (!B || !F) break; B.replaceChildren(...this._rowFactory.createRow(F, A, A === D, b, E, M, k, this.dimensions.css.cell.width, this._widthCache, -1, -1)) } } get _terminalSelector() { return `.${d}${this._terminalClass}` } _handleLinkHover(C) { this._setCellUnderline(C.x1, C.x2, C.y1, C.y2, C.cols, !0) } _handleLinkLeave(C) { this._setCellUnderline(C.x1, C.x2, C.y1, C.y2, C.cols, !1) } _setCellUnderline(C, L, R, D, M, k) { R < 0 && (C = 0), D < 0 && (L = 0); const b = this._bufferService.rows - 1; R = Math.max(Math.min(R, b), 0), D = Math.max(Math.min(D, b), 0), M = Math.min(M, this._bufferService.cols); const E = this._bufferService.buffer, x = E.ybase + E.y, A = Math.min(E.x, M - 1), B = this._optionsService.rawOptions.cursorBlink, F = this._optionsService.rawOptions.cursorStyle, H = this._optionsService.rawOptions.cursorInactiveStyle; for (let W = R; W <= D; ++W) { const N = W + E.ydisp, y = this._rowElements[W], T = E.lines.get(N); if (!y || !T) break; y.replaceChildren(...this._rowFactory.createRow(T, N, N === x, F, H, A, B, this.dimensions.css.cell.width, this._widthCache, k ? W === R ? C : 0 : -1, k ? (W === D ? L : M) - 1 : -1)) } } }; t.DomRenderer = m = c([f(4, r.IInstantiationService), f(5, o.ICharSizeService), f(6, r.IOptionsService), f(7, r.IBufferService), f(8, o.ICoreBrowserService), f(9, o.IThemeService)], m) }, 3787: function (P, t, h) { var c = this && this.__decorate || function (p, S, a, g) { var w, m = arguments.length, C = m < 3 ? S : g === null ? g = Object.getOwnPropertyDescriptor(S, a) : g; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") C = Reflect.decorate(p, S, a, g); else for (var L = p.length - 1; L >= 0; L--)(w = p[L]) && (C = (m < 3 ? w(C) : m > 3 ? w(S, a, C) : w(S, a)) || C); return m > 3 && C && Object.defineProperty(S, a, C), C }, f = this && this.__param || function (p, S) { return function (a, g) { S(a, g, p) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.DomRendererRowFactory = void 0; const n = h(2223), l = h(643), _ = h(511), v = h(2585), o = h(8055), e = h(4725), s = h(4269), i = h(6171), r = h(3734); let d = t.DomRendererRowFactory = class { constructor(p, S, a, g, w, m, C) { this._document = p, this._characterJoinerService = S, this._optionsService = a, this._coreBrowserService = g, this._coreService = w, this._decorationService = m, this._themeService = C, this._workCell = new _.CellData, this._columnSelectMode = !1, this.defaultSpacing = 0 } handleSelectionChanged(p, S, a) { this._selectionStart = p, this._selectionEnd = S, this._columnSelectMode = a } createRow(p, S, a, g, w, m, C, L, R, D, M) { const k = [], b = this._characterJoinerService.getJoinedCharacters(S), E = this._themeService.colors; let x, A = p.getNoBgTrimmedLength(); a && A < m + 1 && (A = m + 1); let B = 0, F = "", H = 0, W = 0, N = 0, y = !1, T = 0, I = !1, O = 0; const z = [], $ = D !== -1 && M !== -1; for (let V = 0; V < A; V++) { p.loadCell(V, this._workCell); let ee = this._workCell.getWidth(); if (ee === 0) continue; let te = !1, Z = V, q = this._workCell; if (b.length > 0 && V === b[0][0]) { te = !0; const K = b.shift(); q = new s.JoinedCellData(this._workCell, p.translateToString(!0, K[0], K[1]), K[1] - K[0]), Z = K[1] - 1, ee = q.getWidth() } const le = this._isCellInSelection(V, S), ce = a && V === m, _e = $ && V >= D && V <= M; let fe = !1; this._decorationService.forEachDecorationAtCell(V, S, void 0, K => { fe = !0 }); let X = q.getChars() || l.WHITESPACE_CELL_CHAR; if (X === " " && (q.isUnderline() || q.isOverline()) && (X = "Â "), O = ee * L - R.get(X, q.isBold(), q.isItalic()), x) { if (B && (le && I || !le && !I && q.bg === H) && (le && I && E.selectionForeground || q.fg === W) && q.extended.ext === N && _e === y && O === T && !ce && !te && !fe) { F += X, B++; continue } B && (x.textContent = F), x = this._document.createElement("span"), B = 0, F = "" } else x = this._document.createElement("span"); if (H = q.bg, W = q.fg, N = q.extended.ext, y = _e, T = O, I = le, te && m >= V && m <= Z && (m = V), !this._coreService.isCursorHidden && ce) { if (z.push("xterm-cursor"), this._coreBrowserService.isFocused) C && z.push("xterm-cursor-blink"), z.push(g === "bar" ? "xterm-cursor-bar" : g === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block"); else if (w) switch (w) { case "outline": z.push("xterm-cursor-outline"); break; case "block": z.push("xterm-cursor-block"); break; case "bar": z.push("xterm-cursor-bar"); break; case "underline": z.push("xterm-cursor-underline") } } if (q.isBold() && z.push("xterm-bold"), q.isItalic() && z.push("xterm-italic"), q.isDim() && z.push("xterm-dim"), F = q.isInvisible() ? l.WHITESPACE_CELL_CHAR : q.getChars() || l.WHITESPACE_CELL_CHAR, q.isUnderline() && (z.push(`xterm-underline-${q.extended.underlineStyle}`), F === " " && (F = "Â "), !q.isUnderlineColorDefault())) if (q.isUnderlineColorRGB()) x.style.textDecorationColor = `rgb(${r.AttributeData.toColorRGB(q.getUnderlineColor()).join(",")})`; else { let K = q.getUnderlineColor(); this._optionsService.rawOptions.drawBoldTextInBrightColors && q.isBold() && K < 8 && (K += 8), x.style.textDecorationColor = E.ansi[K].css } q.isOverline() && (z.push("xterm-overline"), F === " " && (F = "Â ")), q.isStrikethrough() && z.push("xterm-strikethrough"), _e && (x.style.textDecoration = "underline"); let j = q.getFgColor(), G = q.getFgColorMode(), U = q.getBgColor(), Y = q.getBgColorMode(); const ne = !!q.isInverse(); if (ne) { const K = j; j = U, U = K; const he = G; G = Y, Y = he } let Q, de, oe, se = !1; switch (this._decorationService.forEachDecorationAtCell(V, S, void 0, K => { K.options.layer !== "top" && se || (K.backgroundColorRGB && (Y = 50331648, U = K.backgroundColorRGB.rgba >> 8 & 16777215, Q = K.backgroundColorRGB), K.foregroundColorRGB && (G = 50331648, j = K.foregroundColorRGB.rgba >> 8 & 16777215, de = K.foregroundColorRGB), se = K.options.layer === "top") }), !se && le && (Q = this._coreBrowserService.isFocused ? E.selectionBackgroundOpaque : E.selectionInactiveBackgroundOpaque, U = Q.rgba >> 8 & 16777215, Y = 50331648, se = !0, E.selectionForeground && (G = 50331648, j = E.selectionForeground.rgba >> 8 & 16777215, de = E.selectionForeground)), se && z.push("xterm-decoration-top"), Y) { case 16777216: case 33554432: oe = E.ansi[U], z.push(`xterm-bg-${U}`); break; case 50331648: oe = o.rgba.toColor(U >> 16, U >> 8 & 255, 255 & U), this._addStyle(x, `background-color:#${u((U >>> 0).toString(16), "0", 6)}`); break; default: ne ? (oe = E.foreground, z.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : oe = E.background }switch (Q || q.isDim() && (Q = o.color.multiplyOpacity(oe, .5)), G) { case 16777216: case 33554432: q.isBold() && j < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (j += 8), this._applyMinimumContrast(x, oe, E.ansi[j], q, Q, void 0) || z.push(`xterm-fg-${j}`); break; case 50331648: const K = o.rgba.toColor(j >> 16 & 255, j >> 8 & 255, 255 & j); this._applyMinimumContrast(x, oe, K, q, Q, de) || this._addStyle(x, `color:#${u(j.toString(16), "0", 6)}`); break; default: this._applyMinimumContrast(x, oe, E.foreground, q, Q, void 0) || ne && z.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`) }z.length && (x.className = z.join(" "), z.length = 0), ce || te || fe ? x.textContent = F : B++, O !== this.defaultSpacing && (x.style.letterSpacing = `${O}px`), k.push(x), V = Z } return x && B && (x.textContent = F), k } _applyMinimumContrast(p, S, a, g, w, m) { if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, i.excludeFromContrastRatioDemands)(g.getCode())) return !1; const C = this._getContrastCache(g); let L; if (w || m || (L = C.getColor(S.rgba, a.rgba)), L === void 0) { const R = this._optionsService.rawOptions.minimumContrastRatio / (g.isDim() ? 2 : 1); L = o.color.ensureContrastRatio(w || S, m || a, R), C.setColor((w || S).rgba, (m || a).rgba, L ?? null) } return !!L && (this._addStyle(p, `color:${L.css}`), !0) } _getContrastCache(p) { return p.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache } _addStyle(p, S) { p.setAttribute("style", `${p.getAttribute("style") || ""}${S};`) } _isCellInSelection(p, S) { const a = this._selectionStart, g = this._selectionEnd; return !(!a || !g) && (this._columnSelectMode ? a[0] <= g[0] ? p >= a[0] && S >= a[1] && p < g[0] && S <= g[1] : p < a[0] && S >= a[1] && p >= g[0] && S <= g[1] : S > a[1] && S < g[1] || a[1] === g[1] && S === a[1] && p >= a[0] && p < g[0] || a[1] < g[1] && S === g[1] && p < g[0] || a[1] < g[1] && S === a[1] && p >= a[0]) } }; function u(p, S, a) { for (; p.length < a;)p = S + p; return p } t.DomRendererRowFactory = d = c([f(1, e.ICharacterJoinerService), f(2, v.IOptionsService), f(3, e.ICoreBrowserService), f(4, v.ICoreService), f(5, v.IDecorationService), f(6, e.IThemeService)], d) }, 2550: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.WidthCache = void 0, t.WidthCache = class { constructor(h) { this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = h.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none"; const c = h.createElement("span"), f = h.createElement("span"); f.style.fontWeight = "bold"; const n = h.createElement("span"); n.style.fontStyle = "italic"; const l = h.createElement("span"); l.style.fontWeight = "bold", l.style.fontStyle = "italic", this._measureElements = [c, f, n, l], this._container.appendChild(c), this._container.appendChild(f), this._container.appendChild(n), this._container.appendChild(l), h.body.appendChild(this._container), this.clear() } dispose() { this._container.remove(), this._measureElements.length = 0, this._holey = void 0 } clear() { this._flat.fill(-9999), this._holey = new Map } setFont(h, c, f, n) { h === this._font && c === this._fontSize && f === this._weight && n === this._weightBold || (this._font = h, this._fontSize = c, this._weight = f, this._weightBold = n, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${f}`, this._measureElements[1].style.fontWeight = `${n}`, this._measureElements[2].style.fontWeight = `${f}`, this._measureElements[3].style.fontWeight = `${n}`, this.clear()) } get(h, c, f) { let n = 0; if (!c && !f && h.length === 1 && (n = h.charCodeAt(0)) < 256) return this._flat[n] !== -9999 ? this._flat[n] : this._flat[n] = this._measure(h, 0); let l = h; c && (l += "B"), f && (l += "I"); let _ = this._holey.get(l); if (_ === void 0) { let v = 0; c && (v |= 1), f && (v |= 2), _ = this._measure(h, v), this._holey.set(l, _) } return _ } _measure(h, c) { const f = this._measureElements[c]; return f.textContent = h.repeat(32), f.offsetWidth / 32 } } }, 2223: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0; const c = h(6114); t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic" }, 6171: (P, t) => { function h(c) { return 57508 <= c && c <= 57558 } Object.defineProperty(t, "__esModule", { value: !0 }), t.createRenderDimensions = t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function (c) { if (!c) throw new Error("value must not be falsy"); return c }, t.isPowerlineGlyph = h, t.isRestrictedPowerlineGlyph = function (c) { return 57520 <= c && c <= 57527 }, t.excludeFromContrastRatioDemands = function (c) { return h(c) || function (f) { return 9472 <= f && f <= 9631 }(c) }, t.createRenderDimensions = function () { return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } } } }, 456: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.SelectionModel = void 0, t.SelectionModel = class { constructor(h) { this._bufferService = h, this.isSelectAllActive = !1, this.selectionStartLength = 0 } clearSelection() { this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0 } get finalSelectionStart() { return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart } get finalSelectionEnd() { if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1]; if (this.selectionStart) { if (!this.selectionEnd || this.areSelectionValuesReversed()) { const h = this.selectionStart[0] + this.selectionStartLength; return h > this._bufferService.cols ? h % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(h / this._bufferService.cols) - 1] : [h % this._bufferService.cols, this.selectionStart[1] + Math.floor(h / this._bufferService.cols)] : [h, this.selectionStart[1]] } if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) { const h = this.selectionStart[0] + this.selectionStartLength; return h > this._bufferService.cols ? [h % this._bufferService.cols, this.selectionStart[1] + Math.floor(h / this._bufferService.cols)] : [Math.max(h, this.selectionEnd[0]), this.selectionEnd[1]] } return this.selectionEnd } } areSelectionValuesReversed() { const h = this.selectionStart, c = this.selectionEnd; return !(!h || !c) && (h[1] > c[1] || h[1] === c[1] && h[0] > c[0]) } handleTrim(h) { return this.selectionStart && (this.selectionStart[1] -= h), this.selectionEnd && (this.selectionEnd[1] -= h), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1) } } }, 428: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.CharSizeService = void 0; const n = h(2585), l = h(8460), _ = h(844); let v = t.CharSizeService = class extends _.Disposable { get hasValidSize() { return this.width > 0 && this.height > 0 } constructor(e, s, i) { super(), this._optionsService = i, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new l.EventEmitter), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new o(e, s, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure())) } measure() { const e = this._measureStrategy.measure(); e.width === this.width && e.height === this.height || (this.width = e.width, this.height = e.height, this._onCharSizeChange.fire()) } }; t.CharSizeService = v = c([f(2, n.IOptionsService)], v); class o { constructor(s, i, r) { this._document = s, this._parentElement = i, this._optionsService = r, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement) } measure() { this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`; const s = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) }; return s.width !== 0 && s.height !== 0 && (this._result.width = s.width / 32, this._result.height = Math.ceil(s.height)), this._result } } }, 4269: function (P, t, h) { var c = this && this.__decorate || function (s, i, r, d) { var u, p = arguments.length, S = p < 3 ? i : d === null ? d = Object.getOwnPropertyDescriptor(i, r) : d; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") S = Reflect.decorate(s, i, r, d); else for (var a = s.length - 1; a >= 0; a--)(u = s[a]) && (S = (p < 3 ? u(S) : p > 3 ? u(i, r, S) : u(i, r)) || S); return p > 3 && S && Object.defineProperty(i, r, S), S }, f = this && this.__param || function (s, i) { return function (r, d) { i(r, d, s) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.CharacterJoinerService = t.JoinedCellData = void 0; const n = h(3734), l = h(643), _ = h(511), v = h(2585); class o extends n.AttributeData { constructor(i, r, d) { super(), this.content = 0, this.combinedData = "", this.fg = i.fg, this.bg = i.bg, this.combinedData = r, this._width = d } isCombined() { return 2097152 } getWidth() { return this._width } getChars() { return this.combinedData } getCode() { return 2097151 } setFromCharData(i) { throw new Error("not implemented") } getAsCharData() { return [this.fg, this.getChars(), this.getWidth(), this.getCode()] } } t.JoinedCellData = o; let e = t.CharacterJoinerService = class be { constructor(i) { this._bufferService = i, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new _.CellData } register(i) { const r = { id: this._nextCharacterJoinerId++, handler: i }; return this._characterJoiners.push(r), r.id } deregister(i) { for (let r = 0; r < this._characterJoiners.length; r++)if (this._characterJoiners[r].id === i) return this._characterJoiners.splice(r, 1), !0; return !1 } getJoinedCharacters(i) { if (this._characterJoiners.length === 0) return []; const r = this._bufferService.buffer.lines.get(i); if (!r || r.length === 0) return []; const d = [], u = r.translateToString(!0); let p = 0, S = 0, a = 0, g = r.getFg(0), w = r.getBg(0); for (let m = 0; m < r.getTrimmedLength(); m++)if (r.loadCell(m, this._workCell), this._workCell.getWidth() !== 0) { if (this._workCell.fg !== g || this._workCell.bg !== w) { if (m - p > 1) { const C = this._getJoinedRanges(u, a, S, r, p); for (let L = 0; L < C.length; L++)d.push(C[L]) } p = m, a = S, g = this._workCell.fg, w = this._workCell.bg } S += this._workCell.getChars().length || l.WHITESPACE_CELL_CHAR.length } if (this._bufferService.cols - p > 1) { const m = this._getJoinedRanges(u, a, S, r, p); for (let C = 0; C < m.length; C++)d.push(m[C]) } return d } _getJoinedRanges(i, r, d, u, p) { const S = i.substring(r, d); let a = []; try { a = this._characterJoiners[0].handler(S) } catch (g) { console.error(g) } for (let g = 1; g < this._characterJoiners.length; g++)try { const w = this._characterJoiners[g].handler(S); for (let m = 0; m < w.length; m++)be._mergeRanges(a, w[m]) } catch (w) { console.error(w) } return this._stringRangesToCellRanges(a, u, p), a } _stringRangesToCellRanges(i, r, d) { let u = 0, p = !1, S = 0, a = i[u]; if (a) { for (let g = d; g < this._bufferService.cols; g++) { const w = r.getWidth(g), m = r.getString(g).length || l.WHITESPACE_CELL_CHAR.length; if (w !== 0) { if (!p && a[0] <= S && (a[0] = g, p = !0), a[1] <= S) { if (a[1] = g, a = i[++u], !a) break; a[0] <= S ? (a[0] = g, p = !0) : p = !1 } S += m } } a && (a[1] = this._bufferService.cols) } } static _mergeRanges(i, r) { let d = !1; for (let u = 0; u < i.length; u++) { const p = i[u]; if (d) { if (r[1] <= p[0]) return i[u - 1][1] = r[1], i; if (r[1] <= p[1]) return i[u - 1][1] = Math.max(r[1], p[1]), i.splice(u, 1), i; i.splice(u, 1), u-- } else { if (r[1] <= p[0]) return i.splice(u, 0, r), i; if (r[1] <= p[1]) return p[0] = Math.min(r[0], p[0]), i; r[0] < p[1] && (p[0] = Math.min(r[0], p[0]), d = !0) } } return d ? i[i.length - 1][1] = r[1] : i.push(r), i } }; t.CharacterJoinerService = e = c([f(0, v.IBufferService)], e) }, 5114: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CoreBrowserService = void 0, t.CoreBrowserService = class { constructor(h, c) { this._textarea = h, this.window = c, this._isFocused = !1, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = !0), this._textarea.addEventListener("blur", () => this._isFocused = !1) } get dpr() { return this.window.devicePixelRatio } get isFocused() { return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused } } }, 8934: function (P, t, h) { var c = this && this.__decorate || function (v, o, e, s) { var i, r = arguments.length, d = r < 3 ? o : s === null ? s = Object.getOwnPropertyDescriptor(o, e) : s; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") d = Reflect.decorate(v, o, e, s); else for (var u = v.length - 1; u >= 0; u--)(i = v[u]) && (d = (r < 3 ? i(d) : r > 3 ? i(o, e, d) : i(o, e)) || d); return r > 3 && d && Object.defineProperty(o, e, d), d }, f = this && this.__param || function (v, o) { return function (e, s) { o(e, s, v) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.MouseService = void 0; const n = h(4725), l = h(9806); let _ = t.MouseService = class { constructor(v, o) { this._renderService = v, this._charSizeService = o } getCoords(v, o, e, s, i) { return (0, l.getCoords)(window, v, o, e, s, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, i) } getMouseReportCoords(v, o) { const e = (0, l.getCoordsRelativeToElement)(window, v, o); if (this._charSizeService.hasValidSize) return e[0] = Math.min(Math.max(e[0], 0), this._renderService.dimensions.css.canvas.width - 1), e[1] = Math.min(Math.max(e[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(e[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(e[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(e[0]), y: Math.floor(e[1]) } } }; t.MouseService = _ = c([f(0, n.IRenderService), f(1, n.ICharSizeService)], _) }, 3230: function (P, t, h) { var c = this && this.__decorate || function (d, u, p, S) { var a, g = arguments.length, w = g < 3 ? u : S === null ? S = Object.getOwnPropertyDescriptor(u, p) : S; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") w = Reflect.decorate(d, u, p, S); else for (var m = d.length - 1; m >= 0; m--)(a = d[m]) && (w = (g < 3 ? a(w) : g > 3 ? a(u, p, w) : a(u, p)) || w); return g > 3 && w && Object.defineProperty(u, p, w), w }, f = this && this.__param || function (d, u) { return function (p, S) { u(p, S, d) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.RenderService = void 0; const n = h(3656), l = h(6193), _ = h(5596), v = h(4725), o = h(8460), e = h(844), s = h(7226), i = h(2585); let r = t.RenderService = class extends e.Disposable { get dimensions() { return this._renderer.value.dimensions } constructor(d, u, p, S, a, g, w, m) { if (super(), this._rowCount = d, this._charSizeService = S, this._renderer = this.register(new e.MutableDisposable), this._pausedResizeTask = new s.DebouncedIdleTask, this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: !1 }, this._onDimensionsChange = this.register(new o.EventEmitter), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new o.EventEmitter), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new o.EventEmitter), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new o.EventEmitter), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new l.RenderDebouncer(w.window, (C, L) => this._renderRows(C, L)), this.register(this._renderDebouncer), this._screenDprMonitor = new _.ScreenDprMonitor(w.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(g.onResize(() => this._fullRefresh())), this.register(g.buffers.onBufferActivate(() => { var C; return (C = this._renderer.value) === null || C === void 0 ? void 0 : C.clear() })), this.register(p.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(a.onDecorationRegistered(() => this._fullRefresh())), this.register(a.onDecorationRemoved(() => this._fullRefresh())), this.register(p.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => { this.clear(), this.handleResize(g.cols, g.rows), this._fullRefresh() })), this.register(p.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(g.buffer.y, g.buffer.y, !0))), this.register((0, n.addDisposableDomListener)(w.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(m.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in w.window) { const C = new w.window.IntersectionObserver(L => this._handleIntersectionChange(L[L.length - 1]), { threshold: 0 }); C.observe(u), this.register({ dispose: () => C.disconnect() }) } } _handleIntersectionChange(d) { this._isPaused = d.isIntersecting === void 0 ? d.intersectionRatio === 0 : !d.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1) } refreshRows(d, u, p = !1) { this._isPaused ? this._needsFullRefresh = !0 : (p || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(d, u, this._rowCount)) } _renderRows(d, u) { this._renderer.value && (d = Math.min(d, this._rowCount - 1), u = Math.min(u, this._rowCount - 1), this._renderer.value.renderRows(d, u), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: d, end: u }), this._onRender.fire({ start: d, end: u }), this._isNextRenderRedrawOnly = !0) } resize(d, u) { this._rowCount = u, this._fireOnCanvasResize() } _handleOptionsChanged() { this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize()) } _fireOnCanvasResize() { this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions)) } hasRenderer() { return !!this._renderer.value } setRenderer(d) { this._renderer.value = d, this._renderer.value.onRequestRedraw(u => this.refreshRows(u.start, u.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh() } addRefreshCallback(d) { return this._renderDebouncer.addRefreshCallback(d) } _fullRefresh() { this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1) } clearTextureAtlas() { var d, u; this._renderer.value && ((u = (d = this._renderer.value).clearTextureAtlas) === null || u === void 0 || u.call(d), this._fullRefresh()) } handleDevicePixelRatioChange() { this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1)) } handleResize(d, u) { this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(d, u)) : this._renderer.value.handleResize(d, u), this._fullRefresh()) } handleCharSizeChanged() { var d; (d = this._renderer.value) === null || d === void 0 || d.handleCharSizeChanged() } handleBlur() { var d; (d = this._renderer.value) === null || d === void 0 || d.handleBlur() } handleFocus() { var d; (d = this._renderer.value) === null || d === void 0 || d.handleFocus() } handleSelectionChanged(d, u, p) { var S; this._selectionState.start = d, this._selectionState.end = u, this._selectionState.columnSelectMode = p, (S = this._renderer.value) === null || S === void 0 || S.handleSelectionChanged(d, u, p) } handleCursorMove() { var d; (d = this._renderer.value) === null || d === void 0 || d.handleCursorMove() } clear() { var d; (d = this._renderer.value) === null || d === void 0 || d.clear() } }; t.RenderService = r = c([f(2, i.IOptionsService), f(3, v.ICharSizeService), f(4, i.IDecorationService), f(5, i.IBufferService), f(6, v.ICoreBrowserService), f(7, v.IThemeService)], r) }, 9312: function (P, t, h) {
        var c = this && this.__decorate || function (a, g, w, m) { var C, L = arguments.length, R = L < 3 ? g : m === null ? m = Object.getOwnPropertyDescriptor(g, w) : m; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") R = Reflect.decorate(a, g, w, m); else for (var D = a.length - 1; D >= 0; D--)(C = a[D]) && (R = (L < 3 ? C(R) : L > 3 ? C(g, w, R) : C(g, w)) || R); return L > 3 && R && Object.defineProperty(g, w, R), R }, f = this && this.__param || function (a, g) { return function (w, m) { g(w, m, a) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.SelectionService = void 0; const n = h(9806), l = h(9504), _ = h(456), v = h(4725), o = h(8460), e = h(844), s = h(6114), i = h(4841), r = h(511), d = h(2585), u = "Â ", p = new RegExp(u, "g"); let S = t.SelectionService = class extends e.Disposable {
          constructor(a, g, w, m, C, L, R, D, M) { super(), this._element = a, this._screenElement = g, this._linkifier = w, this._bufferService = m, this._coreService = C, this._mouseService = L, this._optionsService = R, this._renderService = D, this._coreBrowserService = M, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new r.CellData, this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new o.EventEmitter), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new o.EventEmitter), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new o.EventEmitter), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new o.EventEmitter), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = k => this._handleMouseMove(k), this._mouseUpListener = k => this._handleMouseUp(k), this._coreService.onUserInput(() => { this.hasSelection && this.clearSelection() }), this._trimListener = this._bufferService.buffer.lines.onTrim(k => this._handleTrim(k)), this.register(this._bufferService.buffers.onBufferActivate(k => this._handleBufferActivate(k))), this.enable(), this._model = new _.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, e.toDisposable)(() => { this._removeMouseDownListeners() })) } reset() { this.clearSelection() } disable() { this.clearSelection(), this._enabled = !1 } enable() { this._enabled = !0 } get selectionStart() { return this._model.finalSelectionStart } get selectionEnd() { return this._model.finalSelectionEnd } get hasSelection() { const a = this._model.finalSelectionStart, g = this._model.finalSelectionEnd; return !(!a || !g || a[0] === g[0] && a[1] === g[1]) } get selectionText() {
            const a = this._model.finalSelectionStart, g = this._model.finalSelectionEnd; if (!a || !g) return ""; const w = this._bufferService.buffer, m = []; if (this._activeSelectionMode === 3) { if (a[0] === g[0]) return ""; const C = a[0] < g[0] ? a[0] : g[0], L = a[0] < g[0] ? g[0] : a[0]; for (let R = a[1]; R <= g[1]; R++) { const D = w.translateBufferLineToString(R, !0, C, L); m.push(D) } } else { const C = a[1] === g[1] ? g[0] : void 0; m.push(w.translateBufferLineToString(a[1], !0, a[0], C)); for (let L = a[1] + 1; L <= g[1] - 1; L++) { const R = w.lines.get(L), D = w.translateBufferLineToString(L, !0); R?.isWrapped ? m[m.length - 1] += D : m.push(D) } if (a[1] !== g[1]) { const L = w.lines.get(g[1]), R = w.translateBufferLineToString(g[1], !0, 0, g[0]); L && L.isWrapped ? m[m.length - 1] += R : m.push(R) } } return m.map(C => C.replace(p, " ")).join(s.isWindows ? `\r
`: `
`)
          } clearSelection() { this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire() } refresh(a) { this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), s.isLinux && a && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText) } _refresh() { this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 }) } _isClickInSelection(a) { const g = this._getMouseBufferCoords(a), w = this._model.finalSelectionStart, m = this._model.finalSelectionEnd; return !!(w && m && g) && this._areCoordsInSelection(g, w, m) } isCellInSelection(a, g) { const w = this._model.finalSelectionStart, m = this._model.finalSelectionEnd; return !(!w || !m) && this._areCoordsInSelection([a, g], w, m) } _areCoordsInSelection(a, g, w) { return a[1] > g[1] && a[1] < w[1] || g[1] === w[1] && a[1] === g[1] && a[0] >= g[0] && a[0] < w[0] || g[1] < w[1] && a[1] === w[1] && a[0] < w[0] || g[1] < w[1] && a[1] === g[1] && a[0] >= g[0] } _selectWordAtCursor(a, g) { var w, m; const C = (m = (w = this._linkifier.currentLink) === null || w === void 0 ? void 0 : w.link) === null || m === void 0 ? void 0 : m.range; if (C) return this._model.selectionStart = [C.start.x - 1, C.start.y - 1], this._model.selectionStartLength = (0, i.getRangeLength)(C, this._bufferService.cols), this._model.selectionEnd = void 0, !0; const L = this._getMouseBufferCoords(a); return !!L && (this._selectWordAt(L, g), this._model.selectionEnd = void 0, !0) } selectAll() { this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire() } selectLines(a, g) { this._model.clearSelection(), a = Math.max(a, 0), g = Math.min(g, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, a], this._model.selectionEnd = [this._bufferService.cols, g], this.refresh(), this._onSelectionChange.fire() } _handleTrim(a) { this._model.handleTrim(a) && this.refresh() } _getMouseBufferCoords(a) { const g = this._mouseService.getCoords(a, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0); if (g) return g[0]--, g[1]--, g[1] += this._bufferService.buffer.ydisp, g } _getMouseEventScrollAmount(a) { let g = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, a, this._screenElement)[1]; const w = this._renderService.dimensions.css.canvas.height; return g >= 0 && g <= w ? 0 : (g > w && (g -= w), g = Math.min(Math.max(g, -50), 50), g /= 50, g / Math.abs(g) + Math.round(14 * g)) } shouldForceSelection(a) { return s.isMac ? a.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : a.shiftKey } handleMouseDown(a) { if (this._mouseDownTimeStamp = a.timeStamp, (a.button !== 2 || !this.hasSelection) && a.button === 0) { if (!this._enabled) { if (!this.shouldForceSelection(a)) return; a.stopPropagation() } a.preventDefault(), this._dragScrollAmount = 0, this._enabled && a.shiftKey ? this._handleIncrementalClick(a) : a.detail === 1 ? this._handleSingleClick(a) : a.detail === 2 ? this._handleDoubleClick(a) : a.detail === 3 && this._handleTripleClick(a), this._addMouseDownListeners(), this.refresh(!0) } } _addMouseDownListeners() { this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50) } _removeMouseDownListeners() { this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0 } _handleIncrementalClick(a) { this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(a)) } _handleSingleClick(a) { if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(a) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(a), !this._model.selectionStart) return; this._model.selectionEnd = void 0; const g = this._bufferService.buffer.lines.get(this._model.selectionStart[1]); g && g.length !== this._model.selectionStart[0] && g.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++ } _handleDoubleClick(a) { this._selectWordAtCursor(a, !0) && (this._activeSelectionMode = 1) } _handleTripleClick(a) { const g = this._getMouseBufferCoords(a); g && (this._activeSelectionMode = 2, this._selectLineAt(g[1])) } shouldColumnSelect(a) { return a.altKey && !(s.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection) } _handleMouseMove(a) { if (a.stopImmediatePropagation(), !this._model.selectionStart) return; const g = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null; if (this._model.selectionEnd = this._getMouseBufferCoords(a), !this._model.selectionEnd) return void this.refresh(!0); this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(a), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0)); const w = this._bufferService.buffer; if (this._model.selectionEnd[1] < w.lines.length) { const m = w.lines.get(this._model.selectionEnd[1]); m && m.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++ } g && g[0] === this._model.selectionEnd[0] && g[1] === this._model.selectionEnd[1] || this.refresh(!0) } _dragScroll() { if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) { this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: !1 }); const a = this._bufferService.buffer; this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(a.ydisp + this._bufferService.rows, a.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = a.ydisp), this.refresh() } } _handleMouseUp(a) { const g = a.timeStamp - this._mouseDownTimeStamp; if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && g < 500 && a.altKey && this._optionsService.rawOptions.altClickMovesCursor) { if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) { const w = this._mouseService.getCoords(a, this._element, this._bufferService.cols, this._bufferService.rows, !1); if (w && w[0] !== void 0 && w[1] !== void 0) { const m = (0, l.moveToCellSequence)(w[0] - 1, w[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys); this._coreService.triggerDataEvent(m, !0) } } } else this._fireEventIfSelectionChanged() } _fireEventIfSelectionChanged() { const a = this._model.finalSelectionStart, g = this._model.finalSelectionEnd, w = !(!a || !g || a[0] === g[0] && a[1] === g[1]); w ? a && g && (this._oldSelectionStart && this._oldSelectionEnd && a[0] === this._oldSelectionStart[0] && a[1] === this._oldSelectionStart[1] && g[0] === this._oldSelectionEnd[0] && g[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(a, g, w)) : this._oldHasSelection && this._fireOnSelectionChange(a, g, w) } _fireOnSelectionChange(a, g, w) { this._oldSelectionStart = a, this._oldSelectionEnd = g, this._oldHasSelection = w, this._onSelectionChange.fire() } _handleBufferActivate(a) { this.clearSelection(), this._trimListener.dispose(), this._trimListener = a.activeBuffer.lines.onTrim(g => this._handleTrim(g)) } _convertViewportColToCharacterIndex(a, g) { let w = g; for (let m = 0; g >= m; m++) { const C = a.loadCell(m, this._workCell).getChars().length; this._workCell.getWidth() === 0 ? w-- : C > 1 && g !== m && (w += C - 1) } return w } setSelection(a, g, w) { this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [a, g], this._model.selectionStartLength = w, this.refresh(), this._fireEventIfSelectionChanged() } rightClickSelect(a) { this._isClickInSelection(a) || (this._selectWordAtCursor(a, !1) && this.refresh(!0), this._fireEventIfSelectionChanged()) } _getWordAt(a, g, w = !0, m = !0) { if (a[0] >= this._bufferService.cols) return; const C = this._bufferService.buffer, L = C.lines.get(a[1]); if (!L) return; const R = C.translateBufferLineToString(a[1], !1); let D = this._convertViewportColToCharacterIndex(L, a[0]), M = D; const k = a[0] - D; let b = 0, E = 0, x = 0, A = 0; if (R.charAt(D) === " ") { for (; D > 0 && R.charAt(D - 1) === " ";)D--; for (; M < R.length && R.charAt(M + 1) === " ";)M++ } else { let H = a[0], W = a[0]; L.getWidth(H) === 0 && (b++, H--), L.getWidth(W) === 2 && (E++, W++); const N = L.getString(W).length; for (N > 1 && (A += N - 1, M += N - 1); H > 0 && D > 0 && !this._isCharWordSeparator(L.loadCell(H - 1, this._workCell));) { L.loadCell(H - 1, this._workCell); const y = this._workCell.getChars().length; this._workCell.getWidth() === 0 ? (b++, H--) : y > 1 && (x += y - 1, D -= y - 1), D--, H-- } for (; W < L.length && M + 1 < R.length && !this._isCharWordSeparator(L.loadCell(W + 1, this._workCell));) { L.loadCell(W + 1, this._workCell); const y = this._workCell.getChars().length; this._workCell.getWidth() === 2 ? (E++, W++) : y > 1 && (A += y - 1, M += y - 1), M++, W++ } } M++; let B = D + k - b + x, F = Math.min(this._bufferService.cols, M - D + b + E - x - A); if (g || R.slice(D, M).trim() !== "") { if (w && B === 0 && L.getCodePoint(0) !== 32) { const H = C.lines.get(a[1] - 1); if (H && L.isWrapped && H.getCodePoint(this._bufferService.cols - 1) !== 32) { const W = this._getWordAt([this._bufferService.cols - 1, a[1] - 1], !1, !0, !1); if (W) { const N = this._bufferService.cols - W.start; B -= N, F += N } } } if (m && B + F === this._bufferService.cols && L.getCodePoint(this._bufferService.cols - 1) !== 32) { const H = C.lines.get(a[1] + 1); if (H?.isWrapped && H.getCodePoint(0) !== 32) { const W = this._getWordAt([0, a[1] + 1], !1, !1, !0); W && (F += W.length) } } return { start: B, length: F } } } _selectWordAt(a, g) { const w = this._getWordAt(a, g); if (w) { for (; w.start < 0;)w.start += this._bufferService.cols, a[1]--; this._model.selectionStart = [w.start, a[1]], this._model.selectionStartLength = w.length } } _selectToWordAt(a) { const g = this._getWordAt(a, !0); if (g) { let w = a[1]; for (; g.start < 0;)g.start += this._bufferService.cols, w--; if (!this._model.areSelectionValuesReversed()) for (; g.start + g.length > this._bufferService.cols;)g.length -= this._bufferService.cols, w++; this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? g.start : g.start + g.length, w] } } _isCharWordSeparator(a) { return a.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(a.getChars()) >= 0 } _selectLineAt(a) { const g = this._bufferService.buffer.getWrappedRangeForLine(a), w = { start: { x: 0, y: g.first }, end: { x: this._bufferService.cols - 1, y: g.last } }; this._model.selectionStart = [0, g.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, i.getRangeLength)(w, this._bufferService.cols) }
        }; t.SelectionService = S = c([f(3, d.IBufferService), f(4, d.ICoreService), f(5, v.IMouseService), f(6, d.IOptionsService), f(7, v.IRenderService), f(8, v.ICoreBrowserService)], S)
      }, 4725: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.IThemeService = t.ICharacterJoinerService = t.ISelectionService = t.IRenderService = t.IMouseService = t.ICoreBrowserService = t.ICharSizeService = void 0; const c = h(8343); t.ICharSizeService = (0, c.createDecorator)("CharSizeService"), t.ICoreBrowserService = (0, c.createDecorator)("CoreBrowserService"), t.IMouseService = (0, c.createDecorator)("MouseService"), t.IRenderService = (0, c.createDecorator)("RenderService"), t.ISelectionService = (0, c.createDecorator)("SelectionService"), t.ICharacterJoinerService = (0, c.createDecorator)("CharacterJoinerService"), t.IThemeService = (0, c.createDecorator)("ThemeService") }, 6731: function (P, t, h) { var c = this && this.__decorate || function (S, a, g, w) { var m, C = arguments.length, L = C < 3 ? a : w === null ? w = Object.getOwnPropertyDescriptor(a, g) : w; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") L = Reflect.decorate(S, a, g, w); else for (var R = S.length - 1; R >= 0; R--)(m = S[R]) && (L = (C < 3 ? m(L) : C > 3 ? m(a, g, L) : m(a, g)) || L); return C > 3 && L && Object.defineProperty(a, g, L), L }, f = this && this.__param || function (S, a) { return function (g, w) { a(g, w, S) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.ThemeService = t.DEFAULT_ANSI_COLORS = void 0; const n = h(7239), l = h(8055), _ = h(8460), v = h(844), o = h(2585), e = l.css.toColor("#ffffff"), s = l.css.toColor("#000000"), i = l.css.toColor("#ffffff"), r = l.css.toColor("#000000"), d = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 }; t.DEFAULT_ANSI_COLORS = Object.freeze((() => { const S = [l.css.toColor("#2e3436"), l.css.toColor("#cc0000"), l.css.toColor("#4e9a06"), l.css.toColor("#c4a000"), l.css.toColor("#3465a4"), l.css.toColor("#75507b"), l.css.toColor("#06989a"), l.css.toColor("#d3d7cf"), l.css.toColor("#555753"), l.css.toColor("#ef2929"), l.css.toColor("#8ae234"), l.css.toColor("#fce94f"), l.css.toColor("#729fcf"), l.css.toColor("#ad7fa8"), l.css.toColor("#34e2e2"), l.css.toColor("#eeeeec")], a = [0, 95, 135, 175, 215, 255]; for (let g = 0; g < 216; g++) { const w = a[g / 36 % 6 | 0], m = a[g / 6 % 6 | 0], C = a[g % 6]; S.push({ css: l.channels.toCss(w, m, C), rgba: l.channels.toRgba(w, m, C) }) } for (let g = 0; g < 24; g++) { const w = 8 + 10 * g; S.push({ css: l.channels.toCss(w, w, w), rgba: l.channels.toRgba(w, w, w) }) } return S })()); let u = t.ThemeService = class extends v.Disposable { get colors() { return this._colors } constructor(S) { super(), this._optionsService = S, this._contrastCache = new n.ColorContrastCache, this._halfContrastCache = new n.ColorContrastCache, this._onChangeColors = this.register(new _.EventEmitter), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: e, background: s, cursor: i, cursorAccent: r, selectionForeground: void 0, selectionBackgroundTransparent: d, selectionBackgroundOpaque: l.color.blend(s, d), selectionInactiveBackgroundTransparent: d, selectionInactiveBackgroundOpaque: l.color.blend(s, d), ansi: t.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme))) } _setTheme(S = {}) { const a = this._colors; if (a.foreground = p(S.foreground, e), a.background = p(S.background, s), a.cursor = p(S.cursor, i), a.cursorAccent = p(S.cursorAccent, r), a.selectionBackgroundTransparent = p(S.selectionBackground, d), a.selectionBackgroundOpaque = l.color.blend(a.background, a.selectionBackgroundTransparent), a.selectionInactiveBackgroundTransparent = p(S.selectionInactiveBackground, a.selectionBackgroundTransparent), a.selectionInactiveBackgroundOpaque = l.color.blend(a.background, a.selectionInactiveBackgroundTransparent), a.selectionForeground = S.selectionForeground ? p(S.selectionForeground, l.NULL_COLOR) : void 0, a.selectionForeground === l.NULL_COLOR && (a.selectionForeground = void 0), l.color.isOpaque(a.selectionBackgroundTransparent) && (a.selectionBackgroundTransparent = l.color.opacity(a.selectionBackgroundTransparent, .3)), l.color.isOpaque(a.selectionInactiveBackgroundTransparent) && (a.selectionInactiveBackgroundTransparent = l.color.opacity(a.selectionInactiveBackgroundTransparent, .3)), a.ansi = t.DEFAULT_ANSI_COLORS.slice(), a.ansi[0] = p(S.black, t.DEFAULT_ANSI_COLORS[0]), a.ansi[1] = p(S.red, t.DEFAULT_ANSI_COLORS[1]), a.ansi[2] = p(S.green, t.DEFAULT_ANSI_COLORS[2]), a.ansi[3] = p(S.yellow, t.DEFAULT_ANSI_COLORS[3]), a.ansi[4] = p(S.blue, t.DEFAULT_ANSI_COLORS[4]), a.ansi[5] = p(S.magenta, t.DEFAULT_ANSI_COLORS[5]), a.ansi[6] = p(S.cyan, t.DEFAULT_ANSI_COLORS[6]), a.ansi[7] = p(S.white, t.DEFAULT_ANSI_COLORS[7]), a.ansi[8] = p(S.brightBlack, t.DEFAULT_ANSI_COLORS[8]), a.ansi[9] = p(S.brightRed, t.DEFAULT_ANSI_COLORS[9]), a.ansi[10] = p(S.brightGreen, t.DEFAULT_ANSI_COLORS[10]), a.ansi[11] = p(S.brightYellow, t.DEFAULT_ANSI_COLORS[11]), a.ansi[12] = p(S.brightBlue, t.DEFAULT_ANSI_COLORS[12]), a.ansi[13] = p(S.brightMagenta, t.DEFAULT_ANSI_COLORS[13]), a.ansi[14] = p(S.brightCyan, t.DEFAULT_ANSI_COLORS[14]), a.ansi[15] = p(S.brightWhite, t.DEFAULT_ANSI_COLORS[15]), S.extendedAnsi) { const g = Math.min(a.ansi.length - 16, S.extendedAnsi.length); for (let w = 0; w < g; w++)a.ansi[w + 16] = p(S.extendedAnsi[w], t.DEFAULT_ANSI_COLORS[w + 16]) } this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors) } restoreColor(S) { this._restoreColor(S), this._onChangeColors.fire(this.colors) } _restoreColor(S) { if (S !== void 0) switch (S) { case 256: this._colors.foreground = this._restoreColors.foreground; break; case 257: this._colors.background = this._restoreColors.background; break; case 258: this._colors.cursor = this._restoreColors.cursor; break; default: this._colors.ansi[S] = this._restoreColors.ansi[S] } else for (let a = 0; a < this._restoreColors.ansi.length; ++a)this._colors.ansi[a] = this._restoreColors.ansi[a] } modifyColors(S) { S(this._colors), this._onChangeColors.fire(this.colors) } _updateRestoreColors() { this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() } } }; function p(S, a) { if (S !== void 0) try { return l.css.toColor(S) } catch { } return a } t.ThemeService = u = c([f(0, o.IOptionsService)], u) }, 6349: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CircularList = void 0; const c = h(8460), f = h(844); class n extends f.Disposable { constructor(_) { super(), this._maxLength = _, this.onDeleteEmitter = this.register(new c.EventEmitter), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new c.EventEmitter), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new c.EventEmitter), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0 } get maxLength() { return this._maxLength } set maxLength(_) { if (this._maxLength === _) return; const v = new Array(_); for (let o = 0; o < Math.min(_, this.length); o++)v[o] = this._array[this._getCyclicIndex(o)]; this._array = v, this._maxLength = _, this._startIndex = 0 } get length() { return this._length } set length(_) { if (_ > this._length) for (let v = this._length; v < _; v++)this._array[v] = void 0; this._length = _ } get(_) { return this._array[this._getCyclicIndex(_)] } set(_, v) { this._array[this._getCyclicIndex(_)] = v } push(_) { this._array[this._getCyclicIndex(this._length)] = _, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++ } recycle() { if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full"); return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)] } get isFull() { return this._length === this._maxLength } pop() { return this._array[this._getCyclicIndex(this._length-- - 1)] } splice(_, v, ...o) { if (v) { for (let e = _; e < this._length - v; e++)this._array[this._getCyclicIndex(e)] = this._array[this._getCyclicIndex(e + v)]; this._length -= v, this.onDeleteEmitter.fire({ index: _, amount: v }) } for (let e = this._length - 1; e >= _; e--)this._array[this._getCyclicIndex(e + o.length)] = this._array[this._getCyclicIndex(e)]; for (let e = 0; e < o.length; e++)this._array[this._getCyclicIndex(_ + e)] = o[e]; if (o.length && this.onInsertEmitter.fire({ index: _, amount: o.length }), this._length + o.length > this._maxLength) { const e = this._length + o.length - this._maxLength; this._startIndex += e, this._length = this._maxLength, this.onTrimEmitter.fire(e) } else this._length += o.length } trimStart(_) { _ > this._length && (_ = this._length), this._startIndex += _, this._length -= _, this.onTrimEmitter.fire(_) } shiftElements(_, v, o) { if (!(v <= 0)) { if (_ < 0 || _ >= this._length) throw new Error("start argument out of range"); if (_ + o < 0) throw new Error("Cannot shift elements in list beyond index 0"); if (o > 0) { for (let s = v - 1; s >= 0; s--)this.set(_ + s + o, this.get(_ + s)); const e = _ + v + o - this._length; if (e > 0) for (this._length += e; this._length > this._maxLength;)this._length--, this._startIndex++, this.onTrimEmitter.fire(1) } else for (let e = 0; e < v; e++)this.set(_ + e + o, this.get(_ + e)) } } _getCyclicIndex(_) { return (this._startIndex + _) % this._maxLength } } t.CircularList = n }, 1439: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.clone = void 0, t.clone = function h(c, f = 5) { if (typeof c != "object") return c; const n = Array.isArray(c) ? [] : {}; for (const l in c) n[l] = f <= 1 ? c[l] : c[l] && h(c[l], f - 1); return n } }, 8055: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = t.NULL_COLOR = void 0; const c = h(6114); let f = 0, n = 0, l = 0, _ = 0; var v, o, e, s, i; function r(u) { const p = u.toString(16); return p.length < 2 ? "0" + p : p } function d(u, p) { return u < p ? (p + .05) / (u + .05) : (u + .05) / (p + .05) } t.NULL_COLOR = { css: "#00000000", rgba: 0 }, function (u) { u.toCss = function (p, S, a, g) { return g !== void 0 ? `#${r(p)}${r(S)}${r(a)}${r(g)}` : `#${r(p)}${r(S)}${r(a)}` }, u.toRgba = function (p, S, a, g = 255) { return (p << 24 | S << 16 | a << 8 | g) >>> 0 } }(v || (t.channels = v = {})), function (u) { function p(S, a) { return _ = Math.round(255 * a), [f, n, l] = i.toChannels(S.rgba), { css: v.toCss(f, n, l, _), rgba: v.toRgba(f, n, l, _) } } u.blend = function (S, a) { if (_ = (255 & a.rgba) / 255, _ === 1) return { css: a.css, rgba: a.rgba }; const g = a.rgba >> 24 & 255, w = a.rgba >> 16 & 255, m = a.rgba >> 8 & 255, C = S.rgba >> 24 & 255, L = S.rgba >> 16 & 255, R = S.rgba >> 8 & 255; return f = C + Math.round((g - C) * _), n = L + Math.round((w - L) * _), l = R + Math.round((m - R) * _), { css: v.toCss(f, n, l), rgba: v.toRgba(f, n, l) } }, u.isOpaque = function (S) { return (255 & S.rgba) == 255 }, u.ensureContrastRatio = function (S, a, g) { const w = i.ensureContrastRatio(S.rgba, a.rgba, g); if (w) return i.toColor(w >> 24 & 255, w >> 16 & 255, w >> 8 & 255) }, u.opaque = function (S) { const a = (255 | S.rgba) >>> 0; return [f, n, l] = i.toChannels(a), { css: v.toCss(f, n, l), rgba: a } }, u.opacity = p, u.multiplyOpacity = function (S, a) { return _ = 255 & S.rgba, p(S, _ * a / 255) }, u.toColorRGB = function (S) { return [S.rgba >> 24 & 255, S.rgba >> 16 & 255, S.rgba >> 8 & 255] } }(o || (t.color = o = {})), function (u) { let p, S; if (!c.isNode) { const a = document.createElement("canvas"); a.width = 1, a.height = 1; const g = a.getContext("2d", { willReadFrequently: !0 }); g && (p = g, p.globalCompositeOperation = "copy", S = p.createLinearGradient(0, 0, 1, 1)) } u.toColor = function (a) { if (a.match(/#[\da-f]{3,8}/i)) switch (a.length) { case 4: return f = parseInt(a.slice(1, 2).repeat(2), 16), n = parseInt(a.slice(2, 3).repeat(2), 16), l = parseInt(a.slice(3, 4).repeat(2), 16), i.toColor(f, n, l); case 5: return f = parseInt(a.slice(1, 2).repeat(2), 16), n = parseInt(a.slice(2, 3).repeat(2), 16), l = parseInt(a.slice(3, 4).repeat(2), 16), _ = parseInt(a.slice(4, 5).repeat(2), 16), i.toColor(f, n, l, _); case 7: return { css: a, rgba: (parseInt(a.slice(1), 16) << 8 | 255) >>> 0 }; case 9: return { css: a, rgba: parseInt(a.slice(1), 16) >>> 0 } }const g = a.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/); if (g) return f = parseInt(g[1]), n = parseInt(g[2]), l = parseInt(g[3]), _ = Math.round(255 * (g[5] === void 0 ? 1 : parseFloat(g[5]))), i.toColor(f, n, l, _); if (!p || !S) throw new Error("css.toColor: Unsupported css format"); if (p.fillStyle = S, p.fillStyle = a, typeof p.fillStyle != "string") throw new Error("css.toColor: Unsupported css format"); if (p.fillRect(0, 0, 1, 1), [f, n, l, _] = p.getImageData(0, 0, 1, 1).data, _ !== 255) throw new Error("css.toColor: Unsupported css format"); return { rgba: v.toRgba(f, n, l, _), css: a } } }(e || (t.css = e = {})), function (u) { function p(S, a, g) { const w = S / 255, m = a / 255, C = g / 255; return .2126 * (w <= .03928 ? w / 12.92 : Math.pow((w + .055) / 1.055, 2.4)) + .7152 * (m <= .03928 ? m / 12.92 : Math.pow((m + .055) / 1.055, 2.4)) + .0722 * (C <= .03928 ? C / 12.92 : Math.pow((C + .055) / 1.055, 2.4)) } u.relativeLuminance = function (S) { return p(S >> 16 & 255, S >> 8 & 255, 255 & S) }, u.relativeLuminance2 = p }(s || (t.rgb = s = {})), function (u) { function p(a, g, w) { const m = a >> 24 & 255, C = a >> 16 & 255, L = a >> 8 & 255; let R = g >> 24 & 255, D = g >> 16 & 255, M = g >> 8 & 255, k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); for (; k < w && (R > 0 || D > 0 || M > 0);)R -= Math.max(0, Math.ceil(.1 * R)), D -= Math.max(0, Math.ceil(.1 * D)), M -= Math.max(0, Math.ceil(.1 * M)), k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); return (R << 24 | D << 16 | M << 8 | 255) >>> 0 } function S(a, g, w) { const m = a >> 24 & 255, C = a >> 16 & 255, L = a >> 8 & 255; let R = g >> 24 & 255, D = g >> 16 & 255, M = g >> 8 & 255, k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); for (; k < w && (R < 255 || D < 255 || M < 255);)R = Math.min(255, R + Math.ceil(.1 * (255 - R))), D = Math.min(255, D + Math.ceil(.1 * (255 - D))), M = Math.min(255, M + Math.ceil(.1 * (255 - M))), k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); return (R << 24 | D << 16 | M << 8 | 255) >>> 0 } u.ensureContrastRatio = function (a, g, w) { const m = s.relativeLuminance(a >> 8), C = s.relativeLuminance(g >> 8); if (d(m, C) < w) { if (C < m) { const D = p(a, g, w), M = d(m, s.relativeLuminance(D >> 8)); if (M < w) { const k = S(a, g, w); return M > d(m, s.relativeLuminance(k >> 8)) ? D : k } return D } const L = S(a, g, w), R = d(m, s.relativeLuminance(L >> 8)); if (R < w) { const D = p(a, g, w); return R > d(m, s.relativeLuminance(D >> 8)) ? L : D } return L } }, u.reduceLuminance = p, u.increaseLuminance = S, u.toChannels = function (a) { return [a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a] }, u.toColor = function (a, g, w, m) { return { css: v.toCss(a, g, w, m), rgba: v.toRgba(a, g, w, m) } } }(i || (t.rgba = i = {})), t.toPaddedHex = r, t.contrastRatio = d }, 8969: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CoreTerminal = void 0; const c = h(844), f = h(2585), n = h(4348), l = h(7866), _ = h(744), v = h(7302), o = h(6975), e = h(8460), s = h(1753), i = h(1480), r = h(7994), d = h(9282), u = h(5435), p = h(5981), S = h(2660); let a = !1; class g extends c.Disposable { get onScroll() { return this._onScrollApi || (this._onScrollApi = this.register(new e.EventEmitter), this._onScroll.event(m => { var C; (C = this._onScrollApi) === null || C === void 0 || C.fire(m.position) })), this._onScrollApi.event } get cols() { return this._bufferService.cols } get rows() { return this._bufferService.rows } get buffers() { return this._bufferService.buffers } get options() { return this.optionsService.options } set options(m) { for (const C in m) this.optionsService.options[C] = m[C] } constructor(m) { super(), this._windowsWrappingHeuristics = this.register(new c.MutableDisposable), this._onBinary = this.register(new e.EventEmitter), this.onBinary = this._onBinary.event, this._onData = this.register(new e.EventEmitter), this.onData = this._onData.event, this._onLineFeed = this.register(new e.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new e.EventEmitter), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new e.EventEmitter), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new e.EventEmitter), this._instantiationService = new n.InstantiationService, this.optionsService = this.register(new v.OptionsService(m)), this._instantiationService.setService(f.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(_.BufferService)), this._instantiationService.setService(f.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(l.LogService)), this._instantiationService.setService(f.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(o.CoreService)), this._instantiationService.setService(f.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(s.CoreMouseService)), this._instantiationService.setService(f.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(i.UnicodeService)), this._instantiationService.setService(f.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(r.CharsetService), this._instantiationService.setService(f.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(S.OscLinkService), this._instantiationService.setService(f.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new u.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, e.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, e.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, e.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, e.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll(C => { this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom) })), this.register(this._inputHandler.onScroll(C => { this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom) })), this._writeBuffer = this.register(new p.WriteBuffer((C, L) => this._inputHandler.parse(C, L))), this.register((0, e.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed)) } write(m, C) { this._writeBuffer.write(m, C) } writeSync(m, C) { this._logService.logLevel <= f.LogLevelEnum.WARN && !a && (this._logService.warn("writeSync is unreliable and will be removed soon."), a = !0), this._writeBuffer.writeSync(m, C) } resize(m, C) { isNaN(m) || isNaN(C) || (m = Math.max(m, _.MINIMUM_COLS), C = Math.max(C, _.MINIMUM_ROWS), this._bufferService.resize(m, C)) } scroll(m, C = !1) { this._bufferService.scroll(m, C) } scrollLines(m, C, L) { this._bufferService.scrollLines(m, C, L) } scrollPages(m) { this.scrollLines(m * (this.rows - 1)) } scrollToTop() { this.scrollLines(-this._bufferService.buffer.ydisp) } scrollToBottom() { this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp) } scrollToLine(m) { const C = m - this._bufferService.buffer.ydisp; C !== 0 && this.scrollLines(C) } registerEscHandler(m, C) { return this._inputHandler.registerEscHandler(m, C) } registerDcsHandler(m, C) { return this._inputHandler.registerDcsHandler(m, C) } registerCsiHandler(m, C) { return this._inputHandler.registerCsiHandler(m, C) } registerOscHandler(m, C) { return this._inputHandler.registerOscHandler(m, C) } _setup() { this._handleWindowsPtyOptionChange() } reset() { this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset() } _handleWindowsPtyOptionChange() { let m = !1; const C = this.optionsService.rawOptions.windowsPty; C && C.buildNumber !== void 0 && C.buildNumber !== void 0 ? m = C.backend === "conpty" && C.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (m = !0), m ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear() } _enableWindowsWrappingHeuristics() { if (!this._windowsWrappingHeuristics.value) { const m = []; m.push(this.onLineFeed(d.updateWindowsModeWrappedState.bind(null, this._bufferService))), m.push(this.registerCsiHandler({ final: "H" }, () => ((0, d.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, c.toDisposable)(() => { for (const C of m) C.dispose() }) } } } t.CoreTerminal = g }, 8460: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class { constructor() { this._listeners = [], this._disposed = !1 } get event() { return this._event || (this._event = h => (this._listeners.push(h), { dispose: () => { if (!this._disposed) { for (let c = 0; c < this._listeners.length; c++)if (this._listeners[c] === h) return void this._listeners.splice(c, 1) } } })), this._event } fire(h, c) { const f = []; for (let n = 0; n < this._listeners.length; n++)f.push(this._listeners[n]); for (let n = 0; n < f.length; n++)f[n].call(void 0, h, c) } dispose() { this.clearListeners(), this._disposed = !0 } clearListeners() { this._listeners && (this._listeners.length = 0) } }, t.forwardEvent = function (h, c) { return h(f => c.fire(f)) } }, 5435: function (P, t, h) { var c = this && this.__decorate || function (k, b, E, x) { var A, B = arguments.length, F = B < 3 ? b : x === null ? x = Object.getOwnPropertyDescriptor(b, E) : x; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") F = Reflect.decorate(k, b, E, x); else for (var H = k.length - 1; H >= 0; H--)(A = k[H]) && (F = (B < 3 ? A(F) : B > 3 ? A(b, E, F) : A(b, E)) || F); return B > 3 && F && Object.defineProperty(b, E, F), F }, f = this && this.__param || function (k, b) { return function (E, x) { b(E, x, k) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.InputHandler = t.WindowsOptionsReportType = void 0; const n = h(2584), l = h(7116), _ = h(2015), v = h(844), o = h(482), e = h(8437), s = h(8460), i = h(643), r = h(511), d = h(3734), u = h(2585), p = h(6242), S = h(6351), a = h(5941), g = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, w = 131072; function m(k, b) { if (k > 24) return b.setWinLines || !1; switch (k) { case 1: return !!b.restoreWin; case 2: return !!b.minimizeWin; case 3: return !!b.setWinPosition; case 4: return !!b.setWinSizePixels; case 5: return !!b.raiseWin; case 6: return !!b.lowerWin; case 7: return !!b.refreshWin; case 8: return !!b.setWinSizeChars; case 9: return !!b.maximizeWin; case 10: return !!b.fullscreenWin; case 11: return !!b.getWinState; case 13: return !!b.getWinPosition; case 14: return !!b.getWinSizePixels; case 15: return !!b.getScreenSizePixels; case 16: return !!b.getCellSizePixels; case 18: return !!b.getWinSizeChars; case 19: return !!b.getScreenSizeChars; case 20: return !!b.getIconTitle; case 21: return !!b.getWinTitle; case 22: return !!b.pushTitle; case 23: return !!b.popTitle; case 24: return !!b.setWinLines }return !1 } var C; (function (k) { k[k.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", k[k.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS" })(C || (t.WindowsOptionsReportType = C = {})); let L = 0; class R extends v.Disposable { getAttrData() { return this._curAttrData } constructor(b, E, x, A, B, F, H, W, N = new _.EscapeSequenceParser) { super(), this._bufferService = b, this._charsetService = E, this._coreService = x, this._logService = A, this._optionsService = B, this._oscLinkService = F, this._coreMouseService = H, this._unicodeService = W, this._parser = N, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new o.StringToUtf32, this._utf8Decoder = new o.Utf8ToUtf32, this._workCell = new r.CellData, this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new s.EventEmitter), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new s.EventEmitter), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new s.EventEmitter), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new s.EventEmitter), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new s.EventEmitter), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new s.EventEmitter), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new s.EventEmitter), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new s.EventEmitter), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new s.EventEmitter), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new s.EventEmitter), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new s.EventEmitter), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new s.EventEmitter), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new s.EventEmitter), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new D(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(y => this._activeBuffer = y.activeBuffer)), this._parser.setCsiHandlerFallback((y, T) => { this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(y), params: T.toArray() }) }), this._parser.setEscHandlerFallback(y => { this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(y) }) }), this._parser.setExecuteHandlerFallback(y => { this._logService.debug("Unknown EXECUTE code: ", { code: y }) }), this._parser.setOscHandlerFallback((y, T, I) => { this._logService.debug("Unknown OSC code: ", { identifier: y, action: T, data: I }) }), this._parser.setDcsHandlerFallback((y, T, I) => { T === "HOOK" && (I = I.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(y), action: T, payload: I }) }), this._parser.setPrintHandler((y, T, I) => this.print(y, T, I)), this._parser.registerCsiHandler({ final: "@" }, y => this.insertChars(y)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, y => this.scrollLeft(y)), this._parser.registerCsiHandler({ final: "A" }, y => this.cursorUp(y)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, y => this.scrollRight(y)), this._parser.registerCsiHandler({ final: "B" }, y => this.cursorDown(y)), this._parser.registerCsiHandler({ final: "C" }, y => this.cursorForward(y)), this._parser.registerCsiHandler({ final: "D" }, y => this.cursorBackward(y)), this._parser.registerCsiHandler({ final: "E" }, y => this.cursorNextLine(y)), this._parser.registerCsiHandler({ final: "F" }, y => this.cursorPrecedingLine(y)), this._parser.registerCsiHandler({ final: "G" }, y => this.cursorCharAbsolute(y)), this._parser.registerCsiHandler({ final: "H" }, y => this.cursorPosition(y)), this._parser.registerCsiHandler({ final: "I" }, y => this.cursorForwardTab(y)), this._parser.registerCsiHandler({ final: "J" }, y => this.eraseInDisplay(y, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, y => this.eraseInDisplay(y, !0)), this._parser.registerCsiHandler({ final: "K" }, y => this.eraseInLine(y, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, y => this.eraseInLine(y, !0)), this._parser.registerCsiHandler({ final: "L" }, y => this.insertLines(y)), this._parser.registerCsiHandler({ final: "M" }, y => this.deleteLines(y)), this._parser.registerCsiHandler({ final: "P" }, y => this.deleteChars(y)), this._parser.registerCsiHandler({ final: "S" }, y => this.scrollUp(y)), this._parser.registerCsiHandler({ final: "T" }, y => this.scrollDown(y)), this._parser.registerCsiHandler({ final: "X" }, y => this.eraseChars(y)), this._parser.registerCsiHandler({ final: "Z" }, y => this.cursorBackwardTab(y)), this._parser.registerCsiHandler({ final: "`" }, y => this.charPosAbsolute(y)), this._parser.registerCsiHandler({ final: "a" }, y => this.hPositionRelative(y)), this._parser.registerCsiHandler({ final: "b" }, y => this.repeatPrecedingCharacter(y)), this._parser.registerCsiHandler({ final: "c" }, y => this.sendDeviceAttributesPrimary(y)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, y => this.sendDeviceAttributesSecondary(y)), this._parser.registerCsiHandler({ final: "d" }, y => this.linePosAbsolute(y)), this._parser.registerCsiHandler({ final: "e" }, y => this.vPositionRelative(y)), this._parser.registerCsiHandler({ final: "f" }, y => this.hVPosition(y)), this._parser.registerCsiHandler({ final: "g" }, y => this.tabClear(y)), this._parser.registerCsiHandler({ final: "h" }, y => this.setMode(y)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, y => this.setModePrivate(y)), this._parser.registerCsiHandler({ final: "l" }, y => this.resetMode(y)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, y => this.resetModePrivate(y)), this._parser.registerCsiHandler({ final: "m" }, y => this.charAttributes(y)), this._parser.registerCsiHandler({ final: "n" }, y => this.deviceStatus(y)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, y => this.deviceStatusPrivate(y)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, y => this.softReset(y)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, y => this.setCursorStyle(y)), this._parser.registerCsiHandler({ final: "r" }, y => this.setScrollRegion(y)), this._parser.registerCsiHandler({ final: "s" }, y => this.saveCursor(y)), this._parser.registerCsiHandler({ final: "t" }, y => this.windowOptions(y)), this._parser.registerCsiHandler({ final: "u" }, y => this.restoreCursor(y)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, y => this.insertColumns(y)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, y => this.deleteColumns(y)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, y => this.selectProtected(y)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, y => this.requestMode(y, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, y => this.requestMode(y, !1)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new p.OscHandler(y => (this.setTitle(y), this.setIconName(y), !0))), this._parser.registerOscHandler(1, new p.OscHandler(y => this.setIconName(y))), this._parser.registerOscHandler(2, new p.OscHandler(y => this.setTitle(y))), this._parser.registerOscHandler(4, new p.OscHandler(y => this.setOrReportIndexedColor(y))), this._parser.registerOscHandler(8, new p.OscHandler(y => this.setHyperlink(y))), this._parser.registerOscHandler(10, new p.OscHandler(y => this.setOrReportFgColor(y))), this._parser.registerOscHandler(11, new p.OscHandler(y => this.setOrReportBgColor(y))), this._parser.registerOscHandler(12, new p.OscHandler(y => this.setOrReportCursorColor(y))), this._parser.registerOscHandler(104, new p.OscHandler(y => this.restoreIndexedColor(y))), this._parser.registerOscHandler(110, new p.OscHandler(y => this.restoreFgColor(y))), this._parser.registerOscHandler(111, new p.OscHandler(y => this.restoreBgColor(y))), this._parser.registerOscHandler(112, new p.OscHandler(y => this.restoreCursorColor(y))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset()); for (const y in l.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: y }, () => this.selectCharset("(" + y)), this._parser.registerEscHandler({ intermediates: ")", final: y }, () => this.selectCharset(")" + y)), this._parser.registerEscHandler({ intermediates: "*", final: y }, () => this.selectCharset("*" + y)), this._parser.registerEscHandler({ intermediates: "+", final: y }, () => this.selectCharset("+" + y)), this._parser.registerEscHandler({ intermediates: "-", final: y }, () => this.selectCharset("-" + y)), this._parser.registerEscHandler({ intermediates: ".", final: y }, () => this.selectCharset("." + y)), this._parser.registerEscHandler({ intermediates: "/", final: y }, () => this.selectCharset("/" + y)); this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler(y => (this._logService.error("Parsing error: ", y), y)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new S.DcsHandler((y, T) => this.requestStatusString(y, T))) } _preserveStack(b, E, x, A) { this._parseStack.paused = !0, this._parseStack.cursorStartX = b, this._parseStack.cursorStartY = E, this._parseStack.decodedLength = x, this._parseStack.position = A } _logSlowResolvingAsync(b) { this._logService.logLevel <= u.LogLevelEnum.WARN && Promise.race([b, new Promise((E, x) => setTimeout(() => x("#SLOW_TIMEOUT"), 5e3))]).catch(E => { if (E !== "#SLOW_TIMEOUT") throw E; console.warn("async parser handler taking longer than 5000 ms") }) } _getCurrentLinkId() { return this._curAttrData.extended.urlId } parse(b, E) { let x, A = this._activeBuffer.x, B = this._activeBuffer.y, F = 0; const H = this._parseStack.paused; if (H) { if (x = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, E)) return this._logSlowResolvingAsync(x), x; A = this._parseStack.cursorStartX, B = this._parseStack.cursorStartY, this._parseStack.paused = !1, b.length > w && (F = this._parseStack.position + w) } if (this._logService.logLevel <= u.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof b == "string" ? ` "${b}"` : ` "${Array.prototype.map.call(b, W => String.fromCharCode(W)).join("")}"`), typeof b == "string" ? b.split("").map(W => W.charCodeAt(0)) : b), this._parseBuffer.length < b.length && this._parseBuffer.length < w && (this._parseBuffer = new Uint32Array(Math.min(b.length, w))), H || this._dirtyRowTracker.clearRange(), b.length > w) for (let W = F; W < b.length; W += w) { const N = W + w < b.length ? W + w : b.length, y = typeof b == "string" ? this._stringDecoder.decode(b.substring(W, N), this._parseBuffer) : this._utf8Decoder.decode(b.subarray(W, N), this._parseBuffer); if (x = this._parser.parse(this._parseBuffer, y)) return this._preserveStack(A, B, y, W), this._logSlowResolvingAsync(x), x } else if (!H) { const W = typeof b == "string" ? this._stringDecoder.decode(b, this._parseBuffer) : this._utf8Decoder.decode(b, this._parseBuffer); if (x = this._parser.parse(this._parseBuffer, W)) return this._preserveStack(A, B, W, 0), this._logSlowResolvingAsync(x), x } this._activeBuffer.x === A && this._activeBuffer.y === B || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end) } print(b, E, x) { let A, B; const F = this._charsetService.charset, H = this._optionsService.rawOptions.screenReaderMode, W = this._bufferService.cols, N = this._coreService.decPrivateModes.wraparound, y = this._coreService.modes.insertMode, T = this._curAttrData; let I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y); this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && x - E > 0 && I.getWidth(this._activeBuffer.x - 1) === 2 && I.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, T.fg, T.bg, T.extended); for (let O = E; O < x; ++O) { if (A = b[O], B = this._unicodeService.wcwidth(A), A < 127 && F) { const z = F[String.fromCharCode(A)]; z && (A = z.charCodeAt(0)) } if (H && this._onA11yChar.fire((0, o.stringFromCodePoint)(A)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), B || !this._activeBuffer.x) { if (this._activeBuffer.x + B - 1 >= W) { if (N) { for (; this._activeBuffer.x < W;)I.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, T.fg, T.bg, T.extended); this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), I = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y) } else if (this._activeBuffer.x = W - 1, B === 2) continue } if (y && (I.insertCells(this._activeBuffer.x, B, this._activeBuffer.getNullCell(T), T), I.getWidth(W - 1) === 2 && I.setCellFromCodePoint(W - 1, i.NULL_CELL_CODE, i.NULL_CELL_WIDTH, T.fg, T.bg, T.extended)), I.setCellFromCodePoint(this._activeBuffer.x++, A, B, T.fg, T.bg, T.extended), B > 0) for (; --B;)I.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, T.fg, T.bg, T.extended) } else I.getWidth(this._activeBuffer.x - 1) ? I.addCodepointToCell(this._activeBuffer.x - 1, A) : I.addCodepointToCell(this._activeBuffer.x - 2, A) } x - E > 0 && (I.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < W && x - E > 0 && I.getWidth(this._activeBuffer.x) === 0 && !I.hasContent(this._activeBuffer.x) && I.setCellFromCodePoint(this._activeBuffer.x, 0, 1, T.fg, T.bg, T.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y) } registerCsiHandler(b, E) { return b.final !== "t" || b.prefix || b.intermediates ? this._parser.registerCsiHandler(b, E) : this._parser.registerCsiHandler(b, x => !m(x.params[0], this._optionsService.rawOptions.windowOptions) || E(x)) } registerDcsHandler(b, E) { return this._parser.registerDcsHandler(b, new S.DcsHandler(E)) } registerEscHandler(b, E) { return this._parser.registerEscHandler(b, E) } registerOscHandler(b, E) { return this._parser.registerOscHandler(b, new p.OscHandler(E)) } bell() { return this._onRequestBell.fire(), !0 } lineFeed() { return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0 } carriageReturn() { return this._activeBuffer.x = 0, !0 } backspace() { var b; if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0; if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--; else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!((b = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || b === void 0) && b.isWrapped)) { this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1; const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y); E.hasWidth(this._activeBuffer.x) && !E.hasContent(this._activeBuffer.x) && this._activeBuffer.x-- } return this._restrictCursor(), !0 } tab() { if (this._activeBuffer.x >= this._bufferService.cols) return !0; const b = this._activeBuffer.x; return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - b), !0 } shiftOut() { return this._charsetService.setgLevel(1), !0 } shiftIn() { return this._charsetService.setgLevel(0), !0 } _restrictCursor(b = this._bufferService.cols - 1) { this._activeBuffer.x = Math.min(b, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y) } _setCursor(b, E) { this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = b, this._activeBuffer.y = this._activeBuffer.scrollTop + E) : (this._activeBuffer.x = b, this._activeBuffer.y = E), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y) } _moveCursor(b, E) { this._restrictCursor(), this._setCursor(this._activeBuffer.x + b, this._activeBuffer.y + E) } cursorUp(b) { const E = this._activeBuffer.y - this._activeBuffer.scrollTop; return E >= 0 ? this._moveCursor(0, -Math.min(E, b.params[0] || 1)) : this._moveCursor(0, -(b.params[0] || 1)), !0 } cursorDown(b) { const E = this._activeBuffer.scrollBottom - this._activeBuffer.y; return E >= 0 ? this._moveCursor(0, Math.min(E, b.params[0] || 1)) : this._moveCursor(0, b.params[0] || 1), !0 } cursorForward(b) { return this._moveCursor(b.params[0] || 1, 0), !0 } cursorBackward(b) { return this._moveCursor(-(b.params[0] || 1), 0), !0 } cursorNextLine(b) { return this.cursorDown(b), this._activeBuffer.x = 0, !0 } cursorPrecedingLine(b) { return this.cursorUp(b), this._activeBuffer.x = 0, !0 } cursorCharAbsolute(b) { return this._setCursor((b.params[0] || 1) - 1, this._activeBuffer.y), !0 } cursorPosition(b) { return this._setCursor(b.length >= 2 ? (b.params[1] || 1) - 1 : 0, (b.params[0] || 1) - 1), !0 } charPosAbsolute(b) { return this._setCursor((b.params[0] || 1) - 1, this._activeBuffer.y), !0 } hPositionRelative(b) { return this._moveCursor(b.params[0] || 1, 0), !0 } linePosAbsolute(b) { return this._setCursor(this._activeBuffer.x, (b.params[0] || 1) - 1), !0 } vPositionRelative(b) { return this._moveCursor(0, b.params[0] || 1), !0 } hVPosition(b) { return this.cursorPosition(b), !0 } tabClear(b) { const E = b.params[0]; return E === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : E === 3 && (this._activeBuffer.tabs = {}), !0 } cursorForwardTab(b) { if (this._activeBuffer.x >= this._bufferService.cols) return !0; let E = b.params[0] || 1; for (; E--;)this._activeBuffer.x = this._activeBuffer.nextStop(); return !0 } cursorBackwardTab(b) { if (this._activeBuffer.x >= this._bufferService.cols) return !0; let E = b.params[0] || 1; for (; E--;)this._activeBuffer.x = this._activeBuffer.prevStop(); return !0 } selectProtected(b) { const E = b.params[0]; return E === 1 && (this._curAttrData.bg |= 536870912), E !== 2 && E !== 0 || (this._curAttrData.bg &= -536870913), !0 } _eraseInBufferLine(b, E, x, A = !1, B = !1) { const F = this._activeBuffer.lines.get(this._activeBuffer.ybase + b); F.replaceCells(E, x, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), B), A && (F.isWrapped = !1) } _resetBufferLine(b, E = !1) { const x = this._activeBuffer.lines.get(this._activeBuffer.ybase + b); x && (x.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), E), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + b), x.isWrapped = !1) } eraseInDisplay(b, E = !1) { let x; switch (this._restrictCursor(this._bufferService.cols), b.params[0]) { case 0: for (x = this._activeBuffer.y, this._dirtyRowTracker.markDirty(x), this._eraseInBufferLine(x++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, E); x < this._bufferService.rows; x++)this._resetBufferLine(x, E); this._dirtyRowTracker.markDirty(x); break; case 1: for (x = this._activeBuffer.y, this._dirtyRowTracker.markDirty(x), this._eraseInBufferLine(x, 0, this._activeBuffer.x + 1, !0, E), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(x + 1).isWrapped = !1); x--;)this._resetBufferLine(x, E); this._dirtyRowTracker.markDirty(0); break; case 2: for (x = this._bufferService.rows, this._dirtyRowTracker.markDirty(x - 1); x--;)this._resetBufferLine(x, E); this._dirtyRowTracker.markDirty(0); break; case 3: const A = this._activeBuffer.lines.length - this._bufferService.rows; A > 0 && (this._activeBuffer.lines.trimStart(A), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - A, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - A, 0), this._onScroll.fire(0)) }return !0 } eraseInLine(b, E = !1) { switch (this._restrictCursor(this._bufferService.cols), b.params[0]) { case 0: this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, E); break; case 1: this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, E); break; case 2: this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, E) }return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0 } insertLines(b) { this._restrictCursor(); let E = b.params[0] || 1; if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const x = this._activeBuffer.ybase + this._activeBuffer.y, A = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, B = this._bufferService.rows - 1 + this._activeBuffer.ybase - A + 1; for (; E--;)this._activeBuffer.lines.splice(B - 1, 1), this._activeBuffer.lines.splice(x, 0, this._activeBuffer.getBlankLine(this._eraseAttrData())); return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0 } deleteLines(b) { this._restrictCursor(); let E = b.params[0] || 1; if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const x = this._activeBuffer.ybase + this._activeBuffer.y; let A; for (A = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, A = this._bufferService.rows - 1 + this._activeBuffer.ybase - A; E--;)this._activeBuffer.lines.splice(x, 1), this._activeBuffer.lines.splice(A, 0, this._activeBuffer.getBlankLine(this._eraseAttrData())); return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0 } insertChars(b) { this._restrictCursor(); const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y); return E && (E.insertCells(this._activeBuffer.x, b.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0 } deleteChars(b) { this._restrictCursor(); const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y); return E && (E.deleteCells(this._activeBuffer.x, b.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0 } scrollUp(b) { let E = b.params[0] || 1; for (; E--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData())); return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } scrollDown(b) { let E = b.params[0] || 1; for (; E--;)this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(e.DEFAULT_ATTR_DATA)); return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } scrollLeft(b) { if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const E = b.params[0] || 1; for (let x = this._activeBuffer.scrollTop; x <= this._activeBuffer.scrollBottom; ++x) { const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + x); A.deleteCells(0, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), A.isWrapped = !1 } return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } scrollRight(b) { if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const E = b.params[0] || 1; for (let x = this._activeBuffer.scrollTop; x <= this._activeBuffer.scrollBottom; ++x) { const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + x); A.insertCells(0, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), A.isWrapped = !1 } return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } insertColumns(b) { if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const E = b.params[0] || 1; for (let x = this._activeBuffer.scrollTop; x <= this._activeBuffer.scrollBottom; ++x) { const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + x); A.insertCells(this._activeBuffer.x, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), A.isWrapped = !1 } return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } deleteColumns(b) { if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0; const E = b.params[0] || 1; for (let x = this._activeBuffer.scrollTop; x <= this._activeBuffer.scrollBottom; ++x) { const A = this._activeBuffer.lines.get(this._activeBuffer.ybase + x); A.deleteCells(this._activeBuffer.x, E, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), A.isWrapped = !1 } return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0 } eraseChars(b) { this._restrictCursor(); const E = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y); return E && (E.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (b.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0 } repeatPrecedingCharacter(b) { if (!this._parser.precedingCodepoint) return !0; const E = b.params[0] || 1, x = new Uint32Array(E); for (let A = 0; A < E; ++A)x[A] = this._parser.precedingCodepoint; return this.print(x, 0, x.length), !0 } sendDeviceAttributesPrimary(b) { return b.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), !0 } sendDeviceAttributesSecondary(b) { return b.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(b.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), !0 } _is(b) { return (this._optionsService.rawOptions.termName + "").indexOf(b) === 0 } setMode(b) { for (let E = 0; E < b.length; E++)switch (b.params[E]) { case 4: this._coreService.modes.insertMode = !0; break; case 20: this._optionsService.options.convertEol = !0 }return !0 } setModePrivate(b) { for (let E = 0; E < b.length; E++)switch (b.params[E]) { case 1: this._coreService.decPrivateModes.applicationCursorKeys = !0; break; case 2: this._charsetService.setgCharset(0, l.DEFAULT_CHARSET), this._charsetService.setgCharset(1, l.DEFAULT_CHARSET), this._charsetService.setgCharset(2, l.DEFAULT_CHARSET), this._charsetService.setgCharset(3, l.DEFAULT_CHARSET); break; case 3: this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire()); break; case 6: this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0); break; case 7: this._coreService.decPrivateModes.wraparound = !0; break; case 12: this._optionsService.options.cursorBlink = !0; break; case 45: this._coreService.decPrivateModes.reverseWraparound = !0; break; case 66: this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(); break; case 9: this._coreMouseService.activeProtocol = "X10"; break; case 1e3: this._coreMouseService.activeProtocol = "VT200"; break; case 1002: this._coreMouseService.activeProtocol = "DRAG"; break; case 1003: this._coreMouseService.activeProtocol = "ANY"; break; case 1004: this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire(); break; case 1005: this._logService.debug("DECSET 1005 not supported (see #2507)"); break; case 1006: this._coreMouseService.activeEncoding = "SGR"; break; case 1015: this._logService.debug("DECSET 1015 not supported (see #2507)"); break; case 1016: this._coreMouseService.activeEncoding = "SGR_PIXELS"; break; case 25: this._coreService.isCursorHidden = !1; break; case 1048: this.saveCursor(); break; case 1049: this.saveCursor(); case 47: case 1047: this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire(); break; case 2004: this._coreService.decPrivateModes.bracketedPasteMode = !0 }return !0 } resetMode(b) { for (let E = 0; E < b.length; E++)switch (b.params[E]) { case 4: this._coreService.modes.insertMode = !1; break; case 20: this._optionsService.options.convertEol = !1 }return !0 } resetModePrivate(b) { for (let E = 0; E < b.length; E++)switch (b.params[E]) { case 1: this._coreService.decPrivateModes.applicationCursorKeys = !1; break; case 3: this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire()); break; case 6: this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0); break; case 7: this._coreService.decPrivateModes.wraparound = !1; break; case 12: this._optionsService.options.cursorBlink = !1; break; case 45: this._coreService.decPrivateModes.reverseWraparound = !1; break; case 66: this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(); break; case 9: case 1e3: case 1002: case 1003: this._coreMouseService.activeProtocol = "NONE"; break; case 1004: this._coreService.decPrivateModes.sendFocus = !1; break; case 1005: this._logService.debug("DECRST 1005 not supported (see #2507)"); break; case 1006: case 1016: this._coreMouseService.activeEncoding = "DEFAULT"; break; case 1015: this._logService.debug("DECRST 1015 not supported (see #2507)"); break; case 25: this._coreService.isCursorHidden = !0; break; case 1048: this.restoreCursor(); break; case 1049: case 47: case 1047: this._bufferService.buffers.activateNormalBuffer(), b.params[E] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire(); break; case 2004: this._coreService.decPrivateModes.bracketedPasteMode = !1 }return !0 } requestMode(b, E) { const x = this._coreService.decPrivateModes, { activeProtocol: A, activeEncoding: B } = this._coreMouseService, F = this._coreService, { buffers: H, cols: W } = this._bufferService, { active: N, alt: y } = H, T = this._optionsService.rawOptions, I = V => V ? 1 : 2, O = b.params[0]; return z = O, $ = E ? O === 2 ? 4 : O === 4 ? I(F.modes.insertMode) : O === 12 ? 3 : O === 20 ? I(T.convertEol) : 0 : O === 1 ? I(x.applicationCursorKeys) : O === 3 ? T.windowOptions.setWinLines ? W === 80 ? 2 : W === 132 ? 1 : 0 : 0 : O === 6 ? I(x.origin) : O === 7 ? I(x.wraparound) : O === 8 ? 3 : O === 9 ? I(A === "X10") : O === 12 ? I(T.cursorBlink) : O === 25 ? I(!F.isCursorHidden) : O === 45 ? I(x.reverseWraparound) : O === 66 ? I(x.applicationKeypad) : O === 67 ? 4 : O === 1e3 ? I(A === "VT200") : O === 1002 ? I(A === "DRAG") : O === 1003 ? I(A === "ANY") : O === 1004 ? I(x.sendFocus) : O === 1005 ? 4 : O === 1006 ? I(B === "SGR") : O === 1015 ? 4 : O === 1016 ? I(B === "SGR_PIXELS") : O === 1048 ? 1 : O === 47 || O === 1047 || O === 1049 ? I(N === y) : O === 2004 ? I(x.bracketedPasteMode) : 0, F.triggerDataEvent(`${n.C0.ESC}[${E ? "" : "?"}${z};${$}$y`), !0; var z, $ } _updateAttrColor(b, E, x, A, B) { return E === 2 ? (b |= 50331648, b &= -16777216, b |= d.AttributeData.fromColorRGB([x, A, B])) : E === 5 && (b &= -50331904, b |= 33554432 | 255 & x), b } _extractColor(b, E, x) { const A = [0, 0, -1, 0, 0, 0]; let B = 0, F = 0; do { if (A[F + B] = b.params[E + F], b.hasSubParams(E + F)) { const H = b.getSubParams(E + F); let W = 0; do A[1] === 5 && (B = 1), A[F + W + 1 + B] = H[W]; while (++W < H.length && W + F + 1 + B < A.length); break } if (A[1] === 5 && F + B >= 2 || A[1] === 2 && F + B >= 5) break; A[1] && (B = 1) } while (++F + E < b.length && F + B < A.length); for (let H = 2; H < A.length; ++H)A[H] === -1 && (A[H] = 0); switch (A[0]) { case 38: x.fg = this._updateAttrColor(x.fg, A[1], A[3], A[4], A[5]); break; case 48: x.bg = this._updateAttrColor(x.bg, A[1], A[3], A[4], A[5]); break; case 58: x.extended = x.extended.clone(), x.extended.underlineColor = this._updateAttrColor(x.extended.underlineColor, A[1], A[3], A[4], A[5]) }return F } _processUnderline(b, E) { E.extended = E.extended.clone(), (!~b || b > 5) && (b = 1), E.extended.underlineStyle = b, E.fg |= 268435456, b === 0 && (E.fg &= -268435457), E.updateExtended() } _processSGR0(b) { b.fg = e.DEFAULT_ATTR_DATA.fg, b.bg = e.DEFAULT_ATTR_DATA.bg, b.extended = b.extended.clone(), b.extended.underlineStyle = 0, b.extended.underlineColor &= -67108864, b.updateExtended() } charAttributes(b) { if (b.length === 1 && b.params[0] === 0) return this._processSGR0(this._curAttrData), !0; const E = b.length; let x; const A = this._curAttrData; for (let B = 0; B < E; B++)x = b.params[B], x >= 30 && x <= 37 ? (A.fg &= -50331904, A.fg |= 16777216 | x - 30) : x >= 40 && x <= 47 ? (A.bg &= -50331904, A.bg |= 16777216 | x - 40) : x >= 90 && x <= 97 ? (A.fg &= -50331904, A.fg |= 16777224 | x - 90) : x >= 100 && x <= 107 ? (A.bg &= -50331904, A.bg |= 16777224 | x - 100) : x === 0 ? this._processSGR0(A) : x === 1 ? A.fg |= 134217728 : x === 3 ? A.bg |= 67108864 : x === 4 ? (A.fg |= 268435456, this._processUnderline(b.hasSubParams(B) ? b.getSubParams(B)[0] : 1, A)) : x === 5 ? A.fg |= 536870912 : x === 7 ? A.fg |= 67108864 : x === 8 ? A.fg |= 1073741824 : x === 9 ? A.fg |= 2147483648 : x === 2 ? A.bg |= 134217728 : x === 21 ? this._processUnderline(2, A) : x === 22 ? (A.fg &= -134217729, A.bg &= -134217729) : x === 23 ? A.bg &= -67108865 : x === 24 ? (A.fg &= -268435457, this._processUnderline(0, A)) : x === 25 ? A.fg &= -536870913 : x === 27 ? A.fg &= -67108865 : x === 28 ? A.fg &= -1073741825 : x === 29 ? A.fg &= 2147483647 : x === 39 ? (A.fg &= -67108864, A.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg) : x === 49 ? (A.bg &= -67108864, A.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : x === 38 || x === 48 || x === 58 ? B += this._extractColor(b, B, A) : x === 53 ? A.bg |= 1073741824 : x === 55 ? A.bg &= -1073741825 : x === 59 ? (A.extended = A.extended.clone(), A.extended.underlineColor = -1, A.updateExtended()) : x === 100 ? (A.fg &= -67108864, A.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg, A.bg &= -67108864, A.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", x); return !0 } deviceStatus(b) { switch (b.params[0]) { case 5: this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`); break; case 6: const E = this._activeBuffer.y + 1, x = this._activeBuffer.x + 1; this._coreService.triggerDataEvent(`${n.C0.ESC}[${E};${x}R`) }return !0 } deviceStatusPrivate(b) { if (b.params[0] === 6) { const E = this._activeBuffer.y + 1, x = this._activeBuffer.x + 1; this._coreService.triggerDataEvent(`${n.C0.ESC}[?${E};${x}R`) } return !0 } softReset(b) { return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0 } setCursorStyle(b) { const E = b.params[0] || 1; switch (E) { case 1: case 2: this._optionsService.options.cursorStyle = "block"; break; case 3: case 4: this._optionsService.options.cursorStyle = "underline"; break; case 5: case 6: this._optionsService.options.cursorStyle = "bar" }const x = E % 2 == 1; return this._optionsService.options.cursorBlink = x, !0 } setScrollRegion(b) { const E = b.params[0] || 1; let x; return (b.length < 2 || (x = b.params[1]) > this._bufferService.rows || x === 0) && (x = this._bufferService.rows), x > E && (this._activeBuffer.scrollTop = E - 1, this._activeBuffer.scrollBottom = x - 1, this._setCursor(0, 0)), !0 } windowOptions(b) { if (!m(b.params[0], this._optionsService.rawOptions.windowOptions)) return !0; const E = b.length > 1 ? b.params[1] : 0; switch (b.params[0]) { case 14: E !== 2 && this._onRequestWindowsOptionsReport.fire(C.GET_WIN_SIZE_PIXELS); break; case 16: this._onRequestWindowsOptionsReport.fire(C.GET_CELL_SIZE_PIXELS); break; case 18: this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`); break; case 22: E !== 0 && E !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), E !== 0 && E !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift()); break; case 23: E !== 0 && E !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), E !== 0 && E !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop()) }return !0 } saveCursor(b) { return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0 } restoreCursor(b) { return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0 } setTitle(b) { return this._windowTitle = b, this._onTitleChange.fire(b), !0 } setIconName(b) { return this._iconName = b, !0 } setOrReportIndexedColor(b) { const E = [], x = b.split(";"); for (; x.length > 1;) { const A = x.shift(), B = x.shift(); if (/^\d+$/.exec(A)) { const F = parseInt(A); if (M(F)) if (B === "?") E.push({ type: 0, index: F }); else { const H = (0, a.parseColor)(B); H && E.push({ type: 1, index: F, color: H }) } } } return E.length && this._onColor.fire(E), !0 } setHyperlink(b) { const E = b.split(";"); return !(E.length < 2) && (E[1] ? this._createHyperlink(E[0], E[1]) : !E[0] && this._finishHyperlink()) } _createHyperlink(b, E) { this._getCurrentLinkId() && this._finishHyperlink(); const x = b.split(":"); let A; const B = x.findIndex(F => F.startsWith("id=")); return B !== -1 && (A = x[B].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: A, uri: E }), this._curAttrData.updateExtended(), !0 } _finishHyperlink() { return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0 } _setOrReportSpecialColor(b, E) { const x = b.split(";"); for (let A = 0; A < x.length && !(E >= this._specialColors.length); ++A, ++E)if (x[A] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[E] }]); else { const B = (0, a.parseColor)(x[A]); B && this._onColor.fire([{ type: 1, index: this._specialColors[E], color: B }]) } return !0 } setOrReportFgColor(b) { return this._setOrReportSpecialColor(b, 0) } setOrReportBgColor(b) { return this._setOrReportSpecialColor(b, 1) } setOrReportCursorColor(b) { return this._setOrReportSpecialColor(b, 2) } restoreIndexedColor(b) { if (!b) return this._onColor.fire([{ type: 2 }]), !0; const E = [], x = b.split(";"); for (let A = 0; A < x.length; ++A)if (/^\d+$/.exec(x[A])) { const B = parseInt(x[A]); M(B) && E.push({ type: 2, index: B }) } return E.length && this._onColor.fire(E), !0 } restoreFgColor(b) { return this._onColor.fire([{ type: 2, index: 256 }]), !0 } restoreBgColor(b) { return this._onColor.fire([{ type: 2, index: 257 }]), !0 } restoreCursorColor(b) { return this._onColor.fire([{ type: 2, index: 258 }]), !0 } nextLine() { return this._activeBuffer.x = 0, this.index(), !0 } keypadApplicationMode() { return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0 } keypadNumericMode() { return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0 } selectDefaultCharset() { return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, l.DEFAULT_CHARSET), !0 } selectCharset(b) { return b.length !== 2 ? (this.selectDefaultCharset(), !0) : (b[0] === "/" || this._charsetService.setgCharset(g[b[0]], l.CHARSETS[b[1]] || l.DEFAULT_CHARSET), !0) } index() { return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0 } tabSet() { return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0 } reverseIndex() { if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) { const b = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop; this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, b, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom) } else this._activeBuffer.y--, this._restrictCursor(); return !0 } fullReset() { return this._parser.reset(), this._onRequestReset.fire(), !0 } reset() { this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone() } _eraseAttrData() { return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal } setgLevel(b) { return this._charsetService.setgLevel(b), !0 } screenAlignmentPattern() { const b = new r.CellData; b.content = 4194373, b.fg = this._curAttrData.fg, b.bg = this._curAttrData.bg, this._setCursor(0, 0); for (let E = 0; E < this._bufferService.rows; ++E) { const x = this._activeBuffer.ybase + this._activeBuffer.y + E, A = this._activeBuffer.lines.get(x); A && (A.fill(b), A.isWrapped = !1) } return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0 } requestStatusString(b, E) { const x = this._bufferService.buffer, A = this._optionsService.rawOptions; return (B => (this._coreService.triggerDataEvent(`${n.C0.ESC}${B}${n.C0.ESC}\\`), !0))(b === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : b === '"p' ? 'P1$r61;1"p' : b === "r" ? `P1$r${x.scrollTop + 1};${x.scrollBottom + 1}r` : b === "m" ? "P1$r0m" : b === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[A.cursorStyle] - (A.cursorBlink ? 1 : 0)} q` : "P0$r") } markRangeDirty(b, E) { this._dirtyRowTracker.markRangeDirty(b, E) } } t.InputHandler = R; let D = class { constructor(k) { this._bufferService = k, this.clearRange() } clearRange() { this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y } markDirty(k) { k < this.start ? this.start = k : k > this.end && (this.end = k) } markRangeDirty(k, b) { k > b && (L = k, k = b, b = L), k < this.start && (this.start = k), b > this.end && (this.end = b) } markAllDirty() { this.markRangeDirty(0, this._bufferService.rows - 1) } }; function M(k) { return 0 <= k && k < 256 } D = c([f(0, u.IBufferService)], D) }, 844: (P, t) => { function h(c) { for (const f of c) f.dispose(); c.length = 0 } Object.defineProperty(t, "__esModule", { value: !0 }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.MutableDisposable = t.Disposable = void 0, t.Disposable = class { constructor() { this._disposables = [], this._isDisposed = !1 } dispose() { this._isDisposed = !0; for (const c of this._disposables) c.dispose(); this._disposables.length = 0 } register(c) { return this._disposables.push(c), c } unregister(c) { const f = this._disposables.indexOf(c); f !== -1 && this._disposables.splice(f, 1) } }, t.MutableDisposable = class { constructor() { this._isDisposed = !1 } get value() { return this._isDisposed ? void 0 : this._value } set value(c) { var f; this._isDisposed || c === this._value || ((f = this._value) === null || f === void 0 || f.dispose(), this._value = c) } clear() { this.value = void 0 } dispose() { var c; this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0 } }, t.toDisposable = function (c) { return { dispose: c } }, t.disposeArray = h, t.getDisposeArrayDisposable = function (c) { return { dispose: () => h(c) } } }, 1505: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.FourKeyMap = t.TwoKeyMap = void 0; class h { constructor() { this._data = {} } set(f, n, l) { this._data[f] || (this._data[f] = {}), this._data[f][n] = l } get(f, n) { return this._data[f] ? this._data[f][n] : void 0 } clear() { this._data = {} } } t.TwoKeyMap = h, t.FourKeyMap = class { constructor() { this._data = new h } set(c, f, n, l, _) { this._data.get(c, f) || this._data.set(c, f, new h), this._data.get(c, f).set(n, l, _) } get(c, f, n, l) { var _; return (_ = this._data.get(c, f)) === null || _ === void 0 ? void 0 : _.get(n, l) } clear() { this._data.clear() } } }, 6114: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.isChromeOS = t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.getSafariVersion = t.isSafari = t.isLegacyEdge = t.isFirefox = t.isNode = void 0, t.isNode = typeof navigator > "u"; const h = t.isNode ? "node" : navigator.userAgent, c = t.isNode ? "node" : navigator.platform; t.isFirefox = h.includes("Firefox"), t.isLegacyEdge = h.includes("Edge"), t.isSafari = /^((?!chrome|android).)*safari/i.test(h), t.getSafariVersion = function () { if (!t.isSafari) return 0; const f = h.match(/Version\/(\d+)/); return f === null || f.length < 2 ? 0 : parseInt(f[1]) }, t.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), t.isIpad = c === "iPad", t.isIphone = c === "iPhone", t.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), t.isLinux = c.indexOf("Linux") >= 0, t.isChromeOS = /\bCrOS\b/.test(h) }, 6106: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.SortedList = void 0; let h = 0; t.SortedList = class { constructor(c) { this._getKey = c, this._array = [] } clear() { this._array.length = 0 } insert(c) { this._array.length !== 0 ? (h = this._search(this._getKey(c)), this._array.splice(h, 0, c)) : this._array.push(c) } delete(c) { if (this._array.length === 0) return !1; const f = this._getKey(c); if (f === void 0 || (h = this._search(f), h === -1) || this._getKey(this._array[h]) !== f) return !1; do if (this._array[h] === c) return this._array.splice(h, 1), !0; while (++h < this._array.length && this._getKey(this._array[h]) === f); return !1 } *getKeyIterator(c) { if (this._array.length !== 0 && (h = this._search(c), !(h < 0 || h >= this._array.length) && this._getKey(this._array[h]) === c)) do yield this._array[h]; while (++h < this._array.length && this._getKey(this._array[h]) === c) } forEachByKey(c, f) { if (this._array.length !== 0 && (h = this._search(c), !(h < 0 || h >= this._array.length) && this._getKey(this._array[h]) === c)) do f(this._array[h]); while (++h < this._array.length && this._getKey(this._array[h]) === c) } values() { return [...this._array].values() } _search(c) { let f = 0, n = this._array.length - 1; for (; n >= f;) { let l = f + n >> 1; const _ = this._getKey(this._array[l]); if (_ > c) n = l - 1; else { if (!(_ < c)) { for (; l > 0 && this._getKey(this._array[l - 1]) === c;)l--; return l } f = l + 1 } } return f } } }, 7226: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.DebouncedIdleTask = t.IdleTaskQueue = t.PriorityTaskQueue = void 0; const c = h(6114); class f { constructor() { this._tasks = [], this._i = 0 } enqueue(_) { this._tasks.push(_), this._start() } flush() { for (; this._i < this._tasks.length;)this._tasks[this._i]() || this._i++; this.clear() } clear() { this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0 } _start() { this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this))) } _process(_) { this._idleCallback = void 0; let v = 0, o = 0, e = _.timeRemaining(), s = 0; for (; this._i < this._tasks.length;) { if (v = Date.now(), this._tasks[this._i]() || this._i++, v = Math.max(1, Date.now() - v), o = Math.max(v, o), s = _.timeRemaining(), 1.5 * o > s) return e - v < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(e - v))}ms`), void this._start(); e = s } this.clear() } } class n extends f { _requestCallback(_) { return setTimeout(() => _(this._createDeadline(16))) } _cancelCallback(_) { clearTimeout(_) } _createDeadline(_) { const v = Date.now() + _; return { timeRemaining: () => Math.max(0, v - Date.now()) } } } t.PriorityTaskQueue = n, t.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends f { _requestCallback(l) { return requestIdleCallback(l) } _cancelCallback(l) { cancelIdleCallback(l) } } : n, t.DebouncedIdleTask = class { constructor() { this._queue = new t.IdleTaskQueue } set(l) { this._queue.clear(), this._queue.enqueue(l) } flush() { this._queue.flush() } } }, 9282: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.updateWindowsModeWrappedState = void 0; const c = h(643); t.updateWindowsModeWrappedState = function (f) { const n = f.buffer.lines.get(f.buffer.ybase + f.buffer.y - 1), l = n?.get(f.cols - 1), _ = f.buffer.lines.get(f.buffer.ybase + f.buffer.y); _ && l && (_.isWrapped = l[c.CHAR_DATA_CODE_INDEX] !== c.NULL_CELL_CODE && l[c.CHAR_DATA_CODE_INDEX] !== c.WHITESPACE_CELL_CODE) } }, 3734: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ExtendedAttrs = t.AttributeData = void 0; class h { constructor() { this.fg = 0, this.bg = 0, this.extended = new c } static toColorRGB(n) { return [n >>> 16 & 255, n >>> 8 & 255, 255 & n] } static fromColorRGB(n) { return (255 & n[0]) << 16 | (255 & n[1]) << 8 | 255 & n[2] } clone() { const n = new h; return n.fg = this.fg, n.bg = this.bg, n.extended = this.extended.clone(), n } isInverse() { return 67108864 & this.fg } isBold() { return 134217728 & this.fg } isUnderline() { return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg } isBlink() { return 536870912 & this.fg } isInvisible() { return 1073741824 & this.fg } isItalic() { return 67108864 & this.bg } isDim() { return 134217728 & this.bg } isStrikethrough() { return 2147483648 & this.fg } isProtected() { return 536870912 & this.bg } isOverline() { return 1073741824 & this.bg } getFgColorMode() { return 50331648 & this.fg } getBgColorMode() { return 50331648 & this.bg } isFgRGB() { return (50331648 & this.fg) == 50331648 } isBgRGB() { return (50331648 & this.bg) == 50331648 } isFgPalette() { return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432 } isBgPalette() { return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432 } isFgDefault() { return (50331648 & this.fg) == 0 } isBgDefault() { return (50331648 & this.bg) == 0 } isAttributeDefault() { return this.fg === 0 && this.bg === 0 } getFgColor() { switch (50331648 & this.fg) { case 16777216: case 33554432: return 255 & this.fg; case 50331648: return 16777215 & this.fg; default: return -1 } } getBgColor() { switch (50331648 & this.bg) { case 16777216: case 33554432: return 255 & this.bg; case 50331648: return 16777215 & this.bg; default: return -1 } } hasExtendedAttrs() { return 268435456 & this.bg } updateExtended() { this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456 } getUnderlineColor() { if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) { case 16777216: case 33554432: return 255 & this.extended.underlineColor; case 50331648: return 16777215 & this.extended.underlineColor; default: return this.getFgColor() }return this.getFgColor() } getUnderlineColorMode() { return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode() } isUnderlineColorRGB() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB() } isUnderlineColorPalette() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette() } isUnderlineColorDefault() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault() } getUnderlineStyle() { return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0 } } t.AttributeData = h; class c { get ext() { return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext } set ext(n) { this._ext = n } get underlineStyle() { return this._urlId ? 5 : (469762048 & this._ext) >> 26 } set underlineStyle(n) { this._ext &= -469762049, this._ext |= n << 26 & 469762048 } get underlineColor() { return 67108863 & this._ext } set underlineColor(n) { this._ext &= -67108864, this._ext |= 67108863 & n } get urlId() { return this._urlId } set urlId(n) { this._urlId = n } constructor(n = 0, l = 0) { this._ext = 0, this._urlId = 0, this._ext = n, this._urlId = l } clone() { return new c(this._ext, this._urlId) } isEmpty() { return this.underlineStyle === 0 && this._urlId === 0 } } t.ExtendedAttrs = c }, 9092: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Buffer = t.MAX_BUFFER_SIZE = void 0; const c = h(6349), f = h(7226), n = h(3734), l = h(8437), _ = h(4634), v = h(511), o = h(643), e = h(4863), s = h(7116); t.MAX_BUFFER_SIZE = 4294967295, t.Buffer = class { constructor(i, r, d) { this._hasScrollback = i, this._optionsService = r, this._bufferService = d, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = l.DEFAULT_ATTR_DATA.clone(), this.savedCharset = s.DEFAULT_CHARSET, this.markers = [], this._nullCell = v.CellData.fromCharData([0, o.NULL_CELL_CHAR, o.NULL_CELL_WIDTH, o.NULL_CELL_CODE]), this._whitespaceCell = v.CellData.fromCharData([0, o.WHITESPACE_CELL_CHAR, o.WHITESPACE_CELL_WIDTH, o.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new f.IdleTaskQueue, this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops() } getNullCell(i) { return i ? (this._nullCell.fg = i.fg, this._nullCell.bg = i.bg, this._nullCell.extended = i.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs), this._nullCell } getWhitespaceCell(i) { return i ? (this._whitespaceCell.fg = i.fg, this._whitespaceCell.bg = i.bg, this._whitespaceCell.extended = i.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs), this._whitespaceCell } getBlankLine(i, r) { return new l.BufferLine(this._bufferService.cols, this.getNullCell(i), r) } get hasScrollback() { return this._hasScrollback && this.lines.maxLength > this._rows } get isCursorInViewport() { const i = this.ybase + this.y - this.ydisp; return i >= 0 && i < this._rows } _getCorrectBufferLength(i) { if (!this._hasScrollback) return i; const r = i + this._optionsService.rawOptions.scrollback; return r > t.MAX_BUFFER_SIZE ? t.MAX_BUFFER_SIZE : r } fillViewportRows(i) { if (this.lines.length === 0) { i === void 0 && (i = l.DEFAULT_ATTR_DATA); let r = this._rows; for (; r--;)this.lines.push(this.getBlankLine(i)) } } clear() { this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new c.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops() } resize(i, r) { const d = this.getNullCell(l.DEFAULT_ATTR_DATA); let u = 0; const p = this._getCorrectBufferLength(r); if (p > this.lines.maxLength && (this.lines.maxLength = p), this.lines.length > 0) { if (this._cols < i) for (let a = 0; a < this.lines.length; a++)u += +this.lines.get(a).resize(i, d); let S = 0; if (this._rows < r) for (let a = this._rows; a < r; a++)this.lines.length < r + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new l.BufferLine(i, d)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + S + 1 ? (this.ybase--, S++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new l.BufferLine(i, d))); else for (let a = this._rows; a > r; a--)this.lines.length > r + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++)); if (p < this.lines.maxLength) { const a = this.lines.length - p; a > 0 && (this.lines.trimStart(a), this.ybase = Math.max(this.ybase - a, 0), this.ydisp = Math.max(this.ydisp - a, 0), this.savedY = Math.max(this.savedY - a, 0)), this.lines.maxLength = p } this.x = Math.min(this.x, i - 1), this.y = Math.min(this.y, r - 1), S && (this.y += S), this.savedX = Math.min(this.savedX, i - 1), this.scrollTop = 0 } if (this.scrollBottom = r - 1, this._isReflowEnabled && (this._reflow(i, r), this._cols > i)) for (let S = 0; S < this.lines.length; S++)u += +this.lines.get(S).resize(i, d); this._cols = i, this._rows = r, this._memoryCleanupQueue.clear(), u > .1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup())) } _batchedMemoryCleanup() { let i = !0; this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, i = !1); let r = 0; for (; this._memoryCleanupPosition < this.lines.length;)if (r += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), r > 100) return !0; return i } get _isReflowEnabled() { const i = this._optionsService.rawOptions.windowsPty; return i && i.buildNumber ? this._hasScrollback && i.backend === "conpty" && i.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode } _reflow(i, r) { this._cols !== i && (i > this._cols ? this._reflowLarger(i, r) : this._reflowSmaller(i, r)) } _reflowLarger(i, r) { const d = (0, _.reflowLargerGetLinesToRemove)(this.lines, this._cols, i, this.ybase + this.y, this.getNullCell(l.DEFAULT_ATTR_DATA)); if (d.length > 0) { const u = (0, _.reflowLargerCreateNewLayout)(this.lines, d); (0, _.reflowLargerApplyNewLayout)(this.lines, u.layout), this._reflowLargerAdjustViewport(i, r, u.countRemoved) } } _reflowLargerAdjustViewport(i, r, d) { const u = this.getNullCell(l.DEFAULT_ATTR_DATA); let p = d; for (; p-- > 0;)this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < r && this.lines.push(new l.BufferLine(i, u))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--); this.savedY = Math.max(this.savedY - d, 0) } _reflowSmaller(i, r) { const d = this.getNullCell(l.DEFAULT_ATTR_DATA), u = []; let p = 0; for (let S = this.lines.length - 1; S >= 0; S--) { let a = this.lines.get(S); if (!a || !a.isWrapped && a.getTrimmedLength() <= i) continue; const g = [a]; for (; a.isWrapped && S > 0;)a = this.lines.get(--S), g.unshift(a); const w = this.ybase + this.y; if (w >= S && w < S + g.length) continue; const m = g[g.length - 1].getTrimmedLength(), C = (0, _.reflowSmallerGetNewLineLengths)(g, this._cols, i), L = C.length - g.length; let R; R = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + L) : Math.max(0, this.lines.length - this.lines.maxLength + L); const D = []; for (let A = 0; A < L; A++) { const B = this.getBlankLine(l.DEFAULT_ATTR_DATA, !0); D.push(B) } D.length > 0 && (u.push({ start: S + g.length + p, newLines: D }), p += D.length), g.push(...D); let M = C.length - 1, k = C[M]; k === 0 && (M--, k = C[M]); let b = g.length - L - 1, E = m; for (; b >= 0;) { const A = Math.min(E, k); if (g[M] === void 0) break; if (g[M].copyCellsFrom(g[b], E - A, k - A, A, !0), k -= A, k === 0 && (M--, k = C[M]), E -= A, E === 0) { b--; const B = Math.max(b, 0); E = (0, _.getWrappedLineTrimmedLength)(g, B, this._cols) } } for (let A = 0; A < g.length; A++)C[A] < i && g[A].setCell(C[A], d); let x = L - R; for (; x-- > 0;)this.ybase === 0 ? this.y < r - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + p) - r && (this.ybase === this.ydisp && this.ydisp++, this.ybase++); this.savedY = Math.min(this.savedY + L, this.ybase + r - 1) } if (u.length > 0) { const S = [], a = []; for (let M = 0; M < this.lines.length; M++)a.push(this.lines.get(M)); const g = this.lines.length; let w = g - 1, m = 0, C = u[m]; this.lines.length = Math.min(this.lines.maxLength, this.lines.length + p); let L = 0; for (let M = Math.min(this.lines.maxLength - 1, g + p - 1); M >= 0; M--)if (C && C.start > w + L) { for (let k = C.newLines.length - 1; k >= 0; k--)this.lines.set(M--, C.newLines[k]); M++, S.push({ index: w + 1, amount: C.newLines.length }), L += C.newLines.length, C = u[++m] } else this.lines.set(M, a[w--]); let R = 0; for (let M = S.length - 1; M >= 0; M--)S[M].index += R, this.lines.onInsertEmitter.fire(S[M]), R += S[M].amount; const D = Math.max(0, g + p - this.lines.maxLength); D > 0 && this.lines.onTrimEmitter.fire(D) } } translateBufferLineToString(i, r, d = 0, u) { const p = this.lines.get(i); return p ? p.translateToString(r, d, u) : "" } getWrappedRangeForLine(i) { let r = i, d = i; for (; r > 0 && this.lines.get(r).isWrapped;)r--; for (; d + 1 < this.lines.length && this.lines.get(d + 1).isWrapped;)d++; return { first: r, last: d } } setupTabStops(i) { for (i != null ? this.tabs[i] || (i = this.prevStop(i)) : (this.tabs = {}, i = 0); i < this._cols; i += this._optionsService.rawOptions.tabStopWidth)this.tabs[i] = !0 } prevStop(i) { for (i == null && (i = this.x); !this.tabs[--i] && i > 0;); return i >= this._cols ? this._cols - 1 : i < 0 ? 0 : i } nextStop(i) { for (i == null && (i = this.x); !this.tabs[++i] && i < this._cols;); return i >= this._cols ? this._cols - 1 : i < 0 ? 0 : i } clearMarkers(i) { this._isClearing = !0; for (let r = 0; r < this.markers.length; r++)this.markers[r].line === i && (this.markers[r].dispose(), this.markers.splice(r--, 1)); this._isClearing = !1 } clearAllMarkers() { this._isClearing = !0; for (let i = 0; i < this.markers.length; i++)this.markers[i].dispose(), this.markers.splice(i--, 1); this._isClearing = !1 } addMarker(i) { const r = new e.Marker(i); return this.markers.push(r), r.register(this.lines.onTrim(d => { r.line -= d, r.line < 0 && r.dispose() })), r.register(this.lines.onInsert(d => { r.line >= d.index && (r.line += d.amount) })), r.register(this.lines.onDelete(d => { r.line >= d.index && r.line < d.index + d.amount && r.dispose(), r.line > d.index && (r.line -= d.amount) })), r.register(r.onDispose(() => this._removeMarker(r))), r } _removeMarker(i) { this._isClearing || this.markers.splice(this.markers.indexOf(i), 1) } } }, 8437: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferLine = t.DEFAULT_ATTR_DATA = void 0; const c = h(3734), f = h(511), n = h(643), l = h(482); t.DEFAULT_ATTR_DATA = Object.freeze(new c.AttributeData); let _ = 0; class v { constructor(e, s, i = !1) { this.isWrapped = i, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e); const r = s || f.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]); for (let d = 0; d < e; ++d)this.setCell(d, r); this.length = e } get(e) { const s = this._data[3 * e + 0], i = 2097151 & s; return [this._data[3 * e + 1], 2097152 & s ? this._combined[e] : i ? (0, l.stringFromCodePoint)(i) : "", s >> 22, 2097152 & s ? this._combined[e].charCodeAt(this._combined[e].length - 1) : i] } set(e, s) { this._data[3 * e + 1] = s[n.CHAR_DATA_ATTR_INDEX], s[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e] = s[1], this._data[3 * e + 0] = 2097152 | e | s[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e + 0] = s[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | s[n.CHAR_DATA_WIDTH_INDEX] << 22 } getWidth(e) { return this._data[3 * e + 0] >> 22 } hasWidth(e) { return 12582912 & this._data[3 * e + 0] } getFg(e) { return this._data[3 * e + 1] } getBg(e) { return this._data[3 * e + 2] } hasContent(e) { return 4194303 & this._data[3 * e + 0] } getCodePoint(e) { const s = this._data[3 * e + 0]; return 2097152 & s ? this._combined[e].charCodeAt(this._combined[e].length - 1) : 2097151 & s } isCombined(e) { return 2097152 & this._data[3 * e + 0] } getString(e) { const s = this._data[3 * e + 0]; return 2097152 & s ? this._combined[e] : 2097151 & s ? (0, l.stringFromCodePoint)(2097151 & s) : "" } isProtected(e) { return 536870912 & this._data[3 * e + 2] } loadCell(e, s) { return _ = 3 * e, s.content = this._data[_ + 0], s.fg = this._data[_ + 1], s.bg = this._data[_ + 2], 2097152 & s.content && (s.combinedData = this._combined[e]), 268435456 & s.bg && (s.extended = this._extendedAttrs[e]), s } setCell(e, s) { 2097152 & s.content && (this._combined[e] = s.combinedData), 268435456 & s.bg && (this._extendedAttrs[e] = s.extended), this._data[3 * e + 0] = s.content, this._data[3 * e + 1] = s.fg, this._data[3 * e + 2] = s.bg } setCellFromCodePoint(e, s, i, r, d, u) { 268435456 & d && (this._extendedAttrs[e] = u), this._data[3 * e + 0] = s | i << 22, this._data[3 * e + 1] = r, this._data[3 * e + 2] = d } addCodepointToCell(e, s) { let i = this._data[3 * e + 0]; 2097152 & i ? this._combined[e] += (0, l.stringFromCodePoint)(s) : (2097151 & i ? (this._combined[e] = (0, l.stringFromCodePoint)(2097151 & i) + (0, l.stringFromCodePoint)(s), i &= -2097152, i |= 2097152) : i = s | 4194304, this._data[3 * e + 0] = i) } insertCells(e, s, i, r) { if ((e %= this.length) && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs), s < this.length - e) { const d = new f.CellData; for (let u = this.length - e - s - 1; u >= 0; --u)this.setCell(e + s + u, this.loadCell(e + u, d)); for (let u = 0; u < s; ++u)this.setCell(e + u, i) } else for (let d = e; d < this.length; ++d)this.setCell(d, i); this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs) } deleteCells(e, s, i, r) { if (e %= this.length, s < this.length - e) { const d = new f.CellData; for (let u = 0; u < this.length - e - s; ++u)this.setCell(e + u, this.loadCell(e + s + u, d)); for (let u = this.length - s; u < this.length; ++u)this.setCell(u, i) } else for (let d = e; d < this.length; ++d)this.setCell(d, i); e && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs), this.getWidth(e) !== 0 || this.hasContent(e) || this.setCellFromCodePoint(e, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs) } replaceCells(e, s, i, r, d = !1) { if (d) for (e && this.getWidth(e - 1) === 2 && !this.isProtected(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs), s < this.length && this.getWidth(s - 1) === 2 && !this.isProtected(s) && this.setCellFromCodePoint(s, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs); e < s && e < this.length;)this.isProtected(e) || this.setCell(e, i), e++; else for (e && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs), s < this.length && this.getWidth(s - 1) === 2 && this.setCellFromCodePoint(s, 0, 1, r?.fg || 0, r?.bg || 0, r?.extended || new c.ExtendedAttrs); e < s && e < this.length;)this.setCell(e++, i) } resize(e, s) { if (e === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength; const i = 3 * e; if (e > this.length) { if (this._data.buffer.byteLength >= 4 * i) this._data = new Uint32Array(this._data.buffer, 0, i); else { const r = new Uint32Array(i); r.set(this._data), this._data = r } for (let r = this.length; r < e; ++r)this.setCell(r, s) } else { this._data = this._data.subarray(0, i); const r = Object.keys(this._combined); for (let u = 0; u < r.length; u++) { const p = parseInt(r[u], 10); p >= e && delete this._combined[p] } const d = Object.keys(this._extendedAttrs); for (let u = 0; u < d.length; u++) { const p = parseInt(d[u], 10); p >= e && delete this._extendedAttrs[p] } } return this.length = e, 4 * i * 2 < this._data.buffer.byteLength } cleanupMemory() { if (4 * this._data.length * 2 < this._data.buffer.byteLength) { const e = new Uint32Array(this._data.length); return e.set(this._data), this._data = e, 1 } return 0 } fill(e, s = !1) { if (s) for (let i = 0; i < this.length; ++i)this.isProtected(i) || this.setCell(i, e); else { this._combined = {}, this._extendedAttrs = {}; for (let i = 0; i < this.length; ++i)this.setCell(i, e) } } copyFrom(e) { this.length !== e.length ? this._data = new Uint32Array(e._data) : this._data.set(e._data), this.length = e.length, this._combined = {}; for (const s in e._combined) this._combined[s] = e._combined[s]; this._extendedAttrs = {}; for (const s in e._extendedAttrs) this._extendedAttrs[s] = e._extendedAttrs[s]; this.isWrapped = e.isWrapped } clone() { const e = new v(0); e._data = new Uint32Array(this._data), e.length = this.length; for (const s in this._combined) e._combined[s] = this._combined[s]; for (const s in this._extendedAttrs) e._extendedAttrs[s] = this._extendedAttrs[s]; return e.isWrapped = this.isWrapped, e } getTrimmedLength() { for (let e = this.length - 1; e >= 0; --e)if (4194303 & this._data[3 * e + 0]) return e + (this._data[3 * e + 0] >> 22); return 0 } getNoBgTrimmedLength() { for (let e = this.length - 1; e >= 0; --e)if (4194303 & this._data[3 * e + 0] || 50331648 & this._data[3 * e + 2]) return e + (this._data[3 * e + 0] >> 22); return 0 } copyCellsFrom(e, s, i, r, d) { const u = e._data; if (d) for (let S = r - 1; S >= 0; S--) { for (let a = 0; a < 3; a++)this._data[3 * (i + S) + a] = u[3 * (s + S) + a]; 268435456 & u[3 * (s + S) + 2] && (this._extendedAttrs[i + S] = e._extendedAttrs[s + S]) } else for (let S = 0; S < r; S++) { for (let a = 0; a < 3; a++)this._data[3 * (i + S) + a] = u[3 * (s + S) + a]; 268435456 & u[3 * (s + S) + 2] && (this._extendedAttrs[i + S] = e._extendedAttrs[s + S]) } const p = Object.keys(e._combined); for (let S = 0; S < p.length; S++) { const a = parseInt(p[S], 10); a >= s && (this._combined[a - s + i] = e._combined[a]) } } translateToString(e = !1, s = 0, i = this.length) { e && (i = Math.min(i, this.getTrimmedLength())); let r = ""; for (; s < i;) { const d = this._data[3 * s + 0], u = 2097151 & d; r += 2097152 & d ? this._combined[s] : u ? (0, l.stringFromCodePoint)(u) : n.WHITESPACE_CELL_CHAR, s += d >> 22 || 1 } return r } } t.BufferLine = v }, 4841: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.getRangeLength = void 0, t.getRangeLength = function (h, c) { if (h.start.y > h.end.y) throw new Error(`Buffer range end (${h.end.x}, ${h.end.y}) cannot be before start (${h.start.x}, ${h.start.y})`); return c * (h.end.y - h.start.y) + (h.end.x - h.start.x + 1) } }, 4634: (P, t) => { function h(c, f, n) { if (f === c.length - 1) return c[f].getTrimmedLength(); const l = !c[f].hasContent(n - 1) && c[f].getWidth(n - 1) === 1, _ = c[f + 1].getWidth(0) === 2; return l && _ ? n - 1 : n } Object.defineProperty(t, "__esModule", { value: !0 }), t.getWrappedLineTrimmedLength = t.reflowSmallerGetNewLineLengths = t.reflowLargerApplyNewLayout = t.reflowLargerCreateNewLayout = t.reflowLargerGetLinesToRemove = void 0, t.reflowLargerGetLinesToRemove = function (c, f, n, l, _) { const v = []; for (let o = 0; o < c.length - 1; o++) { let e = o, s = c.get(++e); if (!s.isWrapped) continue; const i = [c.get(o)]; for (; e < c.length && s.isWrapped;)i.push(s), s = c.get(++e); if (l >= o && l < e) { o += i.length - 1; continue } let r = 0, d = h(i, r, f), u = 1, p = 0; for (; u < i.length;) { const a = h(i, u, f), g = a - p, w = n - d, m = Math.min(g, w); i[r].copyCellsFrom(i[u], p, d, m, !1), d += m, d === n && (r++, d = 0), p += m, p === a && (u++, p = 0), d === 0 && r !== 0 && i[r - 1].getWidth(n - 1) === 2 && (i[r].copyCellsFrom(i[r - 1], n - 1, d++, 1, !1), i[r - 1].setCell(n - 1, _)) } i[r].replaceCells(d, n, _); let S = 0; for (let a = i.length - 1; a > 0 && (a > r || i[a].getTrimmedLength() === 0); a--)S++; S > 0 && (v.push(o + i.length - S), v.push(S)), o += i.length - 1 } return v }, t.reflowLargerCreateNewLayout = function (c, f) { const n = []; let l = 0, _ = f[l], v = 0; for (let o = 0; o < c.length; o++)if (_ === o) { const e = f[++l]; c.onDeleteEmitter.fire({ index: o - v, amount: e }), o += e - 1, v += e, _ = f[++l] } else n.push(o); return { layout: n, countRemoved: v } }, t.reflowLargerApplyNewLayout = function (c, f) { const n = []; for (let l = 0; l < f.length; l++)n.push(c.get(f[l])); for (let l = 0; l < n.length; l++)c.set(l, n[l]); c.length = f.length }, t.reflowSmallerGetNewLineLengths = function (c, f, n) { const l = [], _ = c.map((s, i) => h(c, i, f)).reduce((s, i) => s + i); let v = 0, o = 0, e = 0; for (; e < _;) { if (_ - e < n) { l.push(_ - e); break } v += n; const s = h(c, o, f); v > s && (v -= s, o++); const i = c[o].getWidth(v - 1) === 2; i && v--; const r = i ? n - 1 : n; l.push(r), e += r } return l }, t.getWrappedLineTrimmedLength = h }, 5295: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferSet = void 0; const c = h(8460), f = h(844), n = h(9092); class l extends f.Disposable { constructor(v, o) { super(), this._optionsService = v, this._bufferService = o, this._onBufferActivate = this.register(new c.EventEmitter), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops())) } reset() { this._normal = new n.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops() } get alt() { return this._alt } get active() { return this._activeBuffer } get normal() { return this._normal } activateNormalBuffer() { this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt })) } activateAltBuffer(v) { this._activeBuffer !== this._alt && (this._alt.fillViewportRows(v), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal })) } resize(v, o) { this._normal.resize(v, o), this._alt.resize(v, o), this.setupTabStops(v) } setupTabStops(v) { this._normal.setupTabStops(v), this._alt.setupTabStops(v) } } t.BufferSet = l }, 511: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CellData = void 0; const c = h(482), f = h(643), n = h(3734); class l extends n.AttributeData { constructor() { super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs, this.combinedData = "" } static fromCharData(v) { const o = new l; return o.setFromCharData(v), o } isCombined() { return 2097152 & this.content } getWidth() { return this.content >> 22 } getChars() { return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "" } getCode() { return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content } setFromCharData(v) { this.fg = v[f.CHAR_DATA_ATTR_INDEX], this.bg = 0; let o = !1; if (v[f.CHAR_DATA_CHAR_INDEX].length > 2) o = !0; else if (v[f.CHAR_DATA_CHAR_INDEX].length === 2) { const e = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0); if (55296 <= e && e <= 56319) { const s = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(1); 56320 <= s && s <= 57343 ? this.content = 1024 * (e - 55296) + s - 56320 + 65536 | v[f.CHAR_DATA_WIDTH_INDEX] << 22 : o = !0 } else o = !0 } else this.content = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | v[f.CHAR_DATA_WIDTH_INDEX] << 22; o && (this.combinedData = v[f.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | v[f.CHAR_DATA_WIDTH_INDEX] << 22) } getAsCharData() { return [this.fg, this.getChars(), this.getWidth(), this.getCode()] } } t.CellData = l }, 643: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 0, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = "", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = " ", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32 }, 4863: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Marker = void 0; const c = h(8460), f = h(844); class n { get id() { return this._id } constructor(_) { this.line = _, this.isDisposed = !1, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new c.EventEmitter), this.onDispose = this._onDispose.event } dispose() { this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, f.disposeArray)(this._disposables), this._disposables.length = 0) } register(_) { return this._disposables.push(_), _ } } t.Marker = n, n._nextId = 1 }, 7116: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.DEFAULT_CHARSET = t.CHARSETS = void 0, t.CHARSETS = {}, t.DEFAULT_CHARSET = t.CHARSETS.B, t.CHARSETS[0] = { "`": "â", a: "â", b: "â", c: "â", d: "â", e: "â", f: "Â°", g: "Â±", h: "â¤", i: "â", j: "â", k: "â", l: "â", m: "â", n: "â¼", o: "âº", p: "â»", q: "â", r: "â¼", s: "â½", t: "â", u: "â¤", v: "â´", w: "â¬", x: "â", y: "â¤", z: "â¥", "{": "Ï", "|": "â ", "}": "Â£", "~": "Â·" }, t.CHARSETS.A = { "#": "Â£" }, t.CHARSETS.B = void 0, t.CHARSETS[4] = { "#": "Â£", "@": "Â¾", "[": "ij", "\\": "Â½", "]": "|", "{": "Â¨", "|": "f", "}": "Â¼", "~": "Â´" }, t.CHARSETS.C = t.CHARSETS[5] = { "[": "Ã", "\\": "Ã", "]": "Ã", "^": "Ã", "`": "Ã©", "{": "Ã¤", "|": "Ã¶", "}": "Ã¥", "~": "Ã¼" }, t.CHARSETS.R = { "#": "Â£", "@": "Ã ", "[": "Â°", "\\": "Ã§", "]": "Â§", "{": "Ã©", "|": "Ã¹", "}": "Ã¨", "~": "Â¨" }, t.CHARSETS.Q = { "@": "Ã ", "[": "Ã¢", "\\": "Ã§", "]": "Ãª", "^": "Ã®", "`": "Ã´", "{": "Ã©", "|": "Ã¹", "}": "Ã¨", "~": "Ã»" }, t.CHARSETS.K = { "@": "Â§", "[": "Ã", "\\": "Ã", "]": "Ã", "{": "Ã¤", "|": "Ã¶", "}": "Ã¼", "~": "Ã" }, t.CHARSETS.Y = { "#": "Â£", "@": "Â§", "[": "Â°", "\\": "Ã§", "]": "Ã©", "`": "Ã¹", "{": "Ã ", "|": "Ã²", "}": "Ã¨", "~": "Ã¬" }, t.CHARSETS.E = t.CHARSETS[6] = { "@": "Ã", "[": "Ã", "\\": "Ã", "]": "Ã", "^": "Ã", "`": "Ã¤", "{": "Ã¦", "|": "Ã¸", "}": "Ã¥", "~": "Ã¼" }, t.CHARSETS.Z = { "#": "Â£", "@": "Â§", "[": "Â¡", "\\": "Ã", "]": "Â¿", "{": "Â°", "|": "Ã±", "}": "Ã§" }, t.CHARSETS.H = t.CHARSETS[7] = { "@": "Ã", "[": "Ã", "\\": "Ã", "]": "Ã", "^": "Ã", "`": "Ã©", "{": "Ã¤", "|": "Ã¶", "}": "Ã¥", "~": "Ã¼" }, t.CHARSETS["="] = { "#": "Ã¹", "@": "Ã ", "[": "Ã©", "\\": "Ã§", "]": "Ãª", "^": "Ã®", _: "Ã¨", "`": "Ã´", "{": "Ã¤", "|": "Ã¶", "}": "Ã¼", "~": "Ã»" } }, 2584: (P, t) => {
        var h, c, f; Object.defineProperty(t, "__esModule", { value: !0 }), t.C1_ESCAPED = t.C1 = t.C0 = void 0, function (n) {
          n.NUL = "\0", n.SOH = "", n.STX = "", n.ETX = "", n.EOT = "", n.ENQ = "", n.ACK = "", n.BEL = "\x07", n.BS = "\b", n.HT = "	", n.LF = `
`, n.VT = "\v", n.FF = "\f", n.CR = "\r", n.SO = "", n.SI = "", n.DLE = "", n.DC1 = "", n.DC2 = "", n.DC3 = "", n.DC4 = "", n.NAK = "", n.SYN = "", n.ETB = "", n.CAN = "", n.EM = "", n.SUB = "", n.ESC = "\x1B", n.FS = "", n.GS = "", n.RS = "", n.US = "", n.SP = " ", n.DEL = ""
        }(h || (t.C0 = h = {})), function (n) { n.PAD = "Â", n.HOP = "Â", n.BPH = "Â", n.NBH = "Â", n.IND = "Â", n.NEL = "Â", n.SSA = "Â", n.ESA = "Â", n.HTS = "Â", n.HTJ = "Â", n.VTS = "Â", n.PLD = "Â", n.PLU = "Â", n.RI = "Â", n.SS2 = "Â", n.SS3 = "Â", n.DCS = "Â", n.PU1 = "Â", n.PU2 = "Â", n.STS = "Â", n.CCH = "Â", n.MW = "Â", n.SPA = "Â", n.EPA = "Â", n.SOS = "Â", n.SGCI = "Â", n.SCI = "Â", n.CSI = "Â", n.ST = "Â", n.OSC = "Â", n.PM = "Â", n.APC = "Â" }(c || (t.C1 = c = {})), function (n) { n.ST = `${h.ESC}\\` }(f || (t.C1_ESCAPED = f = {}))
      }, 7399: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateKeyboardEvent = void 0; const c = h(2584), f = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] }; t.evaluateKeyboardEvent = function (n, l, _, v) { const o = { type: 0, cancel: !1, key: void 0 }, e = (n.shiftKey ? 1 : 0) | (n.altKey ? 2 : 0) | (n.ctrlKey ? 4 : 0) | (n.metaKey ? 8 : 0); switch (n.keyCode) { case 0: n.key === "UIKeyInputUpArrow" ? o.key = l ? c.C0.ESC + "OA" : c.C0.ESC + "[A" : n.key === "UIKeyInputLeftArrow" ? o.key = l ? c.C0.ESC + "OD" : c.C0.ESC + "[D" : n.key === "UIKeyInputRightArrow" ? o.key = l ? c.C0.ESC + "OC" : c.C0.ESC + "[C" : n.key === "UIKeyInputDownArrow" && (o.key = l ? c.C0.ESC + "OB" : c.C0.ESC + "[B"); break; case 8: if (n.altKey) { o.key = c.C0.ESC + c.C0.DEL; break } o.key = c.C0.DEL; break; case 9: if (n.shiftKey) { o.key = c.C0.ESC + "[Z"; break } o.key = c.C0.HT, o.cancel = !0; break; case 13: o.key = n.altKey ? c.C0.ESC + c.C0.CR : c.C0.CR, o.cancel = !0; break; case 27: o.key = c.C0.ESC, n.altKey && (o.key = c.C0.ESC + c.C0.ESC), o.cancel = !0; break; case 37: if (n.metaKey) break; e ? (o.key = c.C0.ESC + "[1;" + (e + 1) + "D", o.key === c.C0.ESC + "[1;3D" && (o.key = c.C0.ESC + (_ ? "b" : "[1;5D"))) : o.key = l ? c.C0.ESC + "OD" : c.C0.ESC + "[D"; break; case 39: if (n.metaKey) break; e ? (o.key = c.C0.ESC + "[1;" + (e + 1) + "C", o.key === c.C0.ESC + "[1;3C" && (o.key = c.C0.ESC + (_ ? "f" : "[1;5C"))) : o.key = l ? c.C0.ESC + "OC" : c.C0.ESC + "[C"; break; case 38: if (n.metaKey) break; e ? (o.key = c.C0.ESC + "[1;" + (e + 1) + "A", _ || o.key !== c.C0.ESC + "[1;3A" || (o.key = c.C0.ESC + "[1;5A")) : o.key = l ? c.C0.ESC + "OA" : c.C0.ESC + "[A"; break; case 40: if (n.metaKey) break; e ? (o.key = c.C0.ESC + "[1;" + (e + 1) + "B", _ || o.key !== c.C0.ESC + "[1;3B" || (o.key = c.C0.ESC + "[1;5B")) : o.key = l ? c.C0.ESC + "OB" : c.C0.ESC + "[B"; break; case 45: n.shiftKey || n.ctrlKey || (o.key = c.C0.ESC + "[2~"); break; case 46: o.key = e ? c.C0.ESC + "[3;" + (e + 1) + "~" : c.C0.ESC + "[3~"; break; case 36: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "H" : l ? c.C0.ESC + "OH" : c.C0.ESC + "[H"; break; case 35: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "F" : l ? c.C0.ESC + "OF" : c.C0.ESC + "[F"; break; case 33: n.shiftKey ? o.type = 2 : n.ctrlKey ? o.key = c.C0.ESC + "[5;" + (e + 1) + "~" : o.key = c.C0.ESC + "[5~"; break; case 34: n.shiftKey ? o.type = 3 : n.ctrlKey ? o.key = c.C0.ESC + "[6;" + (e + 1) + "~" : o.key = c.C0.ESC + "[6~"; break; case 112: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "P" : c.C0.ESC + "OP"; break; case 113: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "Q" : c.C0.ESC + "OQ"; break; case 114: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "R" : c.C0.ESC + "OR"; break; case 115: o.key = e ? c.C0.ESC + "[1;" + (e + 1) + "S" : c.C0.ESC + "OS"; break; case 116: o.key = e ? c.C0.ESC + "[15;" + (e + 1) + "~" : c.C0.ESC + "[15~"; break; case 117: o.key = e ? c.C0.ESC + "[17;" + (e + 1) + "~" : c.C0.ESC + "[17~"; break; case 118: o.key = e ? c.C0.ESC + "[18;" + (e + 1) + "~" : c.C0.ESC + "[18~"; break; case 119: o.key = e ? c.C0.ESC + "[19;" + (e + 1) + "~" : c.C0.ESC + "[19~"; break; case 120: o.key = e ? c.C0.ESC + "[20;" + (e + 1) + "~" : c.C0.ESC + "[20~"; break; case 121: o.key = e ? c.C0.ESC + "[21;" + (e + 1) + "~" : c.C0.ESC + "[21~"; break; case 122: o.key = e ? c.C0.ESC + "[23;" + (e + 1) + "~" : c.C0.ESC + "[23~"; break; case 123: o.key = e ? c.C0.ESC + "[24;" + (e + 1) + "~" : c.C0.ESC + "[24~"; break; default: if (!n.ctrlKey || n.shiftKey || n.altKey || n.metaKey) if (_ && !v || !n.altKey || n.metaKey) !_ || n.altKey || n.ctrlKey || n.shiftKey || !n.metaKey ? n.key && !n.ctrlKey && !n.altKey && !n.metaKey && n.keyCode >= 48 && n.key.length === 1 ? o.key = n.key : n.key && n.ctrlKey && (n.key === "_" && (o.key = c.C0.US), n.key === "@" && (o.key = c.C0.NUL)) : n.keyCode === 65 && (o.type = 1); else { const s = f[n.keyCode], i = s?.[n.shiftKey ? 1 : 0]; if (i) o.key = c.C0.ESC + i; else if (n.keyCode >= 65 && n.keyCode <= 90) { const r = n.ctrlKey ? n.keyCode - 64 : n.keyCode + 32; let d = String.fromCharCode(r); n.shiftKey && (d = d.toUpperCase()), o.key = c.C0.ESC + d } else if (n.keyCode === 32) o.key = c.C0.ESC + (n.ctrlKey ? c.C0.NUL : " "); else if (n.key === "Dead" && n.code.startsWith("Key")) { let r = n.code.slice(3, 4); n.shiftKey || (r = r.toLowerCase()), o.key = c.C0.ESC + r, o.cancel = !0 } } else n.keyCode >= 65 && n.keyCode <= 90 ? o.key = String.fromCharCode(n.keyCode - 64) : n.keyCode === 32 ? o.key = c.C0.NUL : n.keyCode >= 51 && n.keyCode <= 55 ? o.key = String.fromCharCode(n.keyCode - 51 + 27) : n.keyCode === 56 ? o.key = c.C0.DEL : n.keyCode === 219 ? o.key = c.C0.ESC : n.keyCode === 220 ? o.key = c.C0.FS : n.keyCode === 221 && (o.key = c.C0.GS) }return o } }, 482: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function (h) { return h > 65535 ? (h -= 65536, String.fromCharCode(55296 + (h >> 10)) + String.fromCharCode(h % 1024 + 56320)) : String.fromCharCode(h) }, t.utf32ToString = function (h, c = 0, f = h.length) { let n = ""; for (let l = c; l < f; ++l) { let _ = h[l]; _ > 65535 ? (_ -= 65536, n += String.fromCharCode(55296 + (_ >> 10)) + String.fromCharCode(_ % 1024 + 56320)) : n += String.fromCharCode(_) } return n }, t.StringToUtf32 = class { constructor() { this._interim = 0 } clear() { this._interim = 0 } decode(h, c) { const f = h.length; if (!f) return 0; let n = 0, l = 0; if (this._interim) { const _ = h.charCodeAt(l++); 56320 <= _ && _ <= 57343 ? c[n++] = 1024 * (this._interim - 55296) + _ - 56320 + 65536 : (c[n++] = this._interim, c[n++] = _), this._interim = 0 } for (let _ = l; _ < f; ++_) { const v = h.charCodeAt(_); if (55296 <= v && v <= 56319) { if (++_ >= f) return this._interim = v, n; const o = h.charCodeAt(_); 56320 <= o && o <= 57343 ? c[n++] = 1024 * (v - 55296) + o - 56320 + 65536 : (c[n++] = v, c[n++] = o) } else v !== 65279 && (c[n++] = v) } return n } }, t.Utf8ToUtf32 = class { constructor() { this.interim = new Uint8Array(3) } clear() { this.interim.fill(0) } decode(h, c) { const f = h.length; if (!f) return 0; let n, l, _, v, o = 0, e = 0, s = 0; if (this.interim[0]) { let d = !1, u = this.interim[0]; u &= (224 & u) == 192 ? 31 : (240 & u) == 224 ? 15 : 7; let p, S = 0; for (; (p = 63 & this.interim[++S]) && S < 4;)u <<= 6, u |= p; const a = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, g = a - S; for (; s < g;) { if (s >= f) return 0; if (p = h[s++], (192 & p) != 128) { s--, d = !0; break } this.interim[S++] = p, u <<= 6, u |= 63 & p } d || (a === 2 ? u < 128 ? s-- : c[o++] = u : a === 3 ? u < 2048 || u >= 55296 && u <= 57343 || u === 65279 || (c[o++] = u) : u < 65536 || u > 1114111 || (c[o++] = u)), this.interim.fill(0) } const i = f - 4; let r = s; for (; r < f;) { for (; !(!(r < i) || 128 & (n = h[r]) || 128 & (l = h[r + 1]) || 128 & (_ = h[r + 2]) || 128 & (v = h[r + 3]));)c[o++] = n, c[o++] = l, c[o++] = _, c[o++] = v, r += 4; if (n = h[r++], n < 128) c[o++] = n; else if ((224 & n) == 192) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (e = (31 & n) << 6 | 63 & l, e < 128) { r--; continue } c[o++] = e } else if ((240 & n) == 224) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, o; if (_ = h[r++], (192 & _) != 128) { r--; continue } if (e = (15 & n) << 12 | (63 & l) << 6 | 63 & _, e < 2048 || e >= 55296 && e <= 57343 || e === 65279) continue; c[o++] = e } else if ((248 & n) == 240) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, o; if (_ = h[r++], (192 & _) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, this.interim[2] = _, o; if (v = h[r++], (192 & v) != 128) { r--; continue } if (e = (7 & n) << 18 | (63 & l) << 12 | (63 & _) << 6 | 63 & v, e < 65536 || e > 1114111) continue; c[o++] = e } } return o } } }, 225: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.UnicodeV6 = void 0; const h = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], c = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]]; let f; t.UnicodeV6 = class { constructor() { if (this.version = "6", !f) { f = new Uint8Array(65536), f.fill(1), f[0] = 0, f.fill(0, 1, 32), f.fill(0, 127, 160), f.fill(2, 4352, 4448), f[9001] = 2, f[9002] = 2, f.fill(2, 11904, 42192), f[12351] = 1, f.fill(2, 44032, 55204), f.fill(2, 63744, 64256), f.fill(2, 65040, 65050), f.fill(2, 65072, 65136), f.fill(2, 65280, 65377), f.fill(2, 65504, 65511); for (let n = 0; n < h.length; ++n)f.fill(0, h[n][0], h[n][1] + 1) } } wcwidth(n) { return n < 32 ? 0 : n < 127 ? 1 : n < 65536 ? f[n] : function (l, _) { let v, o = 0, e = _.length - 1; if (l < _[0][0] || l > _[e][1]) return !1; for (; e >= o;)if (v = o + e >> 1, l > _[v][1]) o = v + 1; else { if (!(l < _[v][0])) return !0; e = v - 1 } return !1 }(n, c) ? 0 : n >= 131072 && n <= 196605 || n >= 196608 && n <= 262141 ? 2 : 1 } } }, 5981: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.WriteBuffer = void 0; const c = h(8460), f = h(844); class n extends f.Disposable { constructor(_) { super(), this._action = _, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new c.EventEmitter), this.onWriteParsed = this._onWriteParsed.event } handleUserInput() { this._didUserInput = !0 } writeSync(_, v) { if (v !== void 0 && this._syncCalls > v) return void (this._syncCalls = 0); if (this._pendingData += _.length, this._writeBuffer.push(_), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return; let o; for (this._isSyncWriting = !0; o = this._writeBuffer.shift();) { this._action(o); const e = this._callbacks.shift(); e && e() } this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0 } write(_, v) { if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data"); if (!this._writeBuffer.length) { if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += _.length, this._writeBuffer.push(_), this._callbacks.push(v), void this._innerWrite(); setTimeout(() => this._innerWrite()) } this._pendingData += _.length, this._writeBuffer.push(_), this._callbacks.push(v) } _innerWrite(_ = 0, v = !0) { const o = _ || Date.now(); for (; this._writeBuffer.length > this._bufferOffset;) { const e = this._writeBuffer[this._bufferOffset], s = this._action(e, v); if (s) { const r = d => Date.now() - o >= 12 ? setTimeout(() => this._innerWrite(0, d)) : this._innerWrite(o, d); return void s.catch(d => (queueMicrotask(() => { throw d }), Promise.resolve(!1))).then(r) } const i = this._callbacks[this._bufferOffset]; if (i && i(), this._bufferOffset++, this._pendingData -= e.length, Date.now() - o >= 12) break } this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire() } } t.WriteBuffer = n }, 5941: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.toRgbString = t.parseColor = void 0; const h = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, c = /^[\da-f]+$/; function f(n, l) { const _ = n.toString(16), v = _.length < 2 ? "0" + _ : _; switch (l) { case 4: return _[0]; case 8: return v; case 12: return (v + v).slice(0, 3); default: return v + v } } t.parseColor = function (n) { if (!n) return; let l = n.toLowerCase(); if (l.indexOf("rgb:") === 0) { l = l.slice(4); const _ = h.exec(l); if (_) { const v = _[1] ? 15 : _[4] ? 255 : _[7] ? 4095 : 65535; return [Math.round(parseInt(_[1] || _[4] || _[7] || _[10], 16) / v * 255), Math.round(parseInt(_[2] || _[5] || _[8] || _[11], 16) / v * 255), Math.round(parseInt(_[3] || _[6] || _[9] || _[12], 16) / v * 255)] } } else if (l.indexOf("#") === 0 && (l = l.slice(1), c.exec(l) && [3, 6, 9, 12].includes(l.length))) { const _ = l.length / 3, v = [0, 0, 0]; for (let o = 0; o < 3; ++o) { const e = parseInt(l.slice(_ * o, _ * o + _), 16); v[o] = _ === 1 ? e << 4 : _ === 2 ? e : _ === 3 ? e >> 4 : e >> 8 } return v } }, t.toRgbString = function (n, l = 16) { const [_, v, o] = n; return `rgb:${f(_, l)}/${f(v, l)}/${f(o, l)}` } }, 5770: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.PAYLOAD_LIMIT = void 0, t.PAYLOAD_LIMIT = 1e7 }, 6351: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.DcsHandler = t.DcsParser = void 0; const c = h(482), f = h(8742), n = h(5770), l = []; t.DcsParser = class { constructor() { this._handlers = Object.create(null), this._active = l, this._ident = 0, this._handlerFb = () => { }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 } } dispose() { this._handlers = Object.create(null), this._handlerFb = () => { }, this._active = l } registerHandler(v, o) { this._handlers[v] === void 0 && (this._handlers[v] = []); const e = this._handlers[v]; return e.push(o), { dispose: () => { const s = e.indexOf(o); s !== -1 && e.splice(s, 1) } } } clearHandler(v) { this._handlers[v] && delete this._handlers[v] } setHandlerFallback(v) { this._handlerFb = v } reset() { if (this._active.length) for (let v = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; v >= 0; --v)this._active[v].unhook(!1); this._stack.paused = !1, this._active = l, this._ident = 0 } hook(v, o) { if (this.reset(), this._ident = v, this._active = this._handlers[v] || l, this._active.length) for (let e = this._active.length - 1; e >= 0; e--)this._active[e].hook(o); else this._handlerFb(this._ident, "HOOK", o) } put(v, o, e) { if (this._active.length) for (let s = this._active.length - 1; s >= 0; s--)this._active[s].put(v, o, e); else this._handlerFb(this._ident, "PUT", (0, c.utf32ToString)(v, o, e)) } unhook(v, o = !0) { if (this._active.length) { let e = !1, s = this._active.length - 1, i = !1; if (this._stack.paused && (s = this._stack.loopPosition - 1, e = o, i = this._stack.fallThrough, this._stack.paused = !1), !i && e === !1) { for (; s >= 0 && (e = this._active[s].unhook(v), e !== !0); s--)if (e instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, e; s-- } for (; s >= 0; s--)if (e = this._active[s].unhook(!1), e instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, e } else this._handlerFb(this._ident, "UNHOOK", v); this._active = l, this._ident = 0 } }; const _ = new f.Params; _.addParam(0), t.DcsHandler = class { constructor(v) { this._handler = v, this._data = "", this._params = _, this._hitLimit = !1 } hook(v) { this._params = v.length > 1 || v.params[0] ? v.clone() : _, this._data = "", this._hitLimit = !1 } put(v, o, e) { this._hitLimit || (this._data += (0, c.utf32ToString)(v, o, e), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0)) } unhook(v) { let o = !1; if (this._hitLimit) o = !1; else if (v && (o = this._handler(this._data, this._params), o instanceof Promise)) return o.then(e => (this._params = _, this._data = "", this._hitLimit = !1, e)); return this._params = _, this._data = "", this._hitLimit = !1, o } } }, 2015: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.EscapeSequenceParser = t.VT500_TRANSITION_TABLE = t.TransitionTable = void 0; const c = h(844), f = h(8742), n = h(6242), l = h(6351); class _ { constructor(s) { this.table = new Uint8Array(s) } setDefault(s, i) { this.table.fill(s << 4 | i) } add(s, i, r, d) { this.table[i << 8 | s] = r << 4 | d } addMany(s, i, r, d) { for (let u = 0; u < s.length; u++)this.table[i << 8 | s[u]] = r << 4 | d } } t.TransitionTable = _; const v = 160; t.VT500_TRANSITION_TABLE = function () { const e = new _(4095), s = Array.apply(null, Array(256)).map((S, a) => a), i = (S, a) => s.slice(S, a), r = i(32, 127), d = i(0, 24); d.push(25), d.push.apply(d, i(28, 32)); const u = i(0, 14); let p; for (p in e.setDefault(1, 0), e.addMany(r, 0, 2, 0), u) e.addMany([24, 26, 153, 154], p, 3, 0), e.addMany(i(128, 144), p, 3, 0), e.addMany(i(144, 152), p, 3, 0), e.add(156, p, 0, 0), e.add(27, p, 11, 1), e.add(157, p, 4, 8), e.addMany([152, 158, 159], p, 0, 7), e.add(155, p, 11, 3), e.add(144, p, 11, 9); return e.addMany(d, 0, 3, 0), e.addMany(d, 1, 3, 1), e.add(127, 1, 0, 1), e.addMany(d, 8, 0, 8), e.addMany(d, 3, 3, 3), e.add(127, 3, 0, 3), e.addMany(d, 4, 3, 4), e.add(127, 4, 0, 4), e.addMany(d, 6, 3, 6), e.addMany(d, 5, 3, 5), e.add(127, 5, 0, 5), e.addMany(d, 2, 3, 2), e.add(127, 2, 0, 2), e.add(93, 1, 4, 8), e.addMany(r, 8, 5, 8), e.add(127, 8, 5, 8), e.addMany([156, 27, 24, 26, 7], 8, 6, 0), e.addMany(i(28, 32), 8, 0, 8), e.addMany([88, 94, 95], 1, 0, 7), e.addMany(r, 7, 0, 7), e.addMany(d, 7, 0, 7), e.add(156, 7, 0, 0), e.add(127, 7, 0, 7), e.add(91, 1, 11, 3), e.addMany(i(64, 127), 3, 7, 0), e.addMany(i(48, 60), 3, 8, 4), e.addMany([60, 61, 62, 63], 3, 9, 4), e.addMany(i(48, 60), 4, 8, 4), e.addMany(i(64, 127), 4, 7, 0), e.addMany([60, 61, 62, 63], 4, 0, 6), e.addMany(i(32, 64), 6, 0, 6), e.add(127, 6, 0, 6), e.addMany(i(64, 127), 6, 0, 0), e.addMany(i(32, 48), 3, 9, 5), e.addMany(i(32, 48), 5, 9, 5), e.addMany(i(48, 64), 5, 0, 6), e.addMany(i(64, 127), 5, 7, 0), e.addMany(i(32, 48), 4, 9, 5), e.addMany(i(32, 48), 1, 9, 2), e.addMany(i(32, 48), 2, 9, 2), e.addMany(i(48, 127), 2, 10, 0), e.addMany(i(48, 80), 1, 10, 0), e.addMany(i(81, 88), 1, 10, 0), e.addMany([89, 90, 92], 1, 10, 0), e.addMany(i(96, 127), 1, 10, 0), e.add(80, 1, 11, 9), e.addMany(d, 9, 0, 9), e.add(127, 9, 0, 9), e.addMany(i(28, 32), 9, 0, 9), e.addMany(i(32, 48), 9, 9, 12), e.addMany(i(48, 60), 9, 8, 10), e.addMany([60, 61, 62, 63], 9, 9, 10), e.addMany(d, 11, 0, 11), e.addMany(i(32, 128), 11, 0, 11), e.addMany(i(28, 32), 11, 0, 11), e.addMany(d, 10, 0, 10), e.add(127, 10, 0, 10), e.addMany(i(28, 32), 10, 0, 10), e.addMany(i(48, 60), 10, 8, 10), e.addMany([60, 61, 62, 63], 10, 0, 11), e.addMany(i(32, 48), 10, 9, 12), e.addMany(d, 12, 0, 12), e.add(127, 12, 0, 12), e.addMany(i(28, 32), 12, 0, 12), e.addMany(i(32, 48), 12, 9, 12), e.addMany(i(48, 64), 12, 0, 11), e.addMany(i(64, 127), 12, 12, 13), e.addMany(i(64, 127), 10, 12, 13), e.addMany(i(64, 127), 9, 12, 13), e.addMany(d, 13, 13, 13), e.addMany(r, 13, 13, 13), e.add(127, 13, 0, 13), e.addMany([27, 156, 24, 26], 13, 14, 0), e.add(v, 0, 2, 0), e.add(v, 8, 5, 8), e.add(v, 6, 0, 6), e.add(v, 11, 0, 11), e.add(v, 13, 13, 13), e }(); class o extends c.Disposable { constructor(s = t.VT500_TRANSITION_TABLE) { super(), this._transitions = s, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new f.Params, this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (i, r, d) => { }, this._executeHandlerFb = i => { }, this._csiHandlerFb = (i, r) => { }, this._escHandlerFb = i => { }, this._errorHandlerFb = i => i, this._printHandler = this._printHandlerFb, this._executeHandlers = Object.create(null), this._csiHandlers = Object.create(null), this._escHandlers = Object.create(null), this.register((0, c.toDisposable)(() => { this._csiHandlers = Object.create(null), this._executeHandlers = Object.create(null), this._escHandlers = Object.create(null) })), this._oscParser = this.register(new n.OscParser), this._dcsParser = this.register(new l.DcsParser), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0) } _identifier(s, i = [64, 126]) { let r = 0; if (s.prefix) { if (s.prefix.length > 1) throw new Error("only one byte as prefix supported"); if (r = s.prefix.charCodeAt(0), r && 60 > r || r > 63) throw new Error("prefix must be in range 0x3c .. 0x3f") } if (s.intermediates) { if (s.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported"); for (let u = 0; u < s.intermediates.length; ++u) { const p = s.intermediates.charCodeAt(u); if (32 > p || p > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f"); r <<= 8, r |= p } } if (s.final.length !== 1) throw new Error("final must be a single byte"); const d = s.final.charCodeAt(0); if (i[0] > d || d > i[1]) throw new Error(`final must be in range ${i[0]} .. ${i[1]}`); return r <<= 8, r |= d, r } identToString(s) { const i = []; for (; s;)i.push(String.fromCharCode(255 & s)), s >>= 8; return i.reverse().join("") } setPrintHandler(s) { this._printHandler = s } clearPrintHandler() { this._printHandler = this._printHandlerFb } registerEscHandler(s, i) { const r = this._identifier(s, [48, 126]); this._escHandlers[r] === void 0 && (this._escHandlers[r] = []); const d = this._escHandlers[r]; return d.push(i), { dispose: () => { const u = d.indexOf(i); u !== -1 && d.splice(u, 1) } } } clearEscHandler(s) { this._escHandlers[this._identifier(s, [48, 126])] && delete this._escHandlers[this._identifier(s, [48, 126])] } setEscHandlerFallback(s) { this._escHandlerFb = s } setExecuteHandler(s, i) { this._executeHandlers[s.charCodeAt(0)] = i } clearExecuteHandler(s) { this._executeHandlers[s.charCodeAt(0)] && delete this._executeHandlers[s.charCodeAt(0)] } setExecuteHandlerFallback(s) { this._executeHandlerFb = s } registerCsiHandler(s, i) { const r = this._identifier(s); this._csiHandlers[r] === void 0 && (this._csiHandlers[r] = []); const d = this._csiHandlers[r]; return d.push(i), { dispose: () => { const u = d.indexOf(i); u !== -1 && d.splice(u, 1) } } } clearCsiHandler(s) { this._csiHandlers[this._identifier(s)] && delete this._csiHandlers[this._identifier(s)] } setCsiHandlerFallback(s) { this._csiHandlerFb = s } registerDcsHandler(s, i) { return this._dcsParser.registerHandler(this._identifier(s), i) } clearDcsHandler(s) { this._dcsParser.clearHandler(this._identifier(s)) } setDcsHandlerFallback(s) { this._dcsParser.setHandlerFallback(s) } registerOscHandler(s, i) { return this._oscParser.registerHandler(s, i) } clearOscHandler(s) { this._oscParser.clearHandler(s) } setOscHandlerFallback(s) { this._oscParser.setHandlerFallback(s) } setErrorHandler(s) { this._errorHandler = s } clearErrorHandler() { this._errorHandler = this._errorHandlerFb } reset() { this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []) } _preserveStack(s, i, r, d, u) { this._parseStack.state = s, this._parseStack.handlers = i, this._parseStack.handlerPos = r, this._parseStack.transition = d, this._parseStack.chunkPos = u } parse(s, i, r) { let d, u = 0, p = 0, S = 0; if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, S = this._parseStack.chunkPos + 1; else { if (r === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing"); const a = this._parseStack.handlers; let g = this._parseStack.handlerPos - 1; switch (this._parseStack.state) { case 3: if (r === !1 && g > -1) { for (; g >= 0 && (d = a[g](this._params), d !== !0); g--)if (d instanceof Promise) return this._parseStack.handlerPos = g, d } this._parseStack.handlers = []; break; case 4: if (r === !1 && g > -1) { for (; g >= 0 && (d = a[g](), d !== !0); g--)if (d instanceof Promise) return this._parseStack.handlerPos = g, d } this._parseStack.handlers = []; break; case 6: if (u = s[this._parseStack.chunkPos], d = this._dcsParser.unhook(u !== 24 && u !== 26, r), d) return d; u === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0; break; case 5: if (u = s[this._parseStack.chunkPos], d = this._oscParser.end(u !== 24 && u !== 26, r), d) return d; u === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0 }this._parseStack.state = 0, S = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition } for (let a = S; a < i; ++a) { switch (u = s[a], p = this._transitions.table[this.currentState << 8 | (u < 160 ? u : v)], p >> 4) { case 2: for (let L = a + 1; ; ++L) { if (L >= i || (u = s[L]) < 32 || u > 126 && u < v) { this._printHandler(s, a, L), a = L - 1; break } if (++L >= i || (u = s[L]) < 32 || u > 126 && u < v) { this._printHandler(s, a, L), a = L - 1; break } if (++L >= i || (u = s[L]) < 32 || u > 126 && u < v) { this._printHandler(s, a, L), a = L - 1; break } if (++L >= i || (u = s[L]) < 32 || u > 126 && u < v) { this._printHandler(s, a, L), a = L - 1; break } } break; case 3: this._executeHandlers[u] ? this._executeHandlers[u]() : this._executeHandlerFb(u), this.precedingCodepoint = 0; break; case 0: break; case 1: if (this._errorHandler({ position: a, code: u, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return; break; case 7: const g = this._csiHandlers[this._collect << 8 | u]; let w = g ? g.length - 1 : -1; for (; w >= 0 && (d = g[w](this._params), d !== !0); w--)if (d instanceof Promise) return this._preserveStack(3, g, w, p, a), d; w < 0 && this._csiHandlerFb(this._collect << 8 | u, this._params), this.precedingCodepoint = 0; break; case 8: do switch (u) { case 59: this._params.addParam(0); break; case 58: this._params.addSubParam(-1); break; default: this._params.addDigit(u - 48) } while (++a < i && (u = s[a]) > 47 && u < 60); a--; break; case 9: this._collect <<= 8, this._collect |= u; break; case 10: const m = this._escHandlers[this._collect << 8 | u]; let C = m ? m.length - 1 : -1; for (; C >= 0 && (d = m[C](), d !== !0); C--)if (d instanceof Promise) return this._preserveStack(4, m, C, p, a), d; C < 0 && this._escHandlerFb(this._collect << 8 | u), this.precedingCodepoint = 0; break; case 11: this._params.reset(), this._params.addParam(0), this._collect = 0; break; case 12: this._dcsParser.hook(this._collect << 8 | u, this._params); break; case 13: for (let L = a + 1; ; ++L)if (L >= i || (u = s[L]) === 24 || u === 26 || u === 27 || u > 127 && u < v) { this._dcsParser.put(s, a, L), a = L - 1; break } break; case 14: if (d = this._dcsParser.unhook(u !== 24 && u !== 26), d) return this._preserveStack(6, [], 0, p, a), d; u === 27 && (p |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0; break; case 4: this._oscParser.start(); break; case 5: for (let L = a + 1; ; L++)if (L >= i || (u = s[L]) < 32 || u > 127 && u < v) { this._oscParser.put(s, a, L), a = L - 1; break } break; case 6: if (d = this._oscParser.end(u !== 24 && u !== 26), d) return this._preserveStack(5, [], 0, p, a), d; u === 27 && (p |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0 }this.currentState = 15 & p } } } t.EscapeSequenceParser = o }, 6242: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.OscHandler = t.OscParser = void 0; const c = h(5770), f = h(482), n = []; t.OscParser = class { constructor() { this._state = 0, this._active = n, this._id = -1, this._handlers = Object.create(null), this._handlerFb = () => { }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 } } registerHandler(l, _) { this._handlers[l] === void 0 && (this._handlers[l] = []); const v = this._handlers[l]; return v.push(_), { dispose: () => { const o = v.indexOf(_); o !== -1 && v.splice(o, 1) } } } clearHandler(l) { this._handlers[l] && delete this._handlers[l] } setHandlerFallback(l) { this._handlerFb = l } dispose() { this._handlers = Object.create(null), this._handlerFb = () => { }, this._active = n } reset() { if (this._state === 2) for (let l = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; l >= 0; --l)this._active[l].end(!1); this._stack.paused = !1, this._active = n, this._id = -1, this._state = 0 } _start() { if (this._active = this._handlers[this._id] || n, this._active.length) for (let l = this._active.length - 1; l >= 0; l--)this._active[l].start(); else this._handlerFb(this._id, "START") } _put(l, _, v) { if (this._active.length) for (let o = this._active.length - 1; o >= 0; o--)this._active[o].put(l, _, v); else this._handlerFb(this._id, "PUT", (0, f.utf32ToString)(l, _, v)) } start() { this.reset(), this._state = 1 } put(l, _, v) { if (this._state !== 3) { if (this._state === 1) for (; _ < v;) { const o = l[_++]; if (o === 59) { this._state = 2, this._start(); break } if (o < 48 || 57 < o) return void (this._state = 3); this._id === -1 && (this._id = 0), this._id = 10 * this._id + o - 48 } this._state === 2 && v - _ > 0 && this._put(l, _, v) } } end(l, _ = !0) { if (this._state !== 0) { if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) { let v = !1, o = this._active.length - 1, e = !1; if (this._stack.paused && (o = this._stack.loopPosition - 1, v = _, e = this._stack.fallThrough, this._stack.paused = !1), !e && v === !1) { for (; o >= 0 && (v = this._active[o].end(l), v !== !0); o--)if (v instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = o, this._stack.fallThrough = !1, v; o-- } for (; o >= 0; o--)if (v = this._active[o].end(!1), v instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = o, this._stack.fallThrough = !0, v } else this._handlerFb(this._id, "END", l); this._active = n, this._id = -1, this._state = 0 } } }, t.OscHandler = class { constructor(l) { this._handler = l, this._data = "", this._hitLimit = !1 } start() { this._data = "", this._hitLimit = !1 } put(l, _, v) { this._hitLimit || (this._data += (0, f.utf32ToString)(l, _, v), this._data.length > c.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0)) } end(l) { let _ = !1; if (this._hitLimit) _ = !1; else if (l && (_ = this._handler(this._data), _ instanceof Promise)) return _.then(v => (this._data = "", this._hitLimit = !1, v)); return this._data = "", this._hitLimit = !1, _ } } }, 8742: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Params = void 0; const h = 2147483647; class c { static fromArray(n) { const l = new c; if (!n.length) return l; for (let _ = Array.isArray(n[0]) ? 1 : 0; _ < n.length; ++_) { const v = n[_]; if (Array.isArray(v)) for (let o = 0; o < v.length; ++o)l.addSubParam(v[o]); else l.addParam(v) } return l } constructor(n = 32, l = 32) { if (this.maxLength = n, this.maxSubParamsLength = l, l > 256) throw new Error("maxSubParamsLength must not be greater than 256"); this.params = new Int32Array(n), this.length = 0, this._subParams = new Int32Array(l), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(n), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1 } clone() { const n = new c(this.maxLength, this.maxSubParamsLength); return n.params.set(this.params), n.length = this.length, n._subParams.set(this._subParams), n._subParamsLength = this._subParamsLength, n._subParamsIdx.set(this._subParamsIdx), n._rejectDigits = this._rejectDigits, n._rejectSubDigits = this._rejectSubDigits, n._digitIsSub = this._digitIsSub, n } toArray() { const n = []; for (let l = 0; l < this.length; ++l) { n.push(this.params[l]); const _ = this._subParamsIdx[l] >> 8, v = 255 & this._subParamsIdx[l]; v - _ > 0 && n.push(Array.prototype.slice.call(this._subParams, _, v)) } return n } reset() { this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1 } addParam(n) { if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0; else { if (n < -1) throw new Error("values lesser than -1 are not allowed"); this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = n > h ? h : n } } addSubParam(n) { if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0; else { if (n < -1) throw new Error("values lesser than -1 are not allowed"); this._subParams[this._subParamsLength++] = n > h ? h : n, this._subParamsIdx[this.length - 1]++ } } hasSubParams(n) { return (255 & this._subParamsIdx[n]) - (this._subParamsIdx[n] >> 8) > 0 } getSubParams(n) { const l = this._subParamsIdx[n] >> 8, _ = 255 & this._subParamsIdx[n]; return _ - l > 0 ? this._subParams.subarray(l, _) : null } getSubParamsAll() { const n = {}; for (let l = 0; l < this.length; ++l) { const _ = this._subParamsIdx[l] >> 8, v = 255 & this._subParamsIdx[l]; v - _ > 0 && (n[l] = this._subParams.slice(_, v)) } return n } addDigit(n) { let l; if (this._rejectDigits || !(l = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return; const _ = this._digitIsSub ? this._subParams : this.params, v = _[l - 1]; _[l - 1] = ~v ? Math.min(10 * v + n, h) : n } } t.Params = c }, 5741: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.AddonManager = void 0, t.AddonManager = class { constructor() { this._addons = [] } dispose() { for (let h = this._addons.length - 1; h >= 0; h--)this._addons[h].instance.dispose() } loadAddon(h, c) { const f = { instance: c, dispose: c.dispose, isDisposed: !1 }; this._addons.push(f), c.dispose = () => this._wrappedAddonDispose(f), c.activate(h) } _wrappedAddonDispose(h) { if (h.isDisposed) return; let c = -1; for (let f = 0; f < this._addons.length; f++)if (this._addons[f] === h) { c = f; break } if (c === -1) throw new Error("Could not dispose an addon that has not been loaded"); h.isDisposed = !0, h.dispose.apply(h.instance), this._addons.splice(c, 1) } } }, 8771: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferApiView = void 0; const c = h(3785), f = h(511); t.BufferApiView = class { constructor(n, l) { this._buffer = n, this.type = l } init(n) { return this._buffer = n, this } get cursorY() { return this._buffer.y } get cursorX() { return this._buffer.x } get viewportY() { return this._buffer.ydisp } get baseY() { return this._buffer.ybase } get length() { return this._buffer.lines.length } getLine(n) { const l = this._buffer.lines.get(n); if (l) return new c.BufferLineApiView(l) } getNullCell() { return new f.CellData } } }, 3785: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferLineApiView = void 0; const c = h(511); t.BufferLineApiView = class { constructor(f) { this._line = f } get isWrapped() { return this._line.isWrapped } get length() { return this._line.length } getCell(f, n) { if (!(f < 0 || f >= this._line.length)) return n ? (this._line.loadCell(f, n), n) : this._line.loadCell(f, new c.CellData) } translateToString(f, n, l) { return this._line.translateToString(f, n, l) } } }, 8285: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferNamespaceApi = void 0; const c = h(8771), f = h(8460), n = h(844); class l extends n.Disposable { constructor(v) { super(), this._core = v, this._onBufferChange = this.register(new f.EventEmitter), this.onBufferChange = this._onBufferChange.event, this._normal = new c.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new c.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active)) } get active() { if (this._core.buffers.active === this._core.buffers.normal) return this.normal; if (this._core.buffers.active === this._core.buffers.alt) return this.alternate; throw new Error("Active buffer is neither normal nor alternate") } get normal() { return this._normal.init(this._core.buffers.normal) } get alternate() { return this._alternate.init(this._core.buffers.alt) } } t.BufferNamespaceApi = l }, 7975: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ParserApi = void 0, t.ParserApi = class { constructor(h) { this._core = h } registerCsiHandler(h, c) { return this._core.registerCsiHandler(h, f => c(f.toArray())) } addCsiHandler(h, c) { return this.registerCsiHandler(h, c) } registerDcsHandler(h, c) { return this._core.registerDcsHandler(h, (f, n) => c(f, n.toArray())) } addDcsHandler(h, c) { return this.registerDcsHandler(h, c) } registerEscHandler(h, c) { return this._core.registerEscHandler(h, c) } addEscHandler(h, c) { return this.registerEscHandler(h, c) } registerOscHandler(h, c) { return this._core.registerOscHandler(h, c) } addOscHandler(h, c) { return this.registerOscHandler(h, c) } } }, 7090: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.UnicodeApi = void 0, t.UnicodeApi = class { constructor(h) { this._core = h } register(h) { this._core.unicodeService.register(h) } get versions() { return this._core.unicodeService.versions } get activeVersion() { return this._core.unicodeService.activeVersion } set activeVersion(h) { this._core.unicodeService.activeVersion = h } } }, 744: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.BufferService = t.MINIMUM_ROWS = t.MINIMUM_COLS = void 0; const n = h(8460), l = h(844), _ = h(5295), v = h(2585); t.MINIMUM_COLS = 2, t.MINIMUM_ROWS = 1; let o = t.BufferService = class extends l.Disposable { get buffer() { return this.buffers.active } constructor(e) { super(), this.isUserScrolling = !1, this._onResize = this.register(new n.EventEmitter), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter), this.onScroll = this._onScroll.event, this.cols = Math.max(e.rawOptions.cols || 0, t.MINIMUM_COLS), this.rows = Math.max(e.rawOptions.rows || 0, t.MINIMUM_ROWS), this.buffers = this.register(new _.BufferSet(e, this)) } resize(e, s) { this.cols = e, this.rows = s, this.buffers.resize(e, s), this._onResize.fire({ cols: e, rows: s }) } reset() { this.buffers.reset(), this.isUserScrolling = !1 } scroll(e, s = !1) { const i = this.buffer; let r; r = this._cachedBlankLine, r && r.length === this.cols && r.getFg(0) === e.fg && r.getBg(0) === e.bg || (r = i.getBlankLine(e, s), this._cachedBlankLine = r), r.isWrapped = s; const d = i.ybase + i.scrollTop, u = i.ybase + i.scrollBottom; if (i.scrollTop === 0) { const p = i.lines.isFull; u === i.lines.length - 1 ? p ? i.lines.recycle().copyFrom(r) : i.lines.push(r.clone()) : i.lines.splice(u + 1, 0, r.clone()), p ? this.isUserScrolling && (i.ydisp = Math.max(i.ydisp - 1, 0)) : (i.ybase++, this.isUserScrolling || i.ydisp++) } else { const p = u - d + 1; i.lines.shiftElements(d + 1, p - 1, -1), i.lines.set(u, r.clone()) } this.isUserScrolling || (i.ydisp = i.ybase), this._onScroll.fire(i.ydisp) } scrollLines(e, s, i) { const r = this.buffer; if (e < 0) { if (r.ydisp === 0) return; this.isUserScrolling = !0 } else e + r.ydisp >= r.ybase && (this.isUserScrolling = !1); const d = r.ydisp; r.ydisp = Math.max(Math.min(r.ydisp + e, r.ybase), 0), d !== r.ydisp && (s || this._onScroll.fire(r.ydisp)) } }; t.BufferService = o = c([f(0, v.IOptionsService)], o) }, 7994: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CharsetService = void 0, t.CharsetService = class { constructor() { this.glevel = 0, this._charsets = [] } reset() { this.charset = void 0, this._charsets = [], this.glevel = 0 } setgLevel(h) { this.glevel = h, this.charset = this._charsets[h] } setgCharset(h, c) { this._charsets[h] = c, this.glevel === h && (this.charset = c) } } }, 1753: function (P, t, h) { var c = this && this.__decorate || function (r, d, u, p) { var S, a = arguments.length, g = a < 3 ? d : p === null ? p = Object.getOwnPropertyDescriptor(d, u) : p; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") g = Reflect.decorate(r, d, u, p); else for (var w = r.length - 1; w >= 0; w--)(S = r[w]) && (g = (a < 3 ? S(g) : a > 3 ? S(d, u, g) : S(d, u)) || g); return a > 3 && g && Object.defineProperty(d, u, g), g }, f = this && this.__param || function (r, d) { return function (u, p) { d(u, p, r) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.CoreMouseService = void 0; const n = h(2585), l = h(8460), _ = h(844), v = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: r => r.button !== 4 && r.action === 1 && (r.ctrl = !1, r.alt = !1, r.shift = !1, !0) }, VT200: { events: 19, restrict: r => r.action !== 32 }, DRAG: { events: 23, restrict: r => r.action !== 32 || r.button !== 3 }, ANY: { events: 31, restrict: r => !0 } }; function o(r, d) { let u = (r.ctrl ? 16 : 0) | (r.shift ? 4 : 0) | (r.alt ? 8 : 0); return r.button === 4 ? (u |= 64, u |= r.action) : (u |= 3 & r.button, 4 & r.button && (u |= 64), 8 & r.button && (u |= 128), r.action === 32 ? u |= 32 : r.action !== 0 || d || (u |= 3)), u } const e = String.fromCharCode, s = { DEFAULT: r => { const d = [o(r, !1) + 32, r.col + 32, r.row + 32]; return d[0] > 255 || d[1] > 255 || d[2] > 255 ? "" : `\x1B[M${e(d[0])}${e(d[1])}${e(d[2])}` }, SGR: r => { const d = r.action === 0 && r.button !== 4 ? "m" : "M"; return `\x1B[<${o(r, !0)};${r.col};${r.row}${d}` }, SGR_PIXELS: r => { const d = r.action === 0 && r.button !== 4 ? "m" : "M"; return `\x1B[<${o(r, !0)};${r.x};${r.y}${d}` } }; let i = t.CoreMouseService = class extends _.Disposable { constructor(r, d) { super(), this._bufferService = r, this._coreService = d, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new l.EventEmitter), this.onProtocolChange = this._onProtocolChange.event; for (const u of Object.keys(v)) this.addProtocol(u, v[u]); for (const u of Object.keys(s)) this.addEncoding(u, s[u]); this.reset() } addProtocol(r, d) { this._protocols[r] = d } addEncoding(r, d) { this._encodings[r] = d } get activeProtocol() { return this._activeProtocol } get areMouseEventsActive() { return this._protocols[this._activeProtocol].events !== 0 } set activeProtocol(r) { if (!this._protocols[r]) throw new Error(`unknown protocol "${r}"`); this._activeProtocol = r, this._onProtocolChange.fire(this._protocols[r].events) } get activeEncoding() { return this._activeEncoding } set activeEncoding(r) { if (!this._encodings[r]) throw new Error(`unknown encoding "${r}"`); this._activeEncoding = r } reset() { this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null } triggerMouseEvent(r) { if (r.col < 0 || r.col >= this._bufferService.cols || r.row < 0 || r.row >= this._bufferService.rows || r.button === 4 && r.action === 32 || r.button === 3 && r.action !== 32 || r.button !== 4 && (r.action === 2 || r.action === 3) || (r.col++, r.row++, r.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, r, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(r)) return !1; const d = this._encodings[this._activeEncoding](r); return d && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(d) : this._coreService.triggerDataEvent(d, !0)), this._lastEvent = r, !0 } explainEvents(r) { return { down: !!(1 & r), up: !!(2 & r), drag: !!(4 & r), move: !!(8 & r), wheel: !!(16 & r) } } _equalEvents(r, d, u) { if (u) { if (r.x !== d.x || r.y !== d.y) return !1 } else if (r.col !== d.col || r.row !== d.row) return !1; return r.button === d.button && r.action === d.action && r.ctrl === d.ctrl && r.alt === d.alt && r.shift === d.shift } }; t.CoreMouseService = i = c([f(0, n.IBufferService), f(1, n.ICoreService)], i) }, 6975: function (P, t, h) { var c = this && this.__decorate || function (i, r, d, u) { var p, S = arguments.length, a = S < 3 ? r : u === null ? u = Object.getOwnPropertyDescriptor(r, d) : u; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") a = Reflect.decorate(i, r, d, u); else for (var g = i.length - 1; g >= 0; g--)(p = i[g]) && (a = (S < 3 ? p(a) : S > 3 ? p(r, d, a) : p(r, d)) || a); return S > 3 && a && Object.defineProperty(r, d, a), a }, f = this && this.__param || function (i, r) { return function (d, u) { r(d, u, i) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.CoreService = void 0; const n = h(1439), l = h(8460), _ = h(844), v = h(2585), o = Object.freeze({ insertMode: !1 }), e = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 }); let s = t.CoreService = class extends _.Disposable { constructor(i, r, d) { super(), this._bufferService = i, this._logService = r, this._optionsService = d, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new l.EventEmitter), this.onData = this._onData.event, this._onUserInput = this.register(new l.EventEmitter), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new l.EventEmitter), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new l.EventEmitter), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(o), this.decPrivateModes = (0, n.clone)(e) } reset() { this.modes = (0, n.clone)(o), this.decPrivateModes = (0, n.clone)(e) } triggerDataEvent(i, r = !1) { if (this._optionsService.rawOptions.disableStdin) return; const d = this._bufferService.buffer; r && this._optionsService.rawOptions.scrollOnUserInput && d.ybase !== d.ydisp && this._onRequestScrollToBottom.fire(), r && this._onUserInput.fire(), this._logService.debug(`sending data "${i}"`, () => i.split("").map(u => u.charCodeAt(0))), this._onData.fire(i) } triggerBinaryEvent(i) { this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${i}"`, () => i.split("").map(r => r.charCodeAt(0))), this._onBinary.fire(i)) } }; t.CoreService = s = c([f(0, v.IBufferService), f(1, v.ILogService), f(2, v.IOptionsService)], s) }, 9074: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.DecorationService = void 0; const c = h(8055), f = h(8460), n = h(844), l = h(6106); let _ = 0, v = 0; class o extends n.Disposable { get decorations() { return this._decorations.values() } constructor() { super(), this._decorations = new l.SortedList(i => i?.marker.line), this._onDecorationRegistered = this.register(new f.EventEmitter), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new f.EventEmitter), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset())) } registerDecoration(i) { if (i.marker.isDisposed) return; const r = new e(i); if (r) { const d = r.marker.onDispose(() => r.dispose()); r.onDispose(() => { r && (this._decorations.delete(r) && this._onDecorationRemoved.fire(r), d.dispose()) }), this._decorations.insert(r), this._onDecorationRegistered.fire(r) } return r } reset() { for (const i of this._decorations.values()) i.dispose(); this._decorations.clear() } *getDecorationsAtCell(i, r, d) { var u, p, S; let a = 0, g = 0; for (const w of this._decorations.getKeyIterator(r)) a = (u = w.options.x) !== null && u !== void 0 ? u : 0, g = a + ((p = w.options.width) !== null && p !== void 0 ? p : 1), i >= a && i < g && (!d || ((S = w.options.layer) !== null && S !== void 0 ? S : "bottom") === d) && (yield w) } forEachDecorationAtCell(i, r, d, u) { this._decorations.forEachByKey(r, p => { var S, a, g; _ = (S = p.options.x) !== null && S !== void 0 ? S : 0, v = _ + ((a = p.options.width) !== null && a !== void 0 ? a : 1), i >= _ && i < v && (!d || ((g = p.options.layer) !== null && g !== void 0 ? g : "bottom") === d) && u(p) }) } } t.DecorationService = o; class e extends n.Disposable { get isDisposed() { return this._isDisposed } get backgroundColorRGB() { return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = c.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg } get foregroundColorRGB() { return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = c.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg } constructor(i) { super(), this.options = i, this.onRenderEmitter = this.register(new f.EventEmitter), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new f.EventEmitter), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = i.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full") } dispose() { this._onDispose.fire(), super.dispose() } } }, 4348: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.InstantiationService = t.ServiceCollection = void 0; const c = h(2585), f = h(8343); class n { constructor(..._) { this._entries = new Map; for (const [v, o] of _) this.set(v, o) } set(_, v) { const o = this._entries.get(_); return this._entries.set(_, v), o } forEach(_) { for (const [v, o] of this._entries.entries()) _(v, o) } has(_) { return this._entries.has(_) } get(_) { return this._entries.get(_) } } t.ServiceCollection = n, t.InstantiationService = class { constructor() { this._services = new n, this._services.set(c.IInstantiationService, this) } setService(l, _) { this._services.set(l, _) } getService(l) { return this._services.get(l) } createInstance(l, ..._) { const v = (0, f.getServiceDependencies)(l).sort((s, i) => s.index - i.index), o = []; for (const s of v) { const i = this._services.get(s.id); if (!i) throw new Error(`[createInstance] ${l.name} depends on UNKNOWN service ${s.id}.`); o.push(i) } const e = v.length > 0 ? v[0].index : _.length; if (_.length !== e) throw new Error(`[createInstance] First service dependency of ${l.name} at position ${e + 1} conflicts with ${_.length} static arguments`); return new l(..._, ...o) } } }, 7866: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.traceCall = t.setTraceLogger = t.LogService = void 0; const n = h(844), l = h(2585), _ = { trace: l.LogLevelEnum.TRACE, debug: l.LogLevelEnum.DEBUG, info: l.LogLevelEnum.INFO, warn: l.LogLevelEnum.WARN, error: l.LogLevelEnum.ERROR, off: l.LogLevelEnum.OFF }; let v, o = t.LogService = class extends n.Disposable { get logLevel() { return this._logLevel } constructor(e) { super(), this._optionsService = e, this._logLevel = l.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), v = this } _updateLogLevel() { this._logLevel = _[this._optionsService.rawOptions.logLevel] } _evalLazyOptionalParams(e) { for (let s = 0; s < e.length; s++)typeof e[s] == "function" && (e[s] = e[s]()) } _log(e, s, i) { this._evalLazyOptionalParams(i), e.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + s, ...i) } trace(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.TRACE && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.trace.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.log, e, s) } debug(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.DEBUG && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.debug.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.log, e, s) } info(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.INFO && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.info.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.info, e, s) } warn(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.WARN && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.warn.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.warn, e, s) } error(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.ERROR && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.error.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.error, e, s) } }; t.LogService = o = c([f(0, l.IOptionsService)], o), t.setTraceLogger = function (e) { v = e }, t.traceCall = function (e, s, i) { if (typeof i.value != "function") throw new Error("not supported"); const r = i.value; i.value = function (...d) { if (v.logLevel !== l.LogLevelEnum.TRACE) return r.apply(this, d); v.trace(`GlyphRenderer#${r.name}(${d.map(p => JSON.stringify(p)).join(", ")})`); const u = r.apply(this, d); return v.trace(`GlyphRenderer#${r.name} return`, u), u } } }, 7302: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.OptionsService = t.DEFAULT_OPTIONS = void 0; const c = h(8460), f = h(844), n = h(6114); t.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 }; const l = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]; class _ extends f.Disposable { constructor(o) { super(), this._onOptionChange = this.register(new c.EventEmitter), this.onOptionChange = this._onOptionChange.event; const e = Object.assign({}, t.DEFAULT_OPTIONS); for (const s in o) if (s in e) try { const i = o[s]; e[s] = this._sanitizeAndValidateOption(s, i) } catch (i) { console.error(i) } this.rawOptions = e, this.options = Object.assign({}, e), this._setupOptions() } onSpecificOptionChange(o, e) { return this.onOptionChange(s => { s === o && e(this.rawOptions[o]) }) } onMultipleOptionChange(o, e) { return this.onOptionChange(s => { o.indexOf(s) !== -1 && e() }) } _setupOptions() { const o = s => { if (!(s in t.DEFAULT_OPTIONS)) throw new Error(`No option with key "${s}"`); return this.rawOptions[s] }, e = (s, i) => { if (!(s in t.DEFAULT_OPTIONS)) throw new Error(`No option with key "${s}"`); i = this._sanitizeAndValidateOption(s, i), this.rawOptions[s] !== i && (this.rawOptions[s] = i, this._onOptionChange.fire(s)) }; for (const s in this.rawOptions) { const i = { get: o.bind(this, s), set: e.bind(this, s) }; Object.defineProperty(this.options, s, i) } } _sanitizeAndValidateOption(o, e) { switch (o) { case "cursorStyle": if (e || (e = t.DEFAULT_OPTIONS[o]), !function (s) { return s === "block" || s === "underline" || s === "bar" }(e)) throw new Error(`"${e}" is not a valid value for ${o}`); break; case "wordSeparator": e || (e = t.DEFAULT_OPTIONS[o]); break; case "fontWeight": case "fontWeightBold": if (typeof e == "number" && 1 <= e && e <= 1e3) break; e = l.includes(e) ? e : t.DEFAULT_OPTIONS[o]; break; case "cursorWidth": e = Math.floor(e); case "lineHeight": case "tabStopWidth": if (e < 1) throw new Error(`${o} cannot be less than 1, value: ${e}`); break; case "minimumContrastRatio": e = Math.max(1, Math.min(21, Math.round(10 * e) / 10)); break; case "scrollback": if ((e = Math.min(e, 4294967295)) < 0) throw new Error(`${o} cannot be less than 0, value: ${e}`); break; case "fastScrollSensitivity": case "scrollSensitivity": if (e <= 0) throw new Error(`${o} cannot be less than or equal to 0, value: ${e}`); break; case "rows": case "cols": if (!e && e !== 0) throw new Error(`${o} must be numeric, value: ${e}`); break; case "windowsPty": e = e ?? {} }return e } } t.OptionsService = _ }, 2660: function (P, t, h) { var c = this && this.__decorate || function (_, v, o, e) { var s, i = arguments.length, r = i < 3 ? v : e === null ? e = Object.getOwnPropertyDescriptor(v, o) : e; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(_, v, o, e); else for (var d = _.length - 1; d >= 0; d--)(s = _[d]) && (r = (i < 3 ? s(r) : i > 3 ? s(v, o, r) : s(v, o)) || r); return i > 3 && r && Object.defineProperty(v, o, r), r }, f = this && this.__param || function (_, v) { return function (o, e) { v(o, e, _) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.OscLinkService = void 0; const n = h(2585); let l = t.OscLinkService = class { constructor(_) { this._bufferService = _, this._nextId = 1, this._entriesWithId = new Map, this._dataByLinkId = new Map } registerLink(_) { const v = this._bufferService.buffer; if (_.id === void 0) { const d = v.addMarker(v.ybase + v.y), u = { data: _, id: this._nextId++, lines: [d] }; return d.onDispose(() => this._removeMarkerFromLink(u, d)), this._dataByLinkId.set(u.id, u), u.id } const o = _, e = this._getEntryIdKey(o), s = this._entriesWithId.get(e); if (s) return this.addLineToLink(s.id, v.ybase + v.y), s.id; const i = v.addMarker(v.ybase + v.y), r = { id: this._nextId++, key: this._getEntryIdKey(o), data: o, lines: [i] }; return i.onDispose(() => this._removeMarkerFromLink(r, i)), this._entriesWithId.set(r.key, r), this._dataByLinkId.set(r.id, r), r.id } addLineToLink(_, v) { const o = this._dataByLinkId.get(_); if (o && o.lines.every(e => e.line !== v)) { const e = this._bufferService.buffer.addMarker(v); o.lines.push(e), e.onDispose(() => this._removeMarkerFromLink(o, e)) } } getLinkData(_) { var v; return (v = this._dataByLinkId.get(_)) === null || v === void 0 ? void 0 : v.data } _getEntryIdKey(_) { return `${_.id};;${_.uri}` } _removeMarkerFromLink(_, v) { const o = _.lines.indexOf(v); o !== -1 && (_.lines.splice(o, 1), _.lines.length === 0 && (_.data.id !== void 0 && this._entriesWithId.delete(_.key), this._dataByLinkId.delete(_.id))) } }; t.OscLinkService = l = c([f(0, n.IBufferService)], l) }, 8343: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0; const h = "di$target", c = "di$dependencies"; t.serviceRegistry = new Map, t.getServiceDependencies = function (f) { return f[c] || [] }, t.createDecorator = function (f) { if (t.serviceRegistry.has(f)) return t.serviceRegistry.get(f); const n = function (l, _, v) { if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter"); (function (o, e, s) { e[h] === e ? e[c].push({ id: o, index: s }) : (e[c] = [{ id: o, index: s }], e[h] = e) })(n, l, v) }; return n.toString = () => f, t.serviceRegistry.set(f, n), n } }, 2585: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0; const c = h(8343); var f; t.IBufferService = (0, c.createDecorator)("BufferService"), t.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), t.ICoreService = (0, c.createDecorator)("CoreService"), t.ICharsetService = (0, c.createDecorator)("CharsetService"), t.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function (n) { n[n.TRACE = 0] = "TRACE", n[n.DEBUG = 1] = "DEBUG", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.OFF = 5] = "OFF" }(f || (t.LogLevelEnum = f = {})), t.ILogService = (0, c.createDecorator)("LogService"), t.IOptionsService = (0, c.createDecorator)("OptionsService"), t.IOscLinkService = (0, c.createDecorator)("OscLinkService"), t.IUnicodeService = (0, c.createDecorator)("UnicodeService"), t.IDecorationService = (0, c.createDecorator)("DecorationService") }, 1480: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.UnicodeService = void 0; const c = h(8460), f = h(225); t.UnicodeService = class { constructor() { this._providers = Object.create(null), this._active = "", this._onChange = new c.EventEmitter, this.onChange = this._onChange.event; const n = new f.UnicodeV6; this.register(n), this._active = n.version, this._activeProvider = n } dispose() { this._onChange.dispose() } get versions() { return Object.keys(this._providers) } get activeVersion() { return this._active } set activeVersion(n) { if (!this._providers[n]) throw new Error(`unknown Unicode version "${n}"`); this._active = n, this._activeProvider = this._providers[n], this._onChange.fire(n) } register(n) { this._providers[n.version] = n } wcwidth(n) { return this._activeProvider.wcwidth(n) } getStringCellWidth(n) { let l = 0; const _ = n.length; for (let v = 0; v < _; ++v) { let o = n.charCodeAt(v); if (55296 <= o && o <= 56319) { if (++v >= _) return l + this.wcwidth(o); const e = n.charCodeAt(v); 56320 <= e && e <= 57343 ? o = 1024 * (o - 55296) + e - 56320 + 65536 : l += this.wcwidth(e) } l += this.wcwidth(o) } return l } } }
    }, ie = {}; function J(P) { var t = ie[P]; if (t !== void 0) return t.exports; var h = ie[P] = { exports: {} }; return ae[P].call(h.exports, h, h.exports, J), h.exports } var re = {}; return (() => {
      var P = re; Object.defineProperty(P, "__esModule", { value: !0 }), P.Terminal = void 0; const t = J(9042), h = J(3236), c = J(844), f = J(5741), n = J(8285), l = J(7975), _ = J(7090), v = ["cols", "rows"]; class o extends c.Disposable {
        constructor(s) { super(), this._core = this.register(new h.Terminal(s)), this._addonManager = this.register(new f.AddonManager), this._publicOptions = Object.assign({}, this._core.options); const i = d => this._core.options[d], r = (d, u) => { this._checkReadonlyOptions(d), this._core.options[d] = u }; for (const d in this._core.options) { const u = { get: i.bind(this, d), set: r.bind(this, d) }; Object.defineProperty(this._publicOptions, d, u) } } _checkReadonlyOptions(s) { if (v.includes(s)) throw new Error(`Option "${s}" can only be set in the constructor`) } _checkProposedApi() { if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API") } get onBell() { return this._core.onBell } get onBinary() { return this._core.onBinary } get onCursorMove() { return this._core.onCursorMove } get onData() { return this._core.onData } get onKey() { return this._core.onKey } get onLineFeed() { return this._core.onLineFeed } get onRender() { return this._core.onRender } get onResize() { return this._core.onResize } get onScroll() { return this._core.onScroll } get onSelectionChange() { return this._core.onSelectionChange } get onTitleChange() { return this._core.onTitleChange } get onWriteParsed() { return this._core.onWriteParsed } get element() { return this._core.element } get parser() { return this._parser || (this._parser = new l.ParserApi(this._core)), this._parser } get unicode() { return this._checkProposedApi(), new _.UnicodeApi(this._core) } get textarea() { return this._core.textarea } get rows() { return this._core.rows } get cols() { return this._core.cols } get buffer() { return this._buffer || (this._buffer = this.register(new n.BufferNamespaceApi(this._core))), this._buffer } get markers() { return this._checkProposedApi(), this._core.markers } get modes() { const s = this._core.coreService.decPrivateModes; let i = "none"; switch (this._core.coreMouseService.activeProtocol) { case "X10": i = "x10"; break; case "VT200": i = "vt200"; break; case "DRAG": i = "drag"; break; case "ANY": i = "any" }return { applicationCursorKeysMode: s.applicationCursorKeys, applicationKeypadMode: s.applicationKeypad, bracketedPasteMode: s.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: i, originMode: s.origin, reverseWraparoundMode: s.reverseWraparound, sendFocusMode: s.sendFocus, wraparoundMode: s.wraparound } } get options() { return this._publicOptions } set options(s) { for (const i in s) this._publicOptions[i] = s[i] } blur() { this._core.blur() } focus() { this._core.focus() } resize(s, i) { this._verifyIntegers(s, i), this._core.resize(s, i) } open(s) { this._core.open(s) } attachCustomKeyEventHandler(s) { this._core.attachCustomKeyEventHandler(s) } registerLinkProvider(s) { return this._core.registerLinkProvider(s) } registerCharacterJoiner(s) { return this._checkProposedApi(), this._core.registerCharacterJoiner(s) } deregisterCharacterJoiner(s) { this._checkProposedApi(), this._core.deregisterCharacterJoiner(s) } registerMarker(s = 0) { return this._verifyIntegers(s), this._core.registerMarker(s) } registerDecoration(s) { var i, r, d; return this._checkProposedApi(), this._verifyPositiveIntegers((i = s.x) !== null && i !== void 0 ? i : 0, (r = s.width) !== null && r !== void 0 ? r : 0, (d = s.height) !== null && d !== void 0 ? d : 0), this._core.registerDecoration(s) } hasSelection() { return this._core.hasSelection() } select(s, i, r) { this._verifyIntegers(s, i, r), this._core.select(s, i, r) } getSelection() { return this._core.getSelection() } getSelectionPosition() { return this._core.getSelectionPosition() } clearSelection() { this._core.clearSelection() } selectAll() { this._core.selectAll() } selectLines(s, i) { this._verifyIntegers(s, i), this._core.selectLines(s, i) } dispose() { super.dispose() } scrollLines(s) { this._verifyIntegers(s), this._core.scrollLines(s) } scrollPages(s) { this._verifyIntegers(s), this._core.scrollPages(s) } scrollToTop() { this._core.scrollToTop() } scrollToBottom() { this._core.scrollToBottom() } scrollToLine(s) { this._verifyIntegers(s), this._core.scrollToLine(s) } clear() { this._core.clear() } write(s, i) { this._core.write(s, i) } writeln(s, i) {
          this._core.write(s), this._core.write(`\r
`, i)
        } paste(s) { this._core.paste(s) } refresh(s, i) { this._verifyIntegers(s, i), this._core.refresh(s, i) } reset() { this._core.reset() } clearTextureAtlas() { this._core.clearTextureAtlas() } loadAddon(s) { this._addonManager.loadAddon(this, s) } static get strings() { return t } _verifyIntegers(...s) { for (const i of s) if (i === 1 / 0 || isNaN(i) || i % 1 != 0) throw new Error("This API only accepts integers") } _verifyPositiveIntegers(...s) { for (const i of s) if (i && (i === 1 / 0 || isNaN(i) || i % 1 != 0 || i < 0)) throw new Error("This API only accepts positive integers") }
      } P.Terminal = o
    })(), re
  })())
})(Se); var Ee = Se.exports, we = { exports: {} }; (function (ue, pe) { (function (ae, ie) { ue.exports = ie() })(self, () => (() => { var ae = {}; return (() => { var ie = ae; Object.defineProperty(ie, "__esModule", { value: !0 }), ie.FitAddon = void 0, ie.FitAddon = class { activate(J) { this._terminal = J } dispose() { } fit() { const J = this.proposeDimensions(); if (!J || !this._terminal || isNaN(J.cols) || isNaN(J.rows)) return; const re = this._terminal._core; this._terminal.rows === J.rows && this._terminal.cols === J.cols || (re._renderService.clear(), this._terminal.resize(J.cols, J.rows)) } proposeDimensions() { if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement) return; const J = this._terminal._core, re = J._renderService.dimensions; if (re.css.cell.width === 0 || re.css.cell.height === 0) return; const P = this._terminal.options.scrollback === 0 ? 0 : J.viewport.scrollBarWidth, t = window.getComputedStyle(this._terminal.element.parentElement), h = parseInt(t.getPropertyValue("height")), c = Math.max(0, parseInt(t.getPropertyValue("width"))), f = window.getComputedStyle(this._terminal.element), n = h - (parseInt(f.getPropertyValue("padding-top")) + parseInt(f.getPropertyValue("padding-bottom"))), l = c - (parseInt(f.getPropertyValue("padding-right")) + parseInt(f.getPropertyValue("padding-left"))) - P; return { cols: Math.max(2, Math.floor(l / re.css.cell.width)), rows: Math.max(1, Math.floor(n / re.css.cell.height)) } } } })(), ae })()) })(we); var xe = we.exports, ye = { exports: {} }; (function (ue, pe) {
  (function (ae, ie) { ue.exports = ie() })(self, () => (() => {
    var ae = {
      965: function (P, t, h) {
        var c = this && this.__decorate || function (S, a, g, w) { var m, C = arguments.length, L = C < 3 ? a : w === null ? w = Object.getOwnPropertyDescriptor(a, g) : w; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") L = Reflect.decorate(S, a, g, w); else for (var R = S.length - 1; R >= 0; R--)(m = S[R]) && (L = (C < 3 ? m(L) : C > 3 ? m(a, g, L) : m(a, g)) || L); return C > 3 && L && Object.defineProperty(a, g, L), L }; Object.defineProperty(t, "__esModule", { value: !0 }), t.GlyphRenderer = void 0; const f = h(374), n = h(509), l = h(855), _ = h(859), v = h(776), o = h(381), e = 11, s = e * Float32Array.BYTES_PER_ELEMENT; let i, r = 0, d = 0, u = 0; class p extends _.Disposable {
          constructor(a, g, w) {
            super(), this._terminal = a, this._gl = g, this._dimensions = w, this._activeBuffer = 0, this._vertices = { count: 0, attributes: new Float32Array(0), attributesBuffers: [new Float32Array(0), new Float32Array(0)] }; const m = this._gl; n.TextureAtlas.maxAtlasPages === void 0 && (n.TextureAtlas.maxAtlasPages = Math.min(32, (0, f.throwIfFalsy)(m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS))), n.TextureAtlas.maxTextureSize = (0, f.throwIfFalsy)(m.getParameter(m.MAX_TEXTURE_SIZE))), this._program = (0, f.throwIfFalsy)((0, o.createProgram)(m, `#version 300 es
layout (location = 0) in vec2 a_unitquad;
layout (location = 1) in vec2 a_cellpos;
layout (location = 2) in vec2 a_offset;
layout (location = 3) in vec2 a_size;
layout (location = 4) in float a_texpage;
layout (location = 5) in vec2 a_texcoord;
layout (location = 6) in vec2 a_texsize;

uniform mat4 u_projection;
uniform vec2 u_resolution;

out vec2 v_texcoord;
flat out int v_texpage;

void main() {
  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);
  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);
  v_texpage = int(a_texpage);
  v_texcoord = a_texcoord + a_unitquad * a_texsize;
}`, function (k) {
              let b = ""; for (let E = 1; E < k; E++)b += ` else if (v_texpage == ${E}) { outColor = texture(u_texture[${E}], v_texcoord); }`; return `#version 300 es
precision lowp float;

in vec2 v_texcoord;
flat in int v_texpage;

uniform sampler2D u_texture[${k}];

out vec4 outColor;

void main() {
  if (v_texpage == 0) {
    outColor = texture(u_texture[0], v_texcoord);
  } ${b}
}`}(n.TextureAtlas.maxAtlasPages))), this.register((0, _.toDisposable)(() => m.deleteProgram(this._program))), this._projectionLocation = (0, f.throwIfFalsy)(m.getUniformLocation(this._program, "u_projection")), this._resolutionLocation = (0, f.throwIfFalsy)(m.getUniformLocation(this._program, "u_resolution")), this._textureLocation = (0, f.throwIfFalsy)(m.getUniformLocation(this._program, "u_texture")), this._vertexArrayObject = m.createVertexArray(), m.bindVertexArray(this._vertexArrayObject); const C = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), L = m.createBuffer(); this.register((0, _.toDisposable)(() => m.deleteBuffer(L))), m.bindBuffer(m.ARRAY_BUFFER, L), m.bufferData(m.ARRAY_BUFFER, C, m.STATIC_DRAW), m.enableVertexAttribArray(0), m.vertexAttribPointer(0, 2, this._gl.FLOAT, !1, 0, 0); const R = new Uint8Array([0, 1, 2, 3]), D = m.createBuffer(); this.register((0, _.toDisposable)(() => m.deleteBuffer(D))), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, D), m.bufferData(m.ELEMENT_ARRAY_BUFFER, R, m.STATIC_DRAW), this._attributesBuffer = (0, f.throwIfFalsy)(m.createBuffer()), this.register((0, _.toDisposable)(() => m.deleteBuffer(this._attributesBuffer))), m.bindBuffer(m.ARRAY_BUFFER, this._attributesBuffer), m.enableVertexAttribArray(2), m.vertexAttribPointer(2, 2, m.FLOAT, !1, s, 0), m.vertexAttribDivisor(2, 1), m.enableVertexAttribArray(3), m.vertexAttribPointer(3, 2, m.FLOAT, !1, s, 2 * Float32Array.BYTES_PER_ELEMENT), m.vertexAttribDivisor(3, 1), m.enableVertexAttribArray(4), m.vertexAttribPointer(4, 1, m.FLOAT, !1, s, 4 * Float32Array.BYTES_PER_ELEMENT), m.vertexAttribDivisor(4, 1), m.enableVertexAttribArray(5), m.vertexAttribPointer(5, 2, m.FLOAT, !1, s, 5 * Float32Array.BYTES_PER_ELEMENT), m.vertexAttribDivisor(5, 1), m.enableVertexAttribArray(6), m.vertexAttribPointer(6, 2, m.FLOAT, !1, s, 7 * Float32Array.BYTES_PER_ELEMENT), m.vertexAttribDivisor(6, 1), m.enableVertexAttribArray(1), m.vertexAttribPointer(1, 2, m.FLOAT, !1, s, 9 * Float32Array.BYTES_PER_ELEMENT), m.vertexAttribDivisor(1, 1), m.useProgram(this._program); const M = new Int32Array(n.TextureAtlas.maxAtlasPages); for (let k = 0; k < n.TextureAtlas.maxAtlasPages; k++)M[k] = k; m.uniform1iv(this._textureLocation, M), m.uniformMatrix4fv(this._projectionLocation, !1, o.PROJECTION_MATRIX), this._atlasTextures = []; for (let k = 0; k < n.TextureAtlas.maxAtlasPages; k++) { const b = new o.GLTexture((0, f.throwIfFalsy)(m.createTexture())); this.register((0, _.toDisposable)(() => m.deleteTexture(b.texture))), m.activeTexture(m.TEXTURE0 + k), m.bindTexture(m.TEXTURE_2D, b.texture), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 1, 1, 0, m.RGBA, m.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255])), this._atlasTextures[k] = b } m.enable(m.BLEND), m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA), this.handleResize()
          } beginFrame() { return !this._atlas || this._atlas.beginFrame() } updateCell(a, g, w, m, C, L, R, D) { this._updateCell(this._vertices.attributes, a, g, w, m, C, L, R, D) } _updateCell(a, g, w, m, C, L, R, D, M) { r = (w * this._terminal.cols + g) * e, m !== l.NULL_CELL_CODE && m !== void 0 ? this._atlas && (i = D && D.length > 1 ? this._atlas.getRasterizedGlyphCombinedChar(D, C, L, R, !1) : this._atlas.getRasterizedGlyph(m, C, L, R, !1), d = Math.floor((this._dimensions.device.cell.width - this._dimensions.device.char.width) / 2), C !== M && i.offset.x > d ? (u = i.offset.x - d, a[r] = -(i.offset.x - u) + this._dimensions.device.char.left, a[r + 1] = -i.offset.y + this._dimensions.device.char.top, a[r + 2] = (i.size.x - u) / this._dimensions.device.canvas.width, a[r + 3] = i.size.y / this._dimensions.device.canvas.height, a[r + 4] = i.texturePage, a[r + 5] = i.texturePositionClipSpace.x + u / this._atlas.pages[i.texturePage].canvas.width, a[r + 6] = i.texturePositionClipSpace.y, a[r + 7] = i.sizeClipSpace.x - u / this._atlas.pages[i.texturePage].canvas.width, a[r + 8] = i.sizeClipSpace.y) : (a[r] = -i.offset.x + this._dimensions.device.char.left, a[r + 1] = -i.offset.y + this._dimensions.device.char.top, a[r + 2] = i.size.x / this._dimensions.device.canvas.width, a[r + 3] = i.size.y / this._dimensions.device.canvas.height, a[r + 4] = i.texturePage, a[r + 5] = i.texturePositionClipSpace.x, a[r + 6] = i.texturePositionClipSpace.y, a[r + 7] = i.sizeClipSpace.x, a[r + 8] = i.sizeClipSpace.y)) : a.fill(0, r, r + e - 1 - 2) } clear() { const a = this._terminal, g = a.cols * a.rows * e; this._vertices.count !== g ? this._vertices.attributes = new Float32Array(g) : this._vertices.attributes.fill(0); let w = 0; for (; w < this._vertices.attributesBuffers.length; w++)this._vertices.count !== g ? this._vertices.attributesBuffers[w] = new Float32Array(g) : this._vertices.attributesBuffers[w].fill(0); this._vertices.count = g, w = 0; for (let m = 0; m < a.rows; m++)for (let C = 0; C < a.cols; C++)this._vertices.attributes[w + 9] = C / a.cols, this._vertices.attributes[w + 10] = m / a.rows, w += e } handleResize() { const a = this._gl; a.useProgram(this._program), a.viewport(0, 0, a.canvas.width, a.canvas.height), a.uniform2f(this._resolutionLocation, a.canvas.width, a.canvas.height), this.clear() } render(a) { if (!this._atlas) return; const g = this._gl; g.useProgram(this._program), g.bindVertexArray(this._vertexArrayObject), this._activeBuffer = (this._activeBuffer + 1) % 2; const w = this._vertices.attributesBuffers[this._activeBuffer]; let m = 0; for (let C = 0; C < a.lineLengths.length; C++) { const L = C * this._terminal.cols * e, R = this._vertices.attributes.subarray(L, L + a.lineLengths[C] * e); w.set(R, m), m += R.length } g.bindBuffer(g.ARRAY_BUFFER, this._attributesBuffer), g.bufferData(g.ARRAY_BUFFER, w.subarray(0, m), g.STREAM_DRAW); for (let C = 0; C < this._atlas.pages.length; C++)this._atlas.pages[C].version !== this._atlasTextures[C].version && this._bindAtlasPageTexture(g, this._atlas, C); g.drawElementsInstanced(g.TRIANGLE_STRIP, 4, g.UNSIGNED_BYTE, 0, m / e) } setAtlas(a) { this._atlas = a; for (const g of this._atlasTextures) g.version = -1 } _bindAtlasPageTexture(a, g, w) { a.activeTexture(a.TEXTURE0 + w), a.bindTexture(a.TEXTURE_2D, this._atlasTextures[w].texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, g.pages[w].canvas), a.generateMipmap(a.TEXTURE_2D), this._atlasTextures[w].version = g.pages[w].version } setDimensions(a) { this._dimensions = a }
        } t.GlyphRenderer = p, c([v.traceCall], p.prototype, "updateCell", null)
      }, 742: (P, t, h) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.RectangleRenderer = void 0; const c = h(374), f = h(859), n = h(310), l = h(381), _ = 8 * Float32Array.BYTES_PER_ELEMENT; class v { constructor() { this.attributes = new Float32Array(160), this.count = 0 } } let o = 0, e = 0, s = 0, i = 0, r = 0, d = 0, u = 0; class p extends f.Disposable {
          constructor(a, g, w, m) {
            super(), this._terminal = a, this._gl = g, this._dimensions = w, this._themeService = m, this._vertices = new v, this._verticesCursor = new v; const C = this._gl; this._program = (0, c.throwIfFalsy)((0, l.createProgram)(C, `#version 300 es
layout (location = 0) in vec2 a_position;
layout (location = 1) in vec2 a_size;
layout (location = 2) in vec4 a_color;
layout (location = 3) in vec2 a_unitquad;

uniform mat4 u_projection;

out vec4 v_color;

void main() {
  vec2 zeroToOne = a_position + (a_unitquad * a_size);
  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);
  v_color = a_color;
}`, `#version 300 es
precision lowp float;

in vec4 v_color;

out vec4 outColor;

void main() {
  outColor = v_color;
}`)), this.register((0, f.toDisposable)(() => C.deleteProgram(this._program))), this._projectionLocation = (0, c.throwIfFalsy)(C.getUniformLocation(this._program, "u_projection")), this._vertexArrayObject = C.createVertexArray(), C.bindVertexArray(this._vertexArrayObject); const L = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), R = C.createBuffer(); this.register((0, f.toDisposable)(() => C.deleteBuffer(R))), C.bindBuffer(C.ARRAY_BUFFER, R), C.bufferData(C.ARRAY_BUFFER, L, C.STATIC_DRAW), C.enableVertexAttribArray(3), C.vertexAttribPointer(3, 2, this._gl.FLOAT, !1, 0, 0); const D = new Uint8Array([0, 1, 2, 3]), M = C.createBuffer(); this.register((0, f.toDisposable)(() => C.deleteBuffer(M))), C.bindBuffer(C.ELEMENT_ARRAY_BUFFER, M), C.bufferData(C.ELEMENT_ARRAY_BUFFER, D, C.STATIC_DRAW), this._attributesBuffer = (0, c.throwIfFalsy)(C.createBuffer()), this.register((0, f.toDisposable)(() => C.deleteBuffer(this._attributesBuffer))), C.bindBuffer(C.ARRAY_BUFFER, this._attributesBuffer), C.enableVertexAttribArray(0), C.vertexAttribPointer(0, 2, C.FLOAT, !1, _, 0), C.vertexAttribDivisor(0, 1), C.enableVertexAttribArray(1), C.vertexAttribPointer(1, 2, C.FLOAT, !1, _, 2 * Float32Array.BYTES_PER_ELEMENT), C.vertexAttribDivisor(1, 1), C.enableVertexAttribArray(2), C.vertexAttribPointer(2, 4, C.FLOAT, !1, _, 4 * Float32Array.BYTES_PER_ELEMENT), C.vertexAttribDivisor(2, 1), this._updateCachedColors(m.colors), this.register(this._themeService.onChangeColors(k => { this._updateCachedColors(k), this._updateViewportRectangle() }))
          } renderBackgrounds() { this._renderVertices(this._vertices) } renderCursor() { this._renderVertices(this._verticesCursor) } _renderVertices(a) { const g = this._gl; g.useProgram(this._program), g.bindVertexArray(this._vertexArrayObject), g.uniformMatrix4fv(this._projectionLocation, !1, l.PROJECTION_MATRIX), g.bindBuffer(g.ARRAY_BUFFER, this._attributesBuffer), g.bufferData(g.ARRAY_BUFFER, a.attributes, g.DYNAMIC_DRAW), g.drawElementsInstanced(this._gl.TRIANGLE_STRIP, 4, g.UNSIGNED_BYTE, 0, a.count) } handleResize() { this._updateViewportRectangle() } setDimensions(a) { this._dimensions = a } _updateCachedColors(a) { this._bgFloat = this._colorToFloat32Array(a.background), this._cursorFloat = this._colorToFloat32Array(a.cursor) } _updateViewportRectangle() { this._addRectangleFloat(this._vertices.attributes, 0, 0, 0, this._terminal.cols * this._dimensions.device.cell.width, this._terminal.rows * this._dimensions.device.cell.height, this._bgFloat) } updateBackgrounds(a) { const g = this._terminal, w = this._vertices; let m, C, L, R, D, M, k, b, E, x, A, B = 1; for (m = 0; m < g.rows; m++) { for (L = -1, R = 0, D = 0, M = !1, C = 0; C < g.cols; C++)k = (m * g.cols + C) * n.RENDER_MODEL_INDICIES_PER_CELL, b = a.cells[k + n.RENDER_MODEL_BG_OFFSET], E = a.cells[k + n.RENDER_MODEL_FG_OFFSET], x = !!(67108864 & E), (b !== R || E !== D && (M || x)) && ((R !== 0 || M && D !== 0) && (A = 8 * B++, this._updateRectangle(w, A, D, R, L, C, m)), L = C, R = b, D = E, M = x); (R !== 0 || M && D !== 0) && (A = 8 * B++, this._updateRectangle(w, A, D, R, L, g.cols, m)) } w.count = B } updateCursor(a) { const g = this._verticesCursor, w = a.cursor; if (!w || w.style === "block") return void (g.count = 0); let m, C = 0; w.style !== "bar" && w.style !== "outline" || (m = 8 * C++, this._addRectangleFloat(g.attributes, m, w.x * this._dimensions.device.cell.width, w.y * this._dimensions.device.cell.height, w.style === "bar" ? w.dpr * w.cursorWidth : w.dpr, this._dimensions.device.cell.height, this._cursorFloat)), w.style !== "underline" && w.style !== "outline" || (m = 8 * C++, this._addRectangleFloat(g.attributes, m, w.x * this._dimensions.device.cell.width, (w.y + 1) * this._dimensions.device.cell.height - w.dpr, w.width * this._dimensions.device.cell.width, w.dpr, this._cursorFloat)), w.style === "outline" && (m = 8 * C++, this._addRectangleFloat(g.attributes, m, w.x * this._dimensions.device.cell.width, w.y * this._dimensions.device.cell.height, w.width * this._dimensions.device.cell.width, w.dpr, this._cursorFloat), m = 8 * C++, this._addRectangleFloat(g.attributes, m, (w.x + w.width) * this._dimensions.device.cell.width - w.dpr, w.y * this._dimensions.device.cell.height, w.dpr, this._dimensions.device.cell.height, this._cursorFloat)), g.count = C } _updateRectangle(a, g, w, m, C, L, R) { if (67108864 & w) switch (50331648 & w) { case 16777216: case 33554432: o = this._themeService.colors.ansi[255 & w].rgba; break; case 50331648: o = (16777215 & w) << 8; break; default: o = this._themeService.colors.foreground.rgba } else switch (50331648 & m) { case 16777216: case 33554432: o = this._themeService.colors.ansi[255 & m].rgba; break; case 50331648: o = (16777215 & m) << 8; break; default: o = this._themeService.colors.background.rgba }a.attributes.length < g + 4 && (a.attributes = (0, l.expandFloat32Array)(a.attributes, this._terminal.rows * this._terminal.cols * 8)), e = C * this._dimensions.device.cell.width, s = R * this._dimensions.device.cell.height, i = (o >> 24 & 255) / 255, r = (o >> 16 & 255) / 255, d = (o >> 8 & 255) / 255, u = 1, this._addRectangle(a.attributes, g, e, s, (L - C) * this._dimensions.device.cell.width, this._dimensions.device.cell.height, i, r, d, u) } _addRectangle(a, g, w, m, C, L, R, D, M, k) { a[g] = w / this._dimensions.device.canvas.width, a[g + 1] = m / this._dimensions.device.canvas.height, a[g + 2] = C / this._dimensions.device.canvas.width, a[g + 3] = L / this._dimensions.device.canvas.height, a[g + 4] = R, a[g + 5] = D, a[g + 6] = M, a[g + 7] = k } _addRectangleFloat(a, g, w, m, C, L, R) { a[g] = w / this._dimensions.device.canvas.width, a[g + 1] = m / this._dimensions.device.canvas.height, a[g + 2] = C / this._dimensions.device.canvas.width, a[g + 3] = L / this._dimensions.device.canvas.height, a[g + 4] = R[0], a[g + 5] = R[1], a[g + 6] = R[2], a[g + 7] = R[3] } _colorToFloat32Array(a) { return new Float32Array([(a.rgba >> 24 & 255) / 255, (a.rgba >> 16 & 255) / 255, (a.rgba >> 8 & 255) / 255, (255 & a.rgba) / 255]) }
        } t.RectangleRenderer = p
      }, 310: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.RenderModel = t.COMBINED_CHAR_BIT_MASK = t.RENDER_MODEL_EXT_OFFSET = t.RENDER_MODEL_FG_OFFSET = t.RENDER_MODEL_BG_OFFSET = t.RENDER_MODEL_INDICIES_PER_CELL = void 0; const c = h(296); t.RENDER_MODEL_INDICIES_PER_CELL = 4, t.RENDER_MODEL_BG_OFFSET = 1, t.RENDER_MODEL_FG_OFFSET = 2, t.RENDER_MODEL_EXT_OFFSET = 3, t.COMBINED_CHAR_BIT_MASK = 2147483648, t.RenderModel = class { constructor() { this.cells = new Uint32Array(0), this.lineLengths = new Uint32Array(0), this.selection = (0, c.createSelectionRenderModel)() } resize(f, n) { const l = f * n * t.RENDER_MODEL_INDICIES_PER_CELL; l !== this.cells.length && (this.cells = new Uint32Array(l), this.lineLengths = new Uint32Array(n)) } clear() { this.cells.fill(0, 0), this.lineLengths.fill(0, 0) } } }, 666: function (P, t, h) { var c = this && this.__decorate || function (L, R, D, M) { var k, b = arguments.length, E = b < 3 ? R : M === null ? M = Object.getOwnPropertyDescriptor(R, D) : M; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") E = Reflect.decorate(L, R, D, M); else for (var x = L.length - 1; x >= 0; x--)(k = L[x]) && (E = (b < 3 ? k(E) : b > 3 ? k(R, D, E) : k(R, D)) || E); return b > 3 && E && Object.defineProperty(R, D, E), E }; Object.defineProperty(t, "__esModule", { value: !0 }), t.JoinedCellData = t.WebglRenderer = void 0; const f = h(820), n = h(274), l = h(627), _ = h(457), v = h(56), o = h(374), e = h(345), s = h(859), i = h(147), r = h(782), d = h(855), u = h(776), p = h(965), S = h(742), a = h(310), g = h(733); class w extends s.Disposable { constructor(R, D, M, k, b, E, x, A, B) { super(), this._terminal = R, this._characterJoinerService = D, this._charSizeService = M, this._coreBrowserService = k, this._coreService = b, this._decorationService = E, this._optionsService = x, this._themeService = A, this._cursorBlinkStateManager = new s.MutableDisposable, this._charAtlasDisposable = this.register(new s.MutableDisposable), this._model = new a.RenderModel, this._workCell = new r.CellData, this._rectangleRenderer = this.register(new s.MutableDisposable), this._glyphRenderer = this.register(new s.MutableDisposable), this._onChangeTextureAtlas = this.register(new e.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new e.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new e.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onRequestRedraw = this.register(new e.EventEmitter), this.onRequestRedraw = this._onRequestRedraw.event, this._onContextLoss = this.register(new e.EventEmitter), this.onContextLoss = this._onContextLoss.event, this.register(this._themeService.onChangeColors(() => this._handleColorChange())), this._cellColorResolver = new n.CellColorResolver(this._terminal, this._model.selection, this._decorationService, this._coreBrowserService, this._themeService), this._core = this._terminal._core, this._renderLayers = [new g.LinkRenderLayer(this._core.screenElement, 2, this._terminal, this._core.linkifier2, this._coreBrowserService, x, this._themeService)], this.dimensions = (0, o.createRenderDimensions)(), this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this._updateCursorBlink(), this.register(x.onOptionChange(() => this._handleOptionsChanged())), this._canvas = document.createElement("canvas"); const F = { antialias: !1, depth: !1, preserveDrawingBuffer: B }; if (this._gl = this._canvas.getContext("webgl2", F), !this._gl) throw new Error("WebGL2 not supported " + this._gl); this.register((0, f.addDisposableDomListener)(this._canvas, "webglcontextlost", H => { console.log("webglcontextlost event received"), H.preventDefault(), this._contextRestorationTimeout = setTimeout(() => { this._contextRestorationTimeout = void 0, console.warn("webgl context not restored; firing onContextLoss"), this._onContextLoss.fire(H) }, 3e3) })), this.register((0, f.addDisposableDomListener)(this._canvas, "webglcontextrestored", H => { console.warn("webglcontextrestored event received"), clearTimeout(this._contextRestorationTimeout), this._contextRestorationTimeout = void 0, (0, l.removeTerminalFromCache)(this._terminal), this._initializeWebGLState(), this._requestRedrawViewport() })), this.register((0, v.observeDevicePixelDimensions)(this._canvas, this._coreBrowserService.window, (H, W) => this._setCanvasDevicePixelDimensions(H, W))), this._core.screenElement.appendChild(this._canvas), [this._rectangleRenderer.value, this._glyphRenderer.value] = this._initializeWebGLState(), this._isAttached = this._coreBrowserService.window.document.body.contains(this._core.screenElement), this.register((0, s.toDisposable)(() => { var H; for (const W of this._renderLayers) W.dispose(); (H = this._canvas.parentElement) === null || H === void 0 || H.removeChild(this._canvas), (0, l.removeTerminalFromCache)(this._terminal) })) } get textureAtlas() { var R; return (R = this._charAtlas) === null || R === void 0 ? void 0 : R.pages[0].canvas } _handleColorChange() { this._refreshCharAtlas(), this._clearModel(!0) } handleDevicePixelRatioChange() { this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.handleResize(this._terminal.cols, this._terminal.rows)) } handleResize(R, D) { var M, k, b, E; this._updateDimensions(), this._model.resize(this._terminal.cols, this._terminal.rows); for (const x of this._renderLayers) x.resize(this._terminal, this.dimensions); this._canvas.width = this.dimensions.device.canvas.width, this._canvas.height = this.dimensions.device.canvas.height, this._canvas.style.width = `${this.dimensions.css.canvas.width}px`, this._canvas.style.height = `${this.dimensions.css.canvas.height}px`, this._core.screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._core.screenElement.style.height = `${this.dimensions.css.canvas.height}px`, (M = this._rectangleRenderer.value) === null || M === void 0 || M.setDimensions(this.dimensions), (k = this._rectangleRenderer.value) === null || k === void 0 || k.handleResize(), (b = this._glyphRenderer.value) === null || b === void 0 || b.setDimensions(this.dimensions), (E = this._glyphRenderer.value) === null || E === void 0 || E.handleResize(), this._refreshCharAtlas(), this._clearModel(!1) } handleCharSizeChanged() { this.handleResize(this._terminal.cols, this._terminal.rows) } handleBlur() { var R; for (const D of this._renderLayers) D.handleBlur(this._terminal); (R = this._cursorBlinkStateManager.value) === null || R === void 0 || R.pause(), this._requestRedrawViewport() } handleFocus() { var R; for (const D of this._renderLayers) D.handleFocus(this._terminal); (R = this._cursorBlinkStateManager.value) === null || R === void 0 || R.resume(), this._requestRedrawViewport() } handleSelectionChanged(R, D, M) { for (const k of this._renderLayers) k.handleSelectionChanged(this._terminal, R, D, M); this._model.selection.update(this._terminal, R, D, M), this._requestRedrawViewport() } handleCursorMove() { var R; for (const D of this._renderLayers) D.handleCursorMove(this._terminal); (R = this._cursorBlinkStateManager.value) === null || R === void 0 || R.restartBlinkAnimation() } _handleOptionsChanged() { this._updateDimensions(), this._refreshCharAtlas(), this._updateCursorBlink() } _initializeWebGLState() { return this._rectangleRenderer.value = new S.RectangleRenderer(this._terminal, this._gl, this.dimensions, this._themeService), this._glyphRenderer.value = new p.GlyphRenderer(this._terminal, this._gl, this.dimensions), this.handleCharSizeChanged(), [this._rectangleRenderer.value, this._glyphRenderer.value] } _refreshCharAtlas() { var R; if (this.dimensions.device.char.width <= 0 && this.dimensions.device.char.height <= 0) return void (this._isAttached = !1); const D = (0, l.acquireTextureAtlas)(this._terminal, this._optionsService.rawOptions, this._themeService.colors, this.dimensions.device.cell.width, this.dimensions.device.cell.height, this.dimensions.device.char.width, this.dimensions.device.char.height, this._coreBrowserService.dpr); this._charAtlas !== D && (this._onChangeTextureAtlas.fire(D.pages[0].canvas), this._charAtlasDisposable.value = (0, s.getDisposeArrayDisposable)([(0, e.forwardEvent)(D.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas), (0, e.forwardEvent)(D.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)])), this._charAtlas = D, this._charAtlas.warmUp(), (R = this._glyphRenderer.value) === null || R === void 0 || R.setAtlas(this._charAtlas) } _clearModel(R) { var D; this._model.clear(), R && ((D = this._glyphRenderer.value) === null || D === void 0 || D.clear()) } clearTextureAtlas() { var R; (R = this._charAtlas) === null || R === void 0 || R.clearTexture(), this._clearModel(!0), this._requestRedrawViewport() } clear() { var R; this._clearModel(!0); for (const D of this._renderLayers) D.reset(this._terminal); (R = this._cursorBlinkStateManager.value) === null || R === void 0 || R.restartBlinkAnimation(), this._updateCursorBlink() } registerCharacterJoiner(R) { return -1 } deregisterCharacterJoiner(R) { return !1 } renderRows(R, D) { if (!this._isAttached) { if (!(this._coreBrowserService.window.document.body.contains(this._core.screenElement) && this._charSizeService.width && this._charSizeService.height)) return; this._updateDimensions(), this._refreshCharAtlas(), this._isAttached = !0 } for (const M of this._renderLayers) M.handleGridChanged(this._terminal, R, D); this._glyphRenderer.value && this._rectangleRenderer.value && (this._glyphRenderer.value.beginFrame() ? (this._clearModel(!0), this._updateModel(0, this._terminal.rows - 1)) : this._updateModel(R, D), this._rectangleRenderer.value.renderBackgrounds(), this._glyphRenderer.value.render(this._model), this._cursorBlinkStateManager.value && !this._cursorBlinkStateManager.value.isCursorVisible || this._rectangleRenderer.value.renderCursor()) } _updateCursorBlink() { this._terminal.options.cursorBlink ? this._cursorBlinkStateManager.value = new _.CursorBlinkStateManager(() => { this._requestRedrawCursor() }, this._coreBrowserService) : this._cursorBlinkStateManager.clear(), this._requestRedrawCursor() } _updateModel(R, D) { const M = this._core; let k, b, E, x, A, B, F, H, W, N, y, T, I, O = this._workCell; R = C(R, M.rows - 1, 0), D = C(D, M.rows - 1, 0); const z = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY, $ = Math.min(this._terminal.buffer.active.cursorX, M.cols - 1); let V = -1; const ee = this._coreService.isCursorInitialized && !this._coreService.isCursorHidden && (!this._cursorBlinkStateManager.value || this._cursorBlinkStateManager.value.isCursorVisible); this._model.cursor = void 0; let te = !1; for (b = R; b <= D; b++)for (E = b + M.buffer.ydisp, x = M.buffer.lines.get(E), this._model.lineLengths[b] = 0, A = this._characterJoinerService.getJoinedCharacters(E), T = 0; T < M.cols; T++)if (k = this._cellColorResolver.result.bg, x.loadCell(T, O), T === 0 && (k = this._cellColorResolver.result.bg), B = !1, F = T, A.length > 0 && T === A[0][0] && (B = !0, H = A.shift(), O = new m(O, x.translateToString(!0, H[0], H[1]), H[1] - H[0]), F = H[1] - 1), W = O.getChars(), N = O.getCode(), y = (b * M.cols + T) * a.RENDER_MODEL_INDICIES_PER_CELL, this._cellColorResolver.resolve(O, T, E), ee && E === z && (T === $ && (this._model.cursor = { x: $, y: this._terminal.buffer.active.cursorY, width: O.getWidth(), style: this._coreBrowserService.isFocused ? M.options.cursorStyle || "block" : M.options.cursorInactiveStyle, cursorWidth: M.options.cursorWidth, dpr: this._devicePixelRatio }, V = $ + O.getWidth() - 1), T >= $ && T <= V && (this._coreBrowserService.isFocused && (M.options.cursorStyle || "block") === "block" || this._coreBrowserService.isFocused === !1 && M.options.cursorInactiveStyle === "block") && (this._cellColorResolver.result.fg = 50331648 | this._themeService.colors.cursorAccent.rgba >> 8 & 16777215, this._cellColorResolver.result.bg = 50331648 | this._themeService.colors.cursor.rgba >> 8 & 16777215)), N !== d.NULL_CELL_CODE && (this._model.lineLengths[b] = T + 1), (this._model.cells[y] !== N || this._model.cells[y + a.RENDER_MODEL_BG_OFFSET] !== this._cellColorResolver.result.bg || this._model.cells[y + a.RENDER_MODEL_FG_OFFSET] !== this._cellColorResolver.result.fg || this._model.cells[y + a.RENDER_MODEL_EXT_OFFSET] !== this._cellColorResolver.result.ext) && (te = !0, W.length > 1 && (N |= a.COMBINED_CHAR_BIT_MASK), this._model.cells[y] = N, this._model.cells[y + a.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[y + a.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[y + a.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext, this._glyphRenderer.value.updateCell(T, b, N, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext, W, k), B)) for (O = this._workCell, T++; T < F; T++)I = (b * M.cols + T) * a.RENDER_MODEL_INDICIES_PER_CELL, this._glyphRenderer.value.updateCell(T, b, d.NULL_CELL_CODE, 0, 0, 0, d.NULL_CELL_CHAR, 0), this._model.cells[I] = d.NULL_CELL_CODE, this._model.cells[I + a.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[I + a.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[I + a.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext; te && this._rectangleRenderer.value.updateBackgrounds(this._model), this._rectangleRenderer.value.updateCursor(this._model) } _updateDimensions() { this._charSizeService.width && this._charSizeService.height && (this.dimensions.device.char.width = Math.floor(this._charSizeService.width * this._devicePixelRatio), this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * this._devicePixelRatio), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.top = this._optionsService.rawOptions.lineHeight === 1 ? 0 : Math.round((this.dimensions.device.cell.height - this.dimensions.device.char.height) / 2), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.char.left = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.device.canvas.height = this._terminal.rows * this.dimensions.device.cell.height, this.dimensions.device.canvas.width = this._terminal.cols * this.dimensions.device.cell.width, this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / this._devicePixelRatio), this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / this._devicePixelRatio), this.dimensions.css.cell.height = this.dimensions.device.cell.height / this._devicePixelRatio, this.dimensions.css.cell.width = this.dimensions.device.cell.width / this._devicePixelRatio) } _setCanvasDevicePixelDimensions(R, D) { this._canvas.width === R && this._canvas.height === D || (this._canvas.width = R, this._canvas.height = D, this._requestRedrawViewport()) } _requestRedrawViewport() { this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 }) } _requestRedrawCursor() { const R = this._terminal.buffer.active.cursorY; this._onRequestRedraw.fire({ start: R, end: R }) } } t.WebglRenderer = w, c([u.traceCall], w.prototype, "renderRows", null); class m extends i.AttributeData { constructor(R, D, M) { super(), this.content = 0, this.combinedData = "", this.fg = R.fg, this.bg = R.bg, this.combinedData = D, this._width = M } isCombined() { return 2097152 } getWidth() { return this._width } getChars() { return this.combinedData } getCode() { return 2097151 } setFromCharData(R) { throw new Error("not implemented") } getAsCharData() { return [this.fg, this.getChars(), this.getWidth(), this.getCode()] } } function C(L, R, D = 0) { return Math.max(Math.min(L, R), D) } t.JoinedCellData = m }, 381: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.GLTexture = t.expandFloat32Array = t.createShader = t.createProgram = t.PROJECTION_MATRIX = void 0; const c = h(374); function f(n, l, _) { const v = (0, c.throwIfFalsy)(n.createShader(l)); if (n.shaderSource(v, _), n.compileShader(v), n.getShaderParameter(v, n.COMPILE_STATUS)) return v; console.error(n.getShaderInfoLog(v)), n.deleteShader(v) } t.PROJECTION_MATRIX = new Float32Array([2, 0, 0, 0, 0, -2, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]), t.createProgram = function (n, l, _) { const v = (0, c.throwIfFalsy)(n.createProgram()); if (n.attachShader(v, (0, c.throwIfFalsy)(f(n, n.VERTEX_SHADER, l))), n.attachShader(v, (0, c.throwIfFalsy)(f(n, n.FRAGMENT_SHADER, _))), n.linkProgram(v), n.getProgramParameter(v, n.LINK_STATUS)) return v; console.error(n.getProgramInfoLog(v)), n.deleteProgram(v) }, t.createShader = f, t.expandFloat32Array = function (n, l) { const _ = Math.min(2 * n.length, l), v = new Float32Array(_); for (let o = 0; o < n.length; o++)v[o] = n[o]; return v }, t.GLTexture = class { constructor(n) { this.texture = n, this.version = -1 } } }, 592: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseRenderLayer = void 0; const c = h(627), f = h(237), n = h(374), l = h(859); class _ extends l.Disposable { constructor(o, e, s, i, r, d, u, p) { super(), this._container = e, this._alpha = r, this._coreBrowserService = d, this._optionsService = u, this._themeService = p, this._deviceCharWidth = 0, this._deviceCharHeight = 0, this._deviceCellWidth = 0, this._deviceCellHeight = 0, this._deviceCharLeft = 0, this._deviceCharTop = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add(`xterm-${s}-layer`), this._canvas.style.zIndex = i.toString(), this._initCanvas(), this._container.appendChild(this._canvas), this.register(this._themeService.onChangeColors(S => { this._refreshCharAtlas(o, S), this.reset(o) })), this.register((0, l.toDisposable)(() => { this._canvas.remove() })) } _initCanvas() { this._ctx = (0, n.throwIfFalsy)(this._canvas.getContext("2d", { alpha: this._alpha })), this._alpha || this._clearAll() } handleBlur(o) { } handleFocus(o) { } handleCursorMove(o) { } handleGridChanged(o, e, s) { } handleSelectionChanged(o, e, s, i = !1) { } _setTransparency(o, e) { if (e === this._alpha) return; const s = this._canvas; this._alpha = e, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, s), this._refreshCharAtlas(o, this._themeService.colors), this.handleGridChanged(o, 0, o.rows - 1) } _refreshCharAtlas(o, e) { this._deviceCharWidth <= 0 && this._deviceCharHeight <= 0 || (this._charAtlas = (0, c.acquireTextureAtlas)(o, this._optionsService.rawOptions, e, this._deviceCellWidth, this._deviceCellHeight, this._deviceCharWidth, this._deviceCharHeight, this._coreBrowserService.dpr), this._charAtlas.warmUp()) } resize(o, e) { this._deviceCellWidth = e.device.cell.width, this._deviceCellHeight = e.device.cell.height, this._deviceCharWidth = e.device.char.width, this._deviceCharHeight = e.device.char.height, this._deviceCharLeft = e.device.char.left, this._deviceCharTop = e.device.char.top, this._canvas.width = e.device.canvas.width, this._canvas.height = e.device.canvas.height, this._canvas.style.width = `${e.css.canvas.width}px`, this._canvas.style.height = `${e.css.canvas.height}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(o, this._themeService.colors) } _fillBottomLineAtCells(o, e, s = 1) { this._ctx.fillRect(o * this._deviceCellWidth, (e + 1) * this._deviceCellHeight - this._coreBrowserService.dpr - 1, s * this._deviceCellWidth, this._coreBrowserService.dpr) } _clearAll() { this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height)) } _clearCells(o, e, s, i) { this._alpha ? this._ctx.clearRect(o * this._deviceCellWidth, e * this._deviceCellHeight, s * this._deviceCellWidth, i * this._deviceCellHeight) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(o * this._deviceCellWidth, e * this._deviceCellHeight, s * this._deviceCellWidth, i * this._deviceCellHeight)) } _fillCharTrueColor(o, e, s, i) { this._ctx.font = this._getFont(o, !1, !1), this._ctx.textBaseline = f.TEXT_BASELINE, this._clipCell(s, i, e.getWidth()), this._ctx.fillText(e.getChars(), s * this._deviceCellWidth + this._deviceCharLeft, i * this._deviceCellHeight + this._deviceCharTop + this._deviceCharHeight) } _clipCell(o, e, s) { this._ctx.beginPath(), this._ctx.rect(o * this._deviceCellWidth, e * this._deviceCellHeight, s * this._deviceCellWidth, this._deviceCellHeight), this._ctx.clip() } _getFont(o, e, s) { return `${s ? "italic" : ""} ${e ? o.options.fontWeightBold : o.options.fontWeight} ${o.options.fontSize * this._coreBrowserService.dpr}px ${o.options.fontFamily}` } } t.BaseRenderLayer = _ }, 733: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.LinkRenderLayer = void 0; const c = h(197), f = h(237), n = h(592); class l extends n.BaseRenderLayer { constructor(v, o, e, s, i, r, d) { super(e, v, "link", o, !0, i, r, d), this.register(s.onShowLinkUnderline(u => this._handleShowLinkUnderline(u))), this.register(s.onHideLinkUnderline(u => this._handleHideLinkUnderline(u))) } resize(v, o) { super.resize(v, o), this._state = void 0 } reset(v) { this._clearCurrentLink() } _clearCurrentLink() { if (this._state) { this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1); const v = this._state.y2 - this._state.y1 - 1; v > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, v), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = void 0 } } _handleShowLinkUnderline(v) { if (v.fg === f.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._themeService.colors.background.css : v.fg !== void 0 && (0, c.is256Color)(v.fg) ? this._ctx.fillStyle = this._themeService.colors.ansi[v.fg].css : this._ctx.fillStyle = this._themeService.colors.foreground.css, v.y1 === v.y2) this._fillBottomLineAtCells(v.x1, v.y1, v.x2 - v.x1); else { this._fillBottomLineAtCells(v.x1, v.y1, v.cols - v.x1); for (let o = v.y1 + 1; o < v.y2; o++)this._fillBottomLineAtCells(0, o, v.cols); this._fillBottomLineAtCells(0, v.y2, v.x2) } this._state = v } _handleHideLinkUnderline(v) { this._clearCurrentLink() } } t.LinkRenderLayer = l }, 820: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.addDisposableDomListener = void 0, t.addDisposableDomListener = function (h, c, f, n) { h.addEventListener(c, f, n); let l = !1; return { dispose: () => { l || (l = !0, h.removeEventListener(c, f, n)) } } } }, 274: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CellColorResolver = void 0; let h, c = 0, f = 0, n = !1, l = !1, _ = !1; t.CellColorResolver = class { constructor(v, o, e, s, i) { this._terminal = v, this._selectionRenderModel = o, this._decorationService = e, this._coreBrowserService = s, this._themeService = i, this.result = { fg: 0, bg: 0, ext: 0 } } resolve(v, o, e) { this.result.bg = v.bg, this.result.fg = v.fg, this.result.ext = 268435456 & v.bg ? v.extended.ext : 0, f = 0, c = 0, l = !1, n = !1, _ = !1, h = this._themeService.colors, this._decorationService.forEachDecorationAtCell(o, e, "bottom", s => { s.backgroundColorRGB && (f = s.backgroundColorRGB.rgba >> 8 & 16777215, l = !0), s.foregroundColorRGB && (c = s.foregroundColorRGB.rgba >> 8 & 16777215, n = !0) }), _ = this._selectionRenderModel.isCellSelected(this._terminal, o, e), _ && (f = (this._coreBrowserService.isFocused ? h.selectionBackgroundOpaque : h.selectionInactiveBackgroundOpaque).rgba >> 8 & 16777215, l = !0, h.selectionForeground && (c = h.selectionForeground.rgba >> 8 & 16777215, n = !0)), this._decorationService.forEachDecorationAtCell(o, e, "top", s => { s.backgroundColorRGB && (f = s.backgroundColorRGB.rgba >> 8 & 16777215, l = !0), s.foregroundColorRGB && (c = s.foregroundColorRGB.rgba >> 8 & 16777215, n = !0) }), l && (f = _ ? -16777216 & v.bg & -134217729 | f | 50331648 : -16777216 & v.bg | f | 50331648), n && (c = -16777216 & v.fg & -67108865 | c | 50331648), 67108864 & this.result.fg && (l && !n && (c = 50331648 & this.result.bg ? -134217728 & this.result.fg | 67108863 & this.result.bg : -134217728 & this.result.fg | 16777215 & h.background.rgba >> 8 | 50331648, n = !0), !l && n && (f = 50331648 & this.result.fg ? -67108864 & this.result.bg | 67108863 & this.result.fg : -67108864 & this.result.bg | 16777215 & h.foreground.rgba >> 8 | 50331648, l = !0)), h = void 0, this.result.bg = l ? f : this.result.bg, this.result.fg = n ? c : this.result.fg } } }, 627: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.removeTerminalFromCache = t.acquireTextureAtlas = void 0; const c = h(509), f = h(197), n = []; t.acquireTextureAtlas = function (l, _, v, o, e, s, i, r) { const d = (0, f.generateConfig)(o, e, s, i, _, v, r); for (let S = 0; S < n.length; S++) { const a = n[S], g = a.ownedBy.indexOf(l); if (g >= 0) { if ((0, f.configEquals)(a.config, d)) return a.atlas; a.ownedBy.length === 1 ? (a.atlas.dispose(), n.splice(S, 1)) : a.ownedBy.splice(g, 1); break } } for (let S = 0; S < n.length; S++) { const a = n[S]; if ((0, f.configEquals)(a.config, d)) return a.ownedBy.push(l), a.atlas } const u = l._core, p = { atlas: new c.TextureAtlas(document, d, u.unicodeService), config: d, ownedBy: [l] }; return n.push(p), p.atlas }, t.removeTerminalFromCache = function (l) { for (let _ = 0; _ < n.length; _++) { const v = n[_].ownedBy.indexOf(l); if (v !== -1) { n[_].ownedBy.length === 1 ? (n[_].atlas.dispose(), n.splice(_, 1)) : n[_].ownedBy.splice(v, 1); break } } } }, 197: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.is256Color = t.configEquals = t.generateConfig = void 0; const c = h(160); t.generateConfig = function (f, n, l, _, v, o, e) { const s = { foreground: o.foreground, background: o.background, cursor: c.NULL_COLOR, cursorAccent: c.NULL_COLOR, selectionForeground: c.NULL_COLOR, selectionBackgroundTransparent: c.NULL_COLOR, selectionBackgroundOpaque: c.NULL_COLOR, selectionInactiveBackgroundTransparent: c.NULL_COLOR, selectionInactiveBackgroundOpaque: c.NULL_COLOR, ansi: o.ansi.slice(), contrastCache: o.contrastCache, halfContrastCache: o.halfContrastCache }; return { customGlyphs: v.customGlyphs, devicePixelRatio: e, letterSpacing: v.letterSpacing, lineHeight: v.lineHeight, deviceCellWidth: f, deviceCellHeight: n, deviceCharWidth: l, deviceCharHeight: _, fontFamily: v.fontFamily, fontSize: v.fontSize, fontWeight: v.fontWeight, fontWeightBold: v.fontWeightBold, allowTransparency: v.allowTransparency, drawBoldTextInBrightColors: v.drawBoldTextInBrightColors, minimumContrastRatio: v.minimumContrastRatio, colors: s } }, t.configEquals = function (f, n) { for (let l = 0; l < f.colors.ansi.length; l++)if (f.colors.ansi[l].rgba !== n.colors.ansi[l].rgba) return !1; return f.devicePixelRatio === n.devicePixelRatio && f.customGlyphs === n.customGlyphs && f.lineHeight === n.lineHeight && f.letterSpacing === n.letterSpacing && f.fontFamily === n.fontFamily && f.fontSize === n.fontSize && f.fontWeight === n.fontWeight && f.fontWeightBold === n.fontWeightBold && f.allowTransparency === n.allowTransparency && f.deviceCharWidth === n.deviceCharWidth && f.deviceCharHeight === n.deviceCharHeight && f.drawBoldTextInBrightColors === n.drawBoldTextInBrightColors && f.minimumContrastRatio === n.minimumContrastRatio && f.colors.foreground.rgba === n.colors.foreground.rgba && f.colors.background.rgba === n.colors.background.rgba }, t.is256Color = function (f) { return (50331648 & f) == 16777216 || (50331648 & f) == 33554432 } }, 237: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0; const c = h(399); t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = c.isFirefox || c.isLegacyEdge ? "bottom" : "ideographic" }, 457: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CursorBlinkStateManager = void 0, t.CursorBlinkStateManager = class { constructor(h, c) { this._renderCallback = h, this._coreBrowserService = c, this.isCursorVisible = !0, this._coreBrowserService.isFocused && this._restartInterval() } get isPaused() { return !(this._blinkStartTimeout || this._blinkInterval) } dispose() { this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0) } restartBlinkAnimation() { this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = !0, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => { this._renderCallback(), this._animationFrame = void 0 }))) } _restartInterval(h = 600) { this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(() => { if (this._animationTimeRestarted) { const c = 600 - (Date.now() - this._animationTimeRestarted); if (this._animationTimeRestarted = void 0, c > 0) return void this._restartInterval(c) } this.isCursorVisible = !1, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => { this._renderCallback(), this._animationFrame = void 0 }), this._blinkInterval = this._coreBrowserService.window.setInterval(() => { if (this._animationTimeRestarted) { const c = 600 - (Date.now() - this._animationTimeRestarted); return this._animationTimeRestarted = void 0, void this._restartInterval(c) } this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => { this._renderCallback(), this._animationFrame = void 0 }) }, 600) }, h) } pause() { this.isCursorVisible = !0, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0) } resume() { this.pause(), this._animationTimeRestarted = void 0, this._restartInterval(), this.restartBlinkAnimation() } } }, 860: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.tryDrawCustomChar = t.powerlineDefinitions = t.boxDrawingDefinitions = t.blockElementDefinitions = void 0; const c = h(374); t.blockElementDefinitions = { "â": [{ x: 0, y: 0, w: 8, h: 4 }], "â": [{ x: 0, y: 7, w: 8, h: 1 }], "â": [{ x: 0, y: 6, w: 8, h: 2 }], "â": [{ x: 0, y: 5, w: 8, h: 3 }], "â": [{ x: 0, y: 4, w: 8, h: 4 }], "â": [{ x: 0, y: 3, w: 8, h: 5 }], "â": [{ x: 0, y: 2, w: 8, h: 6 }], "â": [{ x: 0, y: 1, w: 8, h: 7 }], "â": [{ x: 0, y: 0, w: 8, h: 8 }], "â": [{ x: 0, y: 0, w: 7, h: 8 }], "â": [{ x: 0, y: 0, w: 6, h: 8 }], "â": [{ x: 0, y: 0, w: 5, h: 8 }], "â": [{ x: 0, y: 0, w: 4, h: 8 }], "â": [{ x: 0, y: 0, w: 3, h: 8 }], "â": [{ x: 0, y: 0, w: 2, h: 8 }], "â": [{ x: 0, y: 0, w: 1, h: 8 }], "â": [{ x: 4, y: 0, w: 4, h: 8 }], "â": [{ x: 0, y: 0, w: 8, h: 1 }], "â": [{ x: 7, y: 0, w: 1, h: 8 }], "â": [{ x: 0, y: 4, w: 4, h: 4 }], "â": [{ x: 4, y: 4, w: 4, h: 4 }], "â": [{ x: 0, y: 0, w: 4, h: 4 }], "â": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "â": [{ x: 0, y: 0, w: 4, h: 4 }, { x: 4, y: 4, w: 4, h: 4 }], "â": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 4, y: 0, w: 4, h: 4 }], "â": [{ x: 0, y: 0, w: 8, h: 4 }, { x: 4, y: 0, w: 4, h: 8 }], "â": [{ x: 4, y: 0, w: 4, h: 4 }], "â": [{ x: 4, y: 0, w: 4, h: 4 }, { x: 0, y: 4, w: 4, h: 4 }], "â": [{ x: 4, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "ð­°": [{ x: 1, y: 0, w: 1, h: 8 }], "ð­±": [{ x: 2, y: 0, w: 1, h: 8 }], "ð­²": [{ x: 3, y: 0, w: 1, h: 8 }], "ð­³": [{ x: 4, y: 0, w: 1, h: 8 }], "ð­´": [{ x: 5, y: 0, w: 1, h: 8 }], "ð­µ": [{ x: 6, y: 0, w: 1, h: 8 }], "ð­¶": [{ x: 0, y: 1, w: 8, h: 1 }], "ð­·": [{ x: 0, y: 2, w: 8, h: 1 }], "ð­¸": [{ x: 0, y: 3, w: 8, h: 1 }], "ð­¹": [{ x: 0, y: 4, w: 8, h: 1 }], "ð­º": [{ x: 0, y: 5, w: 8, h: 1 }], "ð­»": [{ x: 0, y: 6, w: 8, h: 1 }], "ð­¼": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "ð­½": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "ð­¾": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "ð­¿": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "ð®": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "ð®": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 2, w: 8, h: 1 }, { x: 0, y: 4, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "ð®": [{ x: 0, y: 0, w: 8, h: 2 }], "ð®": [{ x: 0, y: 0, w: 8, h: 3 }], "ð®": [{ x: 0, y: 0, w: 8, h: 5 }], "ð®": [{ x: 0, y: 0, w: 8, h: 6 }], "ð®": [{ x: 0, y: 0, w: 8, h: 7 }], "ð®": [{ x: 6, y: 0, w: 2, h: 8 }], "ð®": [{ x: 5, y: 0, w: 3, h: 8 }], "ð®": [{ x: 3, y: 0, w: 5, h: 8 }], "ð®": [{ x: 2, y: 0, w: 6, h: 8 }], "ð®": [{ x: 1, y: 0, w: 7, h: 8 }], "ð®": [{ x: 0, y: 0, w: 2, h: 2 }, { x: 4, y: 0, w: 2, h: 2 }, { x: 2, y: 2, w: 2, h: 2 }, { x: 6, y: 2, w: 2, h: 2 }, { x: 0, y: 4, w: 2, h: 2 }, { x: 4, y: 4, w: 2, h: 2 }, { x: 2, y: 6, w: 2, h: 2 }, { x: 6, y: 6, w: 2, h: 2 }], "ð®": [{ x: 2, y: 0, w: 2, h: 2 }, { x: 6, y: 0, w: 2, h: 2 }, { x: 0, y: 2, w: 2, h: 2 }, { x: 4, y: 2, w: 2, h: 2 }, { x: 2, y: 4, w: 2, h: 2 }, { x: 6, y: 4, w: 2, h: 2 }, { x: 0, y: 6, w: 2, h: 2 }, { x: 4, y: 6, w: 2, h: 2 }], "ð®": [{ x: 0, y: 2, w: 8, h: 2 }, { x: 0, y: 6, w: 8, h: 2 }] }; const f = { "â": [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]], "â": [[1, 0], [0, 0], [0, 1], [0, 0]], "â": [[0, 1], [1, 1], [1, 0], [1, 1]] }; t.boxDrawingDefinitions = { "â": { 1: "M0,.5 L1,.5" }, "â": { 3: "M0,.5 L1,.5" }, "â": { 1: "M.5,0 L.5,1" }, "â": { 3: "M.5,0 L.5,1" }, "â": { 1: "M0.5,1 L.5,.5 L1,.5" }, "â": { 3: "M0.5,1 L.5,.5 L1,.5" }, "â": { 1: "M0,.5 L.5,.5 L.5,1" }, "â": { 3: "M0,.5 L.5,.5 L.5,1" }, "â": { 1: "M.5,0 L.5,.5 L1,.5" }, "â": { 3: "M.5,0 L.5,.5 L1,.5" }, "â": { 1: "M.5,0 L.5,.5 L0,.5" }, "â": { 3: "M.5,0 L.5,.5 L0,.5" }, "â": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "â£": { 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "â¤": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "â«": { 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "â¬": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "â³": { 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "â´": { 1: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "â»": { 3: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "â¼": { 1: "M0,.5 L1,.5 M.5,0 L.5,1" }, "â": { 3: "M0,.5 L1,.5 M.5,0 L.5,1" }, "â´": { 1: "M.5,.5 L0,.5" }, "â¸": { 3: "M.5,.5 L0,.5" }, "âµ": { 1: "M.5,.5 L.5,0" }, "â¹": { 3: "M.5,.5 L.5,0" }, "â¶": { 1: "M.5,.5 L1,.5" }, "âº": { 3: "M.5,.5 L1,.5" }, "â·": { 1: "M.5,.5 L.5,1" }, "â»": { 3: "M.5,.5 L.5,1" }, "â": { 1: (o, e) => `M0,${.5 - e} L1,${.5 - e} M0,${.5 + e} L1,${.5 + e}` }, "â": { 1: (o, e) => `M${.5 - o},0 L${.5 - o},1 M${.5 + o},0 L${.5 + o},1` }, "â": { 1: (o, e) => `M.5,1 L.5,${.5 - e} L1,${.5 - e} M.5,${.5 + e} L1,${.5 + e}` }, "â": { 1: (o, e) => `M${.5 - o},1 L${.5 - o},.5 L1,.5 M${.5 + o},.5 L${.5 + o},1` }, "â": { 1: (o, e) => `M1,${.5 - e} L${.5 - o},${.5 - e} L${.5 - o},1 M1,${.5 + e} L${.5 + o},${.5 + e} L${.5 + o},1` }, "â": { 1: (o, e) => `M0,${.5 - e} L.5,${.5 - e} L.5,1 M0,${.5 + e} L.5,${.5 + e}` }, "â": { 1: (o, e) => `M${.5 + o},1 L${.5 + o},.5 L0,.5 M${.5 - o},.5 L${.5 - o},1` }, "â": { 1: (o, e) => `M0,${.5 + e} L${.5 - o},${.5 + e} L${.5 - o},1 M0,${.5 - e} L${.5 + o},${.5 - e} L${.5 + o},1` }, "â": { 1: (o, e) => `M.5,0 L.5,${.5 + e} L1,${.5 + e} M.5,${.5 - e} L1,${.5 - e}` }, "â": { 1: (o, e) => `M1,.5 L${.5 - o},.5 L${.5 - o},0 M${.5 + o},.5 L${.5 + o},0` }, "â": { 1: (o, e) => `M1,${.5 - e} L${.5 + o},${.5 - e} L${.5 + o},0 M1,${.5 + e} L${.5 - o},${.5 + e} L${.5 - o},0` }, "â": { 1: (o, e) => `M0,${.5 + e} L.5,${.5 + e} L.5,0 M0,${.5 - e} L.5,${.5 - e}` }, "â": { 1: (o, e) => `M0,.5 L${.5 + o},.5 L${.5 + o},0 M${.5 - o},.5 L${.5 - o},0` }, "â": { 1: (o, e) => `M0,${.5 - e} L${.5 - o},${.5 - e} L${.5 - o},0 M0,${.5 + e} L${.5 + o},${.5 + e} L${.5 + o},0` }, "â": { 1: (o, e) => `M.5,0 L.5,1 M.5,${.5 - e} L1,${.5 - e} M.5,${.5 + e} L1,${.5 + e}` }, "â": { 1: (o, e) => `M${.5 - o},0 L${.5 - o},1 M${.5 + o},0 L${.5 + o},1 M${.5 + o},.5 L1,.5` }, "â ": { 1: (o, e) => `M${.5 - o},0 L${.5 - o},1 M1,${.5 + e} L${.5 + o},${.5 + e} L${.5 + o},1 M1,${.5 - e} L${.5 + o},${.5 - e} L${.5 + o},0` }, "â¡": { 1: (o, e) => `M.5,0 L.5,1 M0,${.5 - e} L.5,${.5 - e} M0,${.5 + e} L.5,${.5 + e}` }, "â¢": { 1: (o, e) => `M0,.5 L${.5 - o},.5 M${.5 - o},0 L${.5 - o},1 M${.5 + o},0 L${.5 + o},1` }, "â£": { 1: (o, e) => `M${.5 + o},0 L${.5 + o},1 M0,${.5 + e} L${.5 - o},${.5 + e} L${.5 - o},1 M0,${.5 - e} L${.5 - o},${.5 - e} L${.5 - o},0` }, "â¤": { 1: (o, e) => `M0,${.5 - e} L1,${.5 - e} M0,${.5 + e} L1,${.5 + e} M.5,${.5 + e} L.5,1` }, "â¥": { 1: (o, e) => `M0,.5 L1,.5 M${.5 - o},.5 L${.5 - o},1 M${.5 + o},.5 L${.5 + o},1` }, "â¦": { 1: (o, e) => `M0,${.5 - e} L1,${.5 - e} M0,${.5 + e} L${.5 - o},${.5 + e} L${.5 - o},1 M1,${.5 + e} L${.5 + o},${.5 + e} L${.5 + o},1` }, "â§": { 1: (o, e) => `M.5,0 L.5,${.5 - e} M0,${.5 - e} L1,${.5 - e} M0,${.5 + e} L1,${.5 + e}` }, "â¨": { 1: (o, e) => `M0,.5 L1,.5 M${.5 - o},.5 L${.5 - o},0 M${.5 + o},.5 L${.5 + o},0` }, "â©": { 1: (o, e) => `M0,${.5 + e} L1,${.5 + e} M0,${.5 - e} L${.5 - o},${.5 - e} L${.5 - o},0 M1,${.5 - e} L${.5 + o},${.5 - e} L${.5 + o},0` }, "âª": { 1: (o, e) => `M.5,0 L.5,1 M0,${.5 - e} L1,${.5 - e} M0,${.5 + e} L1,${.5 + e}` }, "â«": { 1: (o, e) => `M0,.5 L1,.5 M${.5 - o},0 L${.5 - o},1 M${.5 + o},0 L${.5 + o},1` }, "â¬": { 1: (o, e) => `M0,${.5 + e} L${.5 - o},${.5 + e} L${.5 - o},1 M1,${.5 + e} L${.5 + o},${.5 + e} L${.5 + o},1 M0,${.5 - e} L${.5 - o},${.5 - e} L${.5 - o},0 M1,${.5 - e} L${.5 + o},${.5 - e} L${.5 + o},0` }, "â±": { 1: "M1,0 L0,1" }, "â²": { 1: "M0,0 L1,1" }, "â³": { 1: "M1,0 L0,1 M0,0 L1,1" }, "â¼": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "â½": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L.5,1" }, "â¾": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "â¿": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "â": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "â": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "â": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L0,.5" }, "â": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "â": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L1,.5" }, "â": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "â": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L0,.5" }, "â": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,0" }, "â": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L1,.5" }, "â": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "â": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "â ": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1" }, "â¡": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "â¢": { 1: "M.5,.5 L.5,0", 3: "M0.5,1 L.5,.5 L1,.5" }, "â¥": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L0,.5" }, "â¦": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "â§": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "â¨": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1" }, "â©": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L0,.5" }, "âª": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L.5,.5 L.5,1" }, "â­": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "â®": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "â¯": { 1: "M.5,.5 L.5,1", 3: "M0,.5 L1,.5" }, "â°": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "â±": { 1: "M.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "â²": { 1: "M.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "âµ": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "â¶": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "â·": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5" }, "â¸": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "â¹": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "âº": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,.5 L1,.5" }, "â½": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "â¾": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "â¿": { 1: "M.5,0 L.5,1", 3: "M0,.5 L1,.5" }, "â": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "â": { 1: "M.5,.5 L.5,0 M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "â": { 1: "M0,.5 L1,.5", 3: "M.5,0 L.5,1" }, "â": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "â": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "â": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "â": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "â": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0 M0,.5 L1,.5" }, "â": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "â": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "â": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "â": { 1: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "â": { 3: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "â": { 1: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "â": { 3: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "â": { 1: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "â": { 3: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "â": { 1: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "â": { 3: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "â": { 1: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "â": { 3: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "â": { 1: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "â": { 3: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "â­": { 1: (o, e) => `M.5,1 L.5,${.5 + e / .15 * .5} C.5,${.5 + e / .15 * .5},.5,.5,1,.5` }, "â®": { 1: (o, e) => `M.5,1 L.5,${.5 + e / .15 * .5} C.5,${.5 + e / .15 * .5},.5,.5,0,.5` }, "â¯": { 1: (o, e) => `M.5,0 L.5,${.5 - e / .15 * .5} C.5,${.5 - e / .15 * .5},.5,.5,0,.5` }, "â°": { 1: (o, e) => `M.5,0 L.5,${.5 - e / .15 * .5} C.5,${.5 - e / .15 * .5},.5,.5,1,.5` } }, t.powerlineDefinitions = { "î°": { d: "M0,0 L1,.5 L0,1", type: 0, rightPadding: 2 }, "î±": { d: "M-1,-.5 L1,.5 L-1,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "î²": { d: "M1,0 L0,.5 L1,1", type: 0, leftPadding: 2 }, "î³": { d: "M2,-.5 L0,.5 L2,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "î´": { d: "M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0", type: 0, rightPadding: 1 }, "îµ": { d: "M.2,1 C.422,1,.8,.826,.78,.5 C.8,.174,0.422,0,.2,0", type: 1, rightPadding: 1 }, "î¶": { d: "M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0", type: 0, leftPadding: 1 }, "î·": { d: "M.8,1 C0.578,1,0.2,.826,.22,.5 C0.2,0.174,0.578,0,0.8,0", type: 1, leftPadding: 1 }, "î¸": { d: "M-.5,-.5 L1.5,1.5 L-.5,1.5", type: 0 }, "î¹": { d: "M-.5,-.5 L1.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "îº": { d: "M1.5,-.5 L-.5,1.5 L1.5,1.5", type: 0 }, "î¼": { d: "M1.5,-.5 L-.5,1.5 L-.5,-.5", type: 0 }, "î½": { d: "M1.5,-.5 L-.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "î¾": { d: "M-.5,-.5 L1.5,1.5 L1.5,-.5", type: 0 } }, t.powerlineDefinitions["î»"] = t.powerlineDefinitions["î½"], t.powerlineDefinitions["î¿"] = t.powerlineDefinitions["î¹"], t.tryDrawCustomChar = function (o, e, s, i, r, d, u, p) { const S = t.blockElementDefinitions[e]; if (S) return function (m, C, L, R, D, M) { for (let k = 0; k < C.length; k++) { const b = C[k], E = D / 8, x = M / 8; m.fillRect(L + b.x * E, R + b.y * x, b.w * E, b.h * x) } }(o, S, s, i, r, d), !0; const a = f[e]; if (a) return function (m, C, L, R, D, M) { let k = n.get(C); k || (k = new Map, n.set(C, k)); const b = m.fillStyle; if (typeof b != "string") throw new Error(`Unexpected fillStyle type "${b}"`); let E = k.get(b); if (!E) { const x = C[0].length, A = C.length, B = document.createElement("canvas"); B.width = x, B.height = A; const F = (0, c.throwIfFalsy)(B.getContext("2d")), H = new ImageData(x, A); let W, N, y, T; if (b.startsWith("#")) W = parseInt(b.slice(1, 3), 16), N = parseInt(b.slice(3, 5), 16), y = parseInt(b.slice(5, 7), 16), T = b.length > 7 && parseInt(b.slice(7, 9), 16) || 1; else { if (!b.startsWith("rgba")) throw new Error(`Unexpected fillStyle color format "${b}" when drawing pattern glyph`);[W, N, y, T] = b.substring(5, b.length - 1).split(",").map(I => parseFloat(I)) } for (let I = 0; I < A; I++)for (let O = 0; O < x; O++)H.data[4 * (I * x + O)] = W, H.data[4 * (I * x + O) + 1] = N, H.data[4 * (I * x + O) + 2] = y, H.data[4 * (I * x + O) + 3] = C[I][O] * (255 * T); F.putImageData(H, 0, 0), E = (0, c.throwIfFalsy)(m.createPattern(B, null)), k.set(b, E) } m.fillStyle = E, m.fillRect(L, R, D, M) }(o, a, s, i, r, d), !0; const g = t.boxDrawingDefinitions[e]; if (g) return function (m, C, L, R, D, M, k) { m.strokeStyle = m.fillStyle; for (const [b, E] of Object.entries(C)) { let x; m.beginPath(), m.lineWidth = k * Number.parseInt(b), x = typeof E == "function" ? E(.15, .15 / M * D) : E; for (const A of x.split(" ")) { const B = A[0], F = _[B]; if (!F) { console.error(`Could not find drawing instructions for "${B}"`); continue } const H = A.substring(1).split(","); H[0] && H[1] && F(m, v(H, D, M, L, R, !0, k)) } m.stroke(), m.closePath() } }(o, g, s, i, r, d, p), !0; const w = t.powerlineDefinitions[e]; return !!w && (function (m, C, L, R, D, M, k, b) { var E, x; const A = new Path2D; A.rect(L, R, D, M), m.clip(A), m.beginPath(); const B = k / 12; m.lineWidth = b * B; for (const F of C.d.split(" ")) { const H = F[0], W = _[H]; if (!W) { console.error(`Could not find drawing instructions for "${H}"`); continue } const N = F.substring(1).split(","); N[0] && N[1] && W(m, v(N, D, M, L, R, !1, b, ((E = C.leftPadding) !== null && E !== void 0 ? E : 0) * (B / 2), ((x = C.rightPadding) !== null && x !== void 0 ? x : 0) * (B / 2))) } C.type === 1 ? (m.strokeStyle = m.fillStyle, m.stroke()) : m.fill(), m.closePath() }(o, w, s, i, r, d, u, p), !0) }; const n = new Map; function l(o, e, s = 0) { return Math.max(Math.min(o, e), s) } const _ = { C: (o, e) => o.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5]), L: (o, e) => o.lineTo(e[0], e[1]), M: (o, e) => o.moveTo(e[0], e[1]) }; function v(o, e, s, i, r, d, u, p = 0, S = 0) { const a = o.map(g => parseFloat(g) || parseInt(g)); if (a.length < 2) throw new Error("Too few arguments for instruction"); for (let g = 0; g < a.length; g += 2)a[g] *= e - p * u - S * u, d && a[g] !== 0 && (a[g] = l(Math.round(a[g] + .5) - .5, e, 0)), a[g] += i + p * u; for (let g = 1; g < a.length; g += 2)a[g] *= s, d && a[g] !== 0 && (a[g] = l(Math.round(a[g] + .5) - .5, s, 0)), a[g] += r; return a } }, 56: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.observeDevicePixelDimensions = void 0; const c = h(859); t.observeDevicePixelDimensions = function (f, n, l) { let _ = new n.ResizeObserver(v => { const o = v.find(i => i.target === f); if (!o) return; if (!("devicePixelContentBoxSize" in o)) return _?.disconnect(), void (_ = void 0); const e = o.devicePixelContentBoxSize[0].inlineSize, s = o.devicePixelContentBoxSize[0].blockSize; e > 0 && s > 0 && l(e, s) }); try { _.observe(f, { box: ["device-pixel-content-box"] }) } catch { _.disconnect(), _ = void 0 } return (0, c.toDisposable)(() => _?.disconnect()) } }, 374: (P, t) => { function h(c) { return 57508 <= c && c <= 57558 } Object.defineProperty(t, "__esModule", { value: !0 }), t.createRenderDimensions = t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function (c) { if (!c) throw new Error("value must not be falsy"); return c }, t.isPowerlineGlyph = h, t.isRestrictedPowerlineGlyph = function (c) { return 57520 <= c && c <= 57527 }, t.excludeFromContrastRatioDemands = function (c) { return h(c) || function (f) { return 9472 <= f && f <= 9631 }(c) }, t.createRenderDimensions = function () { return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } } } }, 296: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.createSelectionRenderModel = void 0; class h { constructor() { this.clear() } clear() { this.hasSelection = !1, this.columnSelectMode = !1, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0 } update(f, n, l, _ = !1) { if (this.selectionStart = n, this.selectionEnd = l, !n || !l || n[0] === l[0] && n[1] === l[1]) return void this.clear(); const v = n[1] - f.buffer.active.viewportY, o = l[1] - f.buffer.active.viewportY, e = Math.max(v, 0), s = Math.min(o, f.rows - 1); e >= f.rows || s < 0 ? this.clear() : (this.hasSelection = !0, this.columnSelectMode = _, this.viewportStartRow = v, this.viewportEndRow = o, this.viewportCappedStartRow = e, this.viewportCappedEndRow = s, this.startCol = n[0], this.endCol = l[0]) } isCellSelected(f, n, l) { return !!this.hasSelection && (l -= f.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? n >= this.startCol && l >= this.viewportCappedStartRow && n < this.endCol && l <= this.viewportCappedEndRow : n < this.startCol && l >= this.viewportCappedStartRow && n >= this.endCol && l <= this.viewportCappedEndRow : l > this.viewportStartRow && l < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && l === this.viewportStartRow && n >= this.startCol && n < this.endCol || this.viewportStartRow < this.viewportEndRow && l === this.viewportEndRow && n < this.endCol || this.viewportStartRow < this.viewportEndRow && l === this.viewportStartRow && n >= this.startCol) } } t.createSelectionRenderModel = function () { return new h } }, 509: function (P, t, h) { var c = this && this.__decorate || function (w, m, C, L) { var R, D = arguments.length, M = D < 3 ? m : L === null ? L = Object.getOwnPropertyDescriptor(m, C) : L; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") M = Reflect.decorate(w, m, C, L); else for (var k = w.length - 1; k >= 0; k--)(R = w[k]) && (M = (D < 3 ? R(M) : D > 3 ? R(m, C, M) : R(m, C)) || M); return D > 3 && M && Object.defineProperty(m, C, M), M }; Object.defineProperty(t, "__esModule", { value: !0 }), t.TextureAtlas = void 0; const f = h(237), n = h(860), l = h(374), _ = h(160), v = h(345), o = h(485), e = h(385), s = h(147), i = h(855), r = h(776), d = { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, size: { x: 0, y: 0 }, sizeClipSpace: { x: 0, y: 0 } }; let u; class p { get pages() { return this._pages } constructor(m, C, L) { this._document = m, this._config = C, this._unicodeService = L, this._didWarmUp = !1, this._cacheMap = new o.FourKeyMap, this._cacheMapCombined = new o.FourKeyMap, this._pages = [], this._activePages = [], this._workBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 }, this._workAttributeData = new s.AttributeData, this._textureSize = 512, this._onAddTextureAtlasCanvas = new v.EventEmitter, this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = new v.EventEmitter, this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._requestClearModel = !1, this._createNewPage(), this._tmpCanvas = g(m, 4 * this._config.deviceCellWidth + 4, this._config.deviceCellHeight + 4), this._tmpCtx = (0, l.throwIfFalsy)(this._tmpCanvas.getContext("2d", { alpha: this._config.allowTransparency, willReadFrequently: !0 })) } dispose() { for (const m of this.pages) m.canvas.remove(); this._onAddTextureAtlasCanvas.dispose() } warmUp() { this._didWarmUp || (this._doWarmUp(), this._didWarmUp = !0) } _doWarmUp() { const m = new e.IdleTaskQueue; for (let C = 33; C < 126; C++)m.enqueue(() => { if (!this._cacheMap.get(C, i.DEFAULT_COLOR, i.DEFAULT_COLOR, i.DEFAULT_EXT)) { const L = this._drawToCache(C, i.DEFAULT_COLOR, i.DEFAULT_COLOR, i.DEFAULT_EXT); this._cacheMap.set(C, i.DEFAULT_COLOR, i.DEFAULT_COLOR, i.DEFAULT_EXT, L) } }) } beginFrame() { return this._requestClearModel } clearTexture() { if (this._pages[0].currentRow.x !== 0 || this._pages[0].currentRow.y !== 0) { for (const m of this._pages) m.clear(); this._cacheMap.clear(), this._cacheMapCombined.clear(), this._didWarmUp = !1 } } _createNewPage() { if (p.maxAtlasPages && this._pages.length >= Math.max(4, p.maxAtlasPages)) { const C = this._pages.filter(E => 2 * E.canvas.width <= (p.maxTextureSize || 4096)).sort((E, x) => x.canvas.width !== E.canvas.width ? x.canvas.width - E.canvas.width : x.percentageUsed - E.percentageUsed); let L = -1, R = 0; for (let E = 0; E < C.length; E++)if (C[E].canvas.width !== R) L = E, R = C[E].canvas.width; else if (E - L == 3) break; const D = C.slice(L, L + 4), M = D.map(E => E.glyphs[0].texturePage).sort((E, x) => E > x ? 1 : -1), k = this.pages.length - D.length, b = this._mergePages(D, k); b.version++; for (let E = M.length - 1; E >= 0; E--)this._deletePage(M[E]); this.pages.push(b), this._requestClearModel = !0, this._onAddTextureAtlasCanvas.fire(b.canvas) } const m = new S(this._document, this._textureSize); return this._pages.push(m), this._activePages.push(m), this._onAddTextureAtlasCanvas.fire(m.canvas), m } _mergePages(m, C) { const L = 2 * m[0].canvas.width, R = new S(this._document, L, m); for (const [D, M] of m.entries()) { const k = D * M.canvas.width % L, b = Math.floor(D / 2) * M.canvas.height; R.ctx.drawImage(M.canvas, k, b); for (const x of M.glyphs) x.texturePage = C, x.sizeClipSpace.x = x.size.x / L, x.sizeClipSpace.y = x.size.y / L, x.texturePosition.x += k, x.texturePosition.y += b, x.texturePositionClipSpace.x = x.texturePosition.x / L, x.texturePositionClipSpace.y = x.texturePosition.y / L; this._onRemoveTextureAtlasCanvas.fire(M.canvas); const E = this._activePages.indexOf(M); E !== -1 && this._activePages.splice(E, 1) } return R } _deletePage(m) { this._pages.splice(m, 1); for (let C = m; C < this._pages.length; C++) { const L = this._pages[C]; for (const R of L.glyphs) R.texturePage--; L.version++ } } getRasterizedGlyphCombinedChar(m, C, L, R, D) { return this._getFromCacheMap(this._cacheMapCombined, m, C, L, R, D) } getRasterizedGlyph(m, C, L, R, D) { return this._getFromCacheMap(this._cacheMap, m, C, L, R, D) } _getFromCacheMap(m, C, L, R, D, M = !1) { return u = m.get(C, L, R, D), u || (u = this._drawToCache(C, L, R, D, M), m.set(C, L, R, D, u)), u } _getColorFromAnsiIndex(m) { if (m >= this._config.colors.ansi.length) throw new Error("No color found for idx " + m); return this._config.colors.ansi[m] } _getBackgroundColor(m, C, L, R) { if (this._config.allowTransparency) return _.NULL_COLOR; let D; switch (m) { case 16777216: case 33554432: D = this._getColorFromAnsiIndex(C); break; case 50331648: const M = s.AttributeData.toColorRGB(C); D = _.rgba.toColor(M[0], M[1], M[2]); break; default: D = L ? _.color.opaque(this._config.colors.foreground) : this._config.colors.background }return D } _getForegroundColor(m, C, L, R, D, M, k, b, E, x) { const A = this._getMinimumContrastColor(m, C, L, R, D, M, !1, E, b, x); if (A) return A; let B; switch (D) { case 16777216: case 33554432: this._config.drawBoldTextInBrightColors && E && M < 8 && (M += 8), B = this._getColorFromAnsiIndex(M); break; case 50331648: const F = s.AttributeData.toColorRGB(M); B = _.rgba.toColor(F[0], F[1], F[2]); break; default: B = k ? this._config.colors.background : this._config.colors.foreground }return this._config.allowTransparency && (B = _.color.opaque(B)), b && (B = _.color.multiplyOpacity(B, f.DIM_OPACITY)), B } _resolveBackgroundRgba(m, C, L) { switch (m) { case 16777216: case 33554432: return this._getColorFromAnsiIndex(C).rgba; case 50331648: return C << 8; default: return L ? this._config.colors.foreground.rgba : this._config.colors.background.rgba } } _resolveForegroundRgba(m, C, L, R) { switch (m) { case 16777216: case 33554432: return this._config.drawBoldTextInBrightColors && R && C < 8 && (C += 8), this._getColorFromAnsiIndex(C).rgba; case 50331648: return C << 8; default: return L ? this._config.colors.background.rgba : this._config.colors.foreground.rgba } } _getMinimumContrastColor(m, C, L, R, D, M, k, b, E, x) { if (this._config.minimumContrastRatio === 1 || x) return; const A = this._getContrastCache(E), B = A.getColor(m, R); if (B !== void 0) return B || void 0; const F = this._resolveBackgroundRgba(C, L, k), H = this._resolveForegroundRgba(D, M, k, b), W = _.rgba.ensureContrastRatio(F, H, this._config.minimumContrastRatio / (E ? 2 : 1)); if (!W) return void A.setColor(m, R, null); const N = _.rgba.toColor(W >> 24 & 255, W >> 16 & 255, W >> 8 & 255); return A.setColor(m, R, N), N } _getContrastCache(m) { return m ? this._config.colors.halfContrastCache : this._config.colors.contrastCache } _drawToCache(m, C, L, R, D = !1) { const M = typeof m == "number" ? String.fromCharCode(m) : m, k = Math.min(this._config.deviceCellWidth * Math.max(M.length, 2) + 4, this._textureSize); this._tmpCanvas.width < k && (this._tmpCanvas.width = k); const b = Math.min(this._config.deviceCellHeight + 8, this._textureSize); if (this._tmpCanvas.height < b && (this._tmpCanvas.height = b), this._tmpCtx.save(), this._workAttributeData.fg = L, this._workAttributeData.bg = C, this._workAttributeData.extended.ext = R, this._workAttributeData.isInvisible()) return d; const E = !!this._workAttributeData.isBold(), x = !!this._workAttributeData.isInverse(), A = !!this._workAttributeData.isDim(), B = !!this._workAttributeData.isItalic(), F = !!this._workAttributeData.isUnderline(), H = !!this._workAttributeData.isStrikethrough(), W = !!this._workAttributeData.isOverline(); let N = this._workAttributeData.getFgColor(), y = this._workAttributeData.getFgColorMode(), T = this._workAttributeData.getBgColor(), I = this._workAttributeData.getBgColorMode(); if (x) { const U = N; N = T, T = U; const Y = y; y = I, I = Y } const O = this._getBackgroundColor(I, T, x, A); this._tmpCtx.globalCompositeOperation = "copy", this._tmpCtx.fillStyle = O.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.globalCompositeOperation = "source-over"; const z = E ? this._config.fontWeightBold : this._config.fontWeight, $ = B ? "italic" : ""; this._tmpCtx.font = `${$} ${z} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = f.TEXT_BASELINE; const V = M.length === 1 && (0, l.isPowerlineGlyph)(M.charCodeAt(0)), ee = M.length === 1 && (0, l.isRestrictedPowerlineGlyph)(M.charCodeAt(0)), te = this._getForegroundColor(C, I, T, L, y, N, x, A, E, (0, l.excludeFromContrastRatioDemands)(M.charCodeAt(0))); this._tmpCtx.fillStyle = te.css; const Z = ee ? 0 : 4; let q = !1; this._config.customGlyphs !== !1 && (q = (0, n.tryDrawCustomChar)(this._tmpCtx, M, Z, Z, this._config.deviceCellWidth, this._config.deviceCellHeight, this._config.fontSize, this._config.devicePixelRatio)); let le, ce = !V; if (le = typeof m == "number" ? this._unicodeService.wcwidth(m) : this._unicodeService.getStringCellWidth(m), F) { this._tmpCtx.save(); const U = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), Y = U % 2 == 1 ? .5 : 0; if (this._tmpCtx.lineWidth = U, this._workAttributeData.isUnderlineColorDefault()) this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle; else if (this._workAttributeData.isUnderlineColorRGB()) ce = !1, this._tmpCtx.strokeStyle = `rgb(${s.AttributeData.toColorRGB(this._workAttributeData.getUnderlineColor()).join(",")})`; else { ce = !1; let se = this._workAttributeData.getUnderlineColor(); this._config.drawBoldTextInBrightColors && this._workAttributeData.isBold() && se < 8 && (se += 8), this._tmpCtx.strokeStyle = this._getColorFromAnsiIndex(se).css } this._tmpCtx.beginPath(); const ne = Z, Q = Math.ceil(Z + this._config.deviceCharHeight) - Y - (D ? 2 * U : 0), de = Q + U, oe = Q + 2 * U; for (let se = 0; se < le; se++) { this._tmpCtx.save(); const K = ne + se * this._config.deviceCellWidth, he = ne + (se + 1) * this._config.deviceCellWidth, me = K + this._config.deviceCellWidth / 2; switch (this._workAttributeData.extended.underlineStyle) { case 2: this._tmpCtx.moveTo(K, Q), this._tmpCtx.lineTo(he, Q), this._tmpCtx.moveTo(K, oe), this._tmpCtx.lineTo(he, oe); break; case 3: const ve = U <= 1 ? oe : Math.ceil(Z + this._config.deviceCharHeight - U / 2) - Y, ge = U <= 1 ? Q : Math.ceil(Z + this._config.deviceCharHeight + U / 2) - Y, Ce = new Path2D; Ce.rect(K, Q, this._config.deviceCellWidth, oe - Q), this._tmpCtx.clip(Ce), this._tmpCtx.moveTo(K - this._config.deviceCellWidth / 2, de), this._tmpCtx.bezierCurveTo(K - this._config.deviceCellWidth / 2, ge, K, ge, K, de), this._tmpCtx.bezierCurveTo(K, ve, me, ve, me, de), this._tmpCtx.bezierCurveTo(me, ge, he, ge, he, de), this._tmpCtx.bezierCurveTo(he, ve, he + this._config.deviceCellWidth / 2, ve, he + this._config.deviceCellWidth / 2, de); break; case 4: this._tmpCtx.setLineDash([Math.round(U), Math.round(U)]), this._tmpCtx.moveTo(K, Q), this._tmpCtx.lineTo(he, Q); break; case 5: this._tmpCtx.setLineDash([4 * this._config.devicePixelRatio, 3 * this._config.devicePixelRatio]), this._tmpCtx.moveTo(K, Q), this._tmpCtx.lineTo(he, Q); break; default: this._tmpCtx.moveTo(K, Q), this._tmpCtx.lineTo(he, Q) }this._tmpCtx.stroke(), this._tmpCtx.restore() } if (this._tmpCtx.restore(), !q && this._config.fontSize >= 12 && !this._config.allowTransparency && M !== " ") { this._tmpCtx.save(), this._tmpCtx.textBaseline = "alphabetic"; const se = this._tmpCtx.measureText(M); if (this._tmpCtx.restore(), "actualBoundingBoxDescent" in se && se.actualBoundingBoxDescent > 0) { this._tmpCtx.save(); const K = new Path2D; K.rect(ne, Q - Math.ceil(U / 2), this._config.deviceCellWidth * le, oe - Q + Math.ceil(U / 2)), this._tmpCtx.clip(K), this._tmpCtx.lineWidth = 3 * this._config.devicePixelRatio, this._tmpCtx.strokeStyle = O.css, this._tmpCtx.strokeText(M, Z, Z + this._config.deviceCharHeight), this._tmpCtx.restore() } } } if (W) { const U = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), Y = U % 2 == 1 ? .5 : 0; this._tmpCtx.lineWidth = U, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(Z, Z + Y), this._tmpCtx.lineTo(Z + this._config.deviceCharWidth * le, Z + Y), this._tmpCtx.stroke() } if (q || this._tmpCtx.fillText(M, Z, Z + this._config.deviceCharHeight), M === "_" && !this._config.allowTransparency) { let U = a(this._tmpCtx.getImageData(Z, Z, this._config.deviceCellWidth, this._config.deviceCellHeight), O, te, ce); if (U) for (let Y = 1; Y <= 5 && (this._tmpCtx.save(), this._tmpCtx.fillStyle = O.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.restore(), this._tmpCtx.fillText(M, Z, Z + this._config.deviceCharHeight - Y), U = a(this._tmpCtx.getImageData(Z, Z, this._config.deviceCellWidth, this._config.deviceCellHeight), O, te, ce), U); Y++); } if (H) { const U = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 10)), Y = this._tmpCtx.lineWidth % 2 == 1 ? .5 : 0; this._tmpCtx.lineWidth = U, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(Z, Z + Math.floor(this._config.deviceCharHeight / 2) - Y), this._tmpCtx.lineTo(Z + this._config.deviceCharWidth * le, Z + Math.floor(this._config.deviceCharHeight / 2) - Y), this._tmpCtx.stroke() } this._tmpCtx.restore(); const _e = this._tmpCtx.getImageData(0, 0, this._tmpCanvas.width, this._tmpCanvas.height); let fe; if (fe = this._config.allowTransparency ? function (U) { for (let Y = 0; Y < U.data.length; Y += 4)if (U.data[Y + 3] > 0) return !1; return !0 }(_e) : a(_e, O, te, ce), fe) return d; const X = this._findGlyphBoundingBox(_e, this._workBoundingBox, k, ee, q, Z); let j, G; for (; ;) { if (this._activePages.length === 0) { const U = this._createNewPage(); j = U, G = U.currentRow, G.height = X.size.y; break } j = this._activePages[this._activePages.length - 1], G = j.currentRow; for (const U of this._activePages) X.size.y <= U.currentRow.height && (j = U, G = U.currentRow); for (let U = this._activePages.length - 1; U >= 0; U--)for (const Y of this._activePages[U].fixedRows) Y.height <= G.height && X.size.y <= Y.height && (j = this._activePages[U], G = Y); if (G.y + X.size.y >= j.canvas.height || G.height > X.size.y + 2) { let U = !1; if (j.currentRow.y + j.currentRow.height + X.size.y >= j.canvas.height) { let Y; for (const ne of this._activePages) if (ne.currentRow.y + ne.currentRow.height + X.size.y < ne.canvas.height) { Y = ne; break } if (Y) j = Y; else if (p.maxAtlasPages && this._pages.length >= p.maxAtlasPages && G.y + X.size.y <= j.canvas.height && G.height >= X.size.y && G.x + X.size.x <= j.canvas.width) U = !0; else { const ne = this._createNewPage(); j = ne, G = ne.currentRow, G.height = X.size.y, U = !0 } } U || (j.currentRow.height > 0 && j.fixedRows.push(j.currentRow), G = { x: 0, y: j.currentRow.y + j.currentRow.height, height: X.size.y }, j.fixedRows.push(G), j.currentRow = { x: 0, y: G.y + G.height, height: 0 }) } if (G.x + X.size.x <= j.canvas.width) break; G === j.currentRow ? (G.x = 0, G.y += G.height, G.height = 0) : j.fixedRows.splice(j.fixedRows.indexOf(G), 1) } return X.texturePage = this._pages.indexOf(j), X.texturePosition.x = G.x, X.texturePosition.y = G.y, X.texturePositionClipSpace.x = G.x / j.canvas.width, X.texturePositionClipSpace.y = G.y / j.canvas.height, X.sizeClipSpace.x /= j.canvas.width, X.sizeClipSpace.y /= j.canvas.height, G.height = Math.max(G.height, X.size.y), G.x += X.size.x, j.ctx.putImageData(_e, X.texturePosition.x - this._workBoundingBox.left, X.texturePosition.y - this._workBoundingBox.top, this._workBoundingBox.left, this._workBoundingBox.top, X.size.x, X.size.y), j.addGlyph(X), j.version++, X } _findGlyphBoundingBox(m, C, L, R, D, M) { C.top = 0; const k = R ? this._config.deviceCellHeight : this._tmpCanvas.height, b = R ? this._config.deviceCellWidth : L; let E = !1; for (let x = 0; x < k; x++) { for (let A = 0; A < b; A++) { const B = x * this._tmpCanvas.width * 4 + 4 * A + 3; if (m.data[B] !== 0) { C.top = x, E = !0; break } } if (E) break } C.left = 0, E = !1; for (let x = 0; x < M + b; x++) { for (let A = 0; A < k; A++) { const B = A * this._tmpCanvas.width * 4 + 4 * x + 3; if (m.data[B] !== 0) { C.left = x, E = !0; break } } if (E) break } C.right = b, E = !1; for (let x = M + b - 1; x >= M; x--) { for (let A = 0; A < k; A++) { const B = A * this._tmpCanvas.width * 4 + 4 * x + 3; if (m.data[B] !== 0) { C.right = x, E = !0; break } } if (E) break } C.bottom = k, E = !1; for (let x = k - 1; x >= 0; x--) { for (let A = 0; A < b; A++) { const B = x * this._tmpCanvas.width * 4 + 4 * A + 3; if (m.data[B] !== 0) { C.bottom = x, E = !0; break } } if (E) break } return { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, size: { x: C.right - C.left + 1, y: C.bottom - C.top + 1 }, sizeClipSpace: { x: C.right - C.left + 1, y: C.bottom - C.top + 1 }, offset: { x: -C.left + M + (R || D ? Math.floor((this._config.deviceCellWidth - this._config.deviceCharWidth) / 2) : 0), y: -C.top + M + (R || D ? this._config.lineHeight === 1 ? 0 : Math.round((this._config.deviceCellHeight - this._config.deviceCharHeight) / 2) : 0) } } } } t.TextureAtlas = p, c([r.traceCall], p.prototype, "_drawToCache", null); class S { get percentageUsed() { return this._usedPixels / (this.canvas.width * this.canvas.height) } get glyphs() { return this._glyphs } addGlyph(m) { this._glyphs.push(m), this._usedPixels += m.size.x * m.size.y } constructor(m, C, L) { if (this._usedPixels = 0, this._glyphs = [], this.version = 0, this.currentRow = { x: 0, y: 0, height: 0 }, this.fixedRows = [], L) for (const R of L) this._glyphs.push(...R.glyphs), this._usedPixels += R._usedPixels; this.canvas = g(m, C, C), this.ctx = (0, l.throwIfFalsy)(this.canvas.getContext("2d", { alpha: !0 })) } clear() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.currentRow.x = 0, this.currentRow.y = 0, this.currentRow.height = 0, this.fixedRows.length = 0, this.version++ } } function a(w, m, C, L) { const R = m.rgba >>> 24, D = m.rgba >>> 16 & 255, M = m.rgba >>> 8 & 255, k = C.rgba >>> 24, b = C.rgba >>> 16 & 255, E = C.rgba >>> 8 & 255, x = Math.floor((Math.abs(R - k) + Math.abs(D - b) + Math.abs(M - E)) / 12); let A = !0; for (let B = 0; B < w.data.length; B += 4)w.data[B] === R && w.data[B + 1] === D && w.data[B + 2] === M || L && Math.abs(w.data[B] - R) + Math.abs(w.data[B + 1] - D) + Math.abs(w.data[B + 2] - M) < x ? w.data[B + 3] = 0 : A = !1; return A } function g(w, m, C) { const L = w.createElement("canvas"); return L.width = m, L.height = C, L } }, 160: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = t.NULL_COLOR = void 0; const c = h(399); let f = 0, n = 0, l = 0, _ = 0; var v, o, e, s, i; function r(u) { const p = u.toString(16); return p.length < 2 ? "0" + p : p } function d(u, p) { return u < p ? (p + .05) / (u + .05) : (u + .05) / (p + .05) } t.NULL_COLOR = { css: "#00000000", rgba: 0 }, function (u) { u.toCss = function (p, S, a, g) { return g !== void 0 ? `#${r(p)}${r(S)}${r(a)}${r(g)}` : `#${r(p)}${r(S)}${r(a)}` }, u.toRgba = function (p, S, a, g = 255) { return (p << 24 | S << 16 | a << 8 | g) >>> 0 } }(v || (t.channels = v = {})), function (u) { function p(S, a) { return _ = Math.round(255 * a), [f, n, l] = i.toChannels(S.rgba), { css: v.toCss(f, n, l, _), rgba: v.toRgba(f, n, l, _) } } u.blend = function (S, a) { if (_ = (255 & a.rgba) / 255, _ === 1) return { css: a.css, rgba: a.rgba }; const g = a.rgba >> 24 & 255, w = a.rgba >> 16 & 255, m = a.rgba >> 8 & 255, C = S.rgba >> 24 & 255, L = S.rgba >> 16 & 255, R = S.rgba >> 8 & 255; return f = C + Math.round((g - C) * _), n = L + Math.round((w - L) * _), l = R + Math.round((m - R) * _), { css: v.toCss(f, n, l), rgba: v.toRgba(f, n, l) } }, u.isOpaque = function (S) { return (255 & S.rgba) == 255 }, u.ensureContrastRatio = function (S, a, g) { const w = i.ensureContrastRatio(S.rgba, a.rgba, g); if (w) return i.toColor(w >> 24 & 255, w >> 16 & 255, w >> 8 & 255) }, u.opaque = function (S) { const a = (255 | S.rgba) >>> 0; return [f, n, l] = i.toChannels(a), { css: v.toCss(f, n, l), rgba: a } }, u.opacity = p, u.multiplyOpacity = function (S, a) { return _ = 255 & S.rgba, p(S, _ * a / 255) }, u.toColorRGB = function (S) { return [S.rgba >> 24 & 255, S.rgba >> 16 & 255, S.rgba >> 8 & 255] } }(o || (t.color = o = {})), function (u) { let p, S; if (!c.isNode) { const a = document.createElement("canvas"); a.width = 1, a.height = 1; const g = a.getContext("2d", { willReadFrequently: !0 }); g && (p = g, p.globalCompositeOperation = "copy", S = p.createLinearGradient(0, 0, 1, 1)) } u.toColor = function (a) { if (a.match(/#[\da-f]{3,8}/i)) switch (a.length) { case 4: return f = parseInt(a.slice(1, 2).repeat(2), 16), n = parseInt(a.slice(2, 3).repeat(2), 16), l = parseInt(a.slice(3, 4).repeat(2), 16), i.toColor(f, n, l); case 5: return f = parseInt(a.slice(1, 2).repeat(2), 16), n = parseInt(a.slice(2, 3).repeat(2), 16), l = parseInt(a.slice(3, 4).repeat(2), 16), _ = parseInt(a.slice(4, 5).repeat(2), 16), i.toColor(f, n, l, _); case 7: return { css: a, rgba: (parseInt(a.slice(1), 16) << 8 | 255) >>> 0 }; case 9: return { css: a, rgba: parseInt(a.slice(1), 16) >>> 0 } }const g = a.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/); if (g) return f = parseInt(g[1]), n = parseInt(g[2]), l = parseInt(g[3]), _ = Math.round(255 * (g[5] === void 0 ? 1 : parseFloat(g[5]))), i.toColor(f, n, l, _); if (!p || !S) throw new Error("css.toColor: Unsupported css format"); if (p.fillStyle = S, p.fillStyle = a, typeof p.fillStyle != "string") throw new Error("css.toColor: Unsupported css format"); if (p.fillRect(0, 0, 1, 1), [f, n, l, _] = p.getImageData(0, 0, 1, 1).data, _ !== 255) throw new Error("css.toColor: Unsupported css format"); return { rgba: v.toRgba(f, n, l, _), css: a } } }(e || (t.css = e = {})), function (u) { function p(S, a, g) { const w = S / 255, m = a / 255, C = g / 255; return .2126 * (w <= .03928 ? w / 12.92 : Math.pow((w + .055) / 1.055, 2.4)) + .7152 * (m <= .03928 ? m / 12.92 : Math.pow((m + .055) / 1.055, 2.4)) + .0722 * (C <= .03928 ? C / 12.92 : Math.pow((C + .055) / 1.055, 2.4)) } u.relativeLuminance = function (S) { return p(S >> 16 & 255, S >> 8 & 255, 255 & S) }, u.relativeLuminance2 = p }(s || (t.rgb = s = {})), function (u) { function p(a, g, w) { const m = a >> 24 & 255, C = a >> 16 & 255, L = a >> 8 & 255; let R = g >> 24 & 255, D = g >> 16 & 255, M = g >> 8 & 255, k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); for (; k < w && (R > 0 || D > 0 || M > 0);)R -= Math.max(0, Math.ceil(.1 * R)), D -= Math.max(0, Math.ceil(.1 * D)), M -= Math.max(0, Math.ceil(.1 * M)), k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); return (R << 24 | D << 16 | M << 8 | 255) >>> 0 } function S(a, g, w) { const m = a >> 24 & 255, C = a >> 16 & 255, L = a >> 8 & 255; let R = g >> 24 & 255, D = g >> 16 & 255, M = g >> 8 & 255, k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); for (; k < w && (R < 255 || D < 255 || M < 255);)R = Math.min(255, R + Math.ceil(.1 * (255 - R))), D = Math.min(255, D + Math.ceil(.1 * (255 - D))), M = Math.min(255, M + Math.ceil(.1 * (255 - M))), k = d(s.relativeLuminance2(R, D, M), s.relativeLuminance2(m, C, L)); return (R << 24 | D << 16 | M << 8 | 255) >>> 0 } u.ensureContrastRatio = function (a, g, w) { const m = s.relativeLuminance(a >> 8), C = s.relativeLuminance(g >> 8); if (d(m, C) < w) { if (C < m) { const D = p(a, g, w), M = d(m, s.relativeLuminance(D >> 8)); if (M < w) { const k = S(a, g, w); return M > d(m, s.relativeLuminance(k >> 8)) ? D : k } return D } const L = S(a, g, w), R = d(m, s.relativeLuminance(L >> 8)); if (R < w) { const D = p(a, g, w); return R > d(m, s.relativeLuminance(D >> 8)) ? L : D } return L } }, u.reduceLuminance = p, u.increaseLuminance = S, u.toChannels = function (a) { return [a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a] }, u.toColor = function (a, g, w, m) { return { css: v.toCss(a, g, w, m), rgba: v.toRgba(a, g, w, m) } } }(i || (t.rgba = i = {})), t.toPaddedHex = r, t.contrastRatio = d }, 345: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class { constructor() { this._listeners = [], this._disposed = !1 } get event() { return this._event || (this._event = h => (this._listeners.push(h), { dispose: () => { if (!this._disposed) { for (let c = 0; c < this._listeners.length; c++)if (this._listeners[c] === h) return void this._listeners.splice(c, 1) } } })), this._event } fire(h, c) { const f = []; for (let n = 0; n < this._listeners.length; n++)f.push(this._listeners[n]); for (let n = 0; n < f.length; n++)f[n].call(void 0, h, c) } dispose() { this.clearListeners(), this._disposed = !0 } clearListeners() { this._listeners && (this._listeners.length = 0) } }, t.forwardEvent = function (h, c) { return h(f => c.fire(f)) } }, 859: (P, t) => { function h(c) { for (const f of c) f.dispose(); c.length = 0 } Object.defineProperty(t, "__esModule", { value: !0 }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.MutableDisposable = t.Disposable = void 0, t.Disposable = class { constructor() { this._disposables = [], this._isDisposed = !1 } dispose() { this._isDisposed = !0; for (const c of this._disposables) c.dispose(); this._disposables.length = 0 } register(c) { return this._disposables.push(c), c } unregister(c) { const f = this._disposables.indexOf(c); f !== -1 && this._disposables.splice(f, 1) } }, t.MutableDisposable = class { constructor() { this._isDisposed = !1 } get value() { return this._isDisposed ? void 0 : this._value } set value(c) { var f; this._isDisposed || c === this._value || ((f = this._value) === null || f === void 0 || f.dispose(), this._value = c) } clear() { this.value = void 0 } dispose() { var c; this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0 } }, t.toDisposable = function (c) { return { dispose: c } }, t.disposeArray = h, t.getDisposeArrayDisposable = function (c) { return { dispose: () => h(c) } } }, 485: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.FourKeyMap = t.TwoKeyMap = void 0; class h { constructor() { this._data = {} } set(f, n, l) { this._data[f] || (this._data[f] = {}), this._data[f][n] = l } get(f, n) { return this._data[f] ? this._data[f][n] : void 0 } clear() { this._data = {} } } t.TwoKeyMap = h, t.FourKeyMap = class { constructor() { this._data = new h } set(c, f, n, l, _) { this._data.get(c, f) || this._data.set(c, f, new h), this._data.get(c, f).set(n, l, _) } get(c, f, n, l) { var _; return (_ = this._data.get(c, f)) === null || _ === void 0 ? void 0 : _.get(n, l) } clear() { this._data.clear() } } }, 399: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.isChromeOS = t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.getSafariVersion = t.isSafari = t.isLegacyEdge = t.isFirefox = t.isNode = void 0, t.isNode = typeof navigator > "u"; const h = t.isNode ? "node" : navigator.userAgent, c = t.isNode ? "node" : navigator.platform; t.isFirefox = h.includes("Firefox"), t.isLegacyEdge = h.includes("Edge"), t.isSafari = /^((?!chrome|android).)*safari/i.test(h), t.getSafariVersion = function () { if (!t.isSafari) return 0; const f = h.match(/Version\/(\d+)/); return f === null || f.length < 2 ? 0 : parseInt(f[1]) }, t.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(c), t.isIpad = c === "iPad", t.isIphone = c === "iPhone", t.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(c), t.isLinux = c.indexOf("Linux") >= 0, t.isChromeOS = /\bCrOS\b/.test(h) }, 385: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.DebouncedIdleTask = t.IdleTaskQueue = t.PriorityTaskQueue = void 0; const c = h(399); class f { constructor() { this._tasks = [], this._i = 0 } enqueue(_) { this._tasks.push(_), this._start() } flush() { for (; this._i < this._tasks.length;)this._tasks[this._i]() || this._i++; this.clear() } clear() { this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0 } _start() { this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this))) } _process(_) { this._idleCallback = void 0; let v = 0, o = 0, e = _.timeRemaining(), s = 0; for (; this._i < this._tasks.length;) { if (v = Date.now(), this._tasks[this._i]() || this._i++, v = Math.max(1, Date.now() - v), o = Math.max(v, o), s = _.timeRemaining(), 1.5 * o > s) return e - v < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(e - v))}ms`), void this._start(); e = s } this.clear() } } class n extends f { _requestCallback(_) { return setTimeout(() => _(this._createDeadline(16))) } _cancelCallback(_) { clearTimeout(_) } _createDeadline(_) { const v = Date.now() + _; return { timeRemaining: () => Math.max(0, v - Date.now()) } } } t.PriorityTaskQueue = n, t.IdleTaskQueue = !c.isNode && "requestIdleCallback" in window ? class extends f { _requestCallback(l) { return requestIdleCallback(l) } _cancelCallback(l) { cancelIdleCallback(l) } } : n, t.DebouncedIdleTask = class { constructor() { this._queue = new t.IdleTaskQueue } set(l) { this._queue.clear(), this._queue.enqueue(l) } flush() { this._queue.flush() } } }, 147: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ExtendedAttrs = t.AttributeData = void 0; class h { constructor() { this.fg = 0, this.bg = 0, this.extended = new c } static toColorRGB(n) { return [n >>> 16 & 255, n >>> 8 & 255, 255 & n] } static fromColorRGB(n) { return (255 & n[0]) << 16 | (255 & n[1]) << 8 | 255 & n[2] } clone() { const n = new h; return n.fg = this.fg, n.bg = this.bg, n.extended = this.extended.clone(), n } isInverse() { return 67108864 & this.fg } isBold() { return 134217728 & this.fg } isUnderline() { return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg } isBlink() { return 536870912 & this.fg } isInvisible() { return 1073741824 & this.fg } isItalic() { return 67108864 & this.bg } isDim() { return 134217728 & this.bg } isStrikethrough() { return 2147483648 & this.fg } isProtected() { return 536870912 & this.bg } isOverline() { return 1073741824 & this.bg } getFgColorMode() { return 50331648 & this.fg } getBgColorMode() { return 50331648 & this.bg } isFgRGB() { return (50331648 & this.fg) == 50331648 } isBgRGB() { return (50331648 & this.bg) == 50331648 } isFgPalette() { return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432 } isBgPalette() { return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432 } isFgDefault() { return (50331648 & this.fg) == 0 } isBgDefault() { return (50331648 & this.bg) == 0 } isAttributeDefault() { return this.fg === 0 && this.bg === 0 } getFgColor() { switch (50331648 & this.fg) { case 16777216: case 33554432: return 255 & this.fg; case 50331648: return 16777215 & this.fg; default: return -1 } } getBgColor() { switch (50331648 & this.bg) { case 16777216: case 33554432: return 255 & this.bg; case 50331648: return 16777215 & this.bg; default: return -1 } } hasExtendedAttrs() { return 268435456 & this.bg } updateExtended() { this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456 } getUnderlineColor() { if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) { case 16777216: case 33554432: return 255 & this.extended.underlineColor; case 50331648: return 16777215 & this.extended.underlineColor; default: return this.getFgColor() }return this.getFgColor() } getUnderlineColorMode() { return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode() } isUnderlineColorRGB() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB() } isUnderlineColorPalette() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette() } isUnderlineColorDefault() { return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault() } getUnderlineStyle() { return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0 } } t.AttributeData = h; class c { get ext() { return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext } set ext(n) { this._ext = n } get underlineStyle() { return this._urlId ? 5 : (469762048 & this._ext) >> 26 } set underlineStyle(n) { this._ext &= -469762049, this._ext |= n << 26 & 469762048 } get underlineColor() { return 67108863 & this._ext } set underlineColor(n) { this._ext &= -67108864, this._ext |= 67108863 & n } get urlId() { return this._urlId } set urlId(n) { this._urlId = n } constructor(n = 0, l = 0) { this._ext = 0, this._urlId = 0, this._ext = n, this._urlId = l } clone() { return new c(this._ext, this._urlId) } isEmpty() { return this.underlineStyle === 0 && this._urlId === 0 } } t.ExtendedAttrs = c }, 782: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CellData = void 0; const c = h(133), f = h(855), n = h(147); class l extends n.AttributeData { constructor() { super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs, this.combinedData = "" } static fromCharData(v) { const o = new l; return o.setFromCharData(v), o } isCombined() { return 2097152 & this.content } getWidth() { return this.content >> 22 } getChars() { return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, c.stringFromCodePoint)(2097151 & this.content) : "" } getCode() { return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content } setFromCharData(v) { this.fg = v[f.CHAR_DATA_ATTR_INDEX], this.bg = 0; let o = !1; if (v[f.CHAR_DATA_CHAR_INDEX].length > 2) o = !0; else if (v[f.CHAR_DATA_CHAR_INDEX].length === 2) { const e = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0); if (55296 <= e && e <= 56319) { const s = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(1); 56320 <= s && s <= 57343 ? this.content = 1024 * (e - 55296) + s - 56320 + 65536 | v[f.CHAR_DATA_WIDTH_INDEX] << 22 : o = !0 } else o = !0 } else this.content = v[f.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | v[f.CHAR_DATA_WIDTH_INDEX] << 22; o && (this.combinedData = v[f.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | v[f.CHAR_DATA_WIDTH_INDEX] << 22) } getAsCharData() { return [this.fg, this.getChars(), this.getWidth(), this.getCode()] } } t.CellData = l }, 855: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 0, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = "", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = " ", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32 }, 133: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function (h) { return h > 65535 ? (h -= 65536, String.fromCharCode(55296 + (h >> 10)) + String.fromCharCode(h % 1024 + 56320)) : String.fromCharCode(h) }, t.utf32ToString = function (h, c = 0, f = h.length) { let n = ""; for (let l = c; l < f; ++l) { let _ = h[l]; _ > 65535 ? (_ -= 65536, n += String.fromCharCode(55296 + (_ >> 10)) + String.fromCharCode(_ % 1024 + 56320)) : n += String.fromCharCode(_) } return n }, t.StringToUtf32 = class { constructor() { this._interim = 0 } clear() { this._interim = 0 } decode(h, c) { const f = h.length; if (!f) return 0; let n = 0, l = 0; if (this._interim) { const _ = h.charCodeAt(l++); 56320 <= _ && _ <= 57343 ? c[n++] = 1024 * (this._interim - 55296) + _ - 56320 + 65536 : (c[n++] = this._interim, c[n++] = _), this._interim = 0 } for (let _ = l; _ < f; ++_) { const v = h.charCodeAt(_); if (55296 <= v && v <= 56319) { if (++_ >= f) return this._interim = v, n; const o = h.charCodeAt(_); 56320 <= o && o <= 57343 ? c[n++] = 1024 * (v - 55296) + o - 56320 + 65536 : (c[n++] = v, c[n++] = o) } else v !== 65279 && (c[n++] = v) } return n } }, t.Utf8ToUtf32 = class { constructor() { this.interim = new Uint8Array(3) } clear() { this.interim.fill(0) } decode(h, c) { const f = h.length; if (!f) return 0; let n, l, _, v, o = 0, e = 0, s = 0; if (this.interim[0]) { let d = !1, u = this.interim[0]; u &= (224 & u) == 192 ? 31 : (240 & u) == 224 ? 15 : 7; let p, S = 0; for (; (p = 63 & this.interim[++S]) && S < 4;)u <<= 6, u |= p; const a = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, g = a - S; for (; s < g;) { if (s >= f) return 0; if (p = h[s++], (192 & p) != 128) { s--, d = !0; break } this.interim[S++] = p, u <<= 6, u |= 63 & p } d || (a === 2 ? u < 128 ? s-- : c[o++] = u : a === 3 ? u < 2048 || u >= 55296 && u <= 57343 || u === 65279 || (c[o++] = u) : u < 65536 || u > 1114111 || (c[o++] = u)), this.interim.fill(0) } const i = f - 4; let r = s; for (; r < f;) { for (; !(!(r < i) || 128 & (n = h[r]) || 128 & (l = h[r + 1]) || 128 & (_ = h[r + 2]) || 128 & (v = h[r + 3]));)c[o++] = n, c[o++] = l, c[o++] = _, c[o++] = v, r += 4; if (n = h[r++], n < 128) c[o++] = n; else if ((224 & n) == 192) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (e = (31 & n) << 6 | 63 & l, e < 128) { r--; continue } c[o++] = e } else if ((240 & n) == 224) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, o; if (_ = h[r++], (192 & _) != 128) { r--; continue } if (e = (15 & n) << 12 | (63 & l) << 6 | 63 & _, e < 2048 || e >= 55296 && e <= 57343 || e === 65279) continue; c[o++] = e } else if ((248 & n) == 240) { if (r >= f) return this.interim[0] = n, o; if (l = h[r++], (192 & l) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, o; if (_ = h[r++], (192 & _) != 128) { r--; continue } if (r >= f) return this.interim[0] = n, this.interim[1] = l, this.interim[2] = _, o; if (v = h[r++], (192 & v) != 128) { r--; continue } if (e = (7 & n) << 18 | (63 & l) << 12 | (63 & _) << 6 | 63 & v, e < 65536 || e > 1114111) continue; c[o++] = e } } return o } } }, 776: function (P, t, h) { var c = this && this.__decorate || function (e, s, i, r) { var d, u = arguments.length, p = u < 3 ? s : r === null ? r = Object.getOwnPropertyDescriptor(s, i) : r; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") p = Reflect.decorate(e, s, i, r); else for (var S = e.length - 1; S >= 0; S--)(d = e[S]) && (p = (u < 3 ? d(p) : u > 3 ? d(s, i, p) : d(s, i)) || p); return u > 3 && p && Object.defineProperty(s, i, p), p }, f = this && this.__param || function (e, s) { return function (i, r) { s(i, r, e) } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.traceCall = t.setTraceLogger = t.LogService = void 0; const n = h(859), l = h(97), _ = { trace: l.LogLevelEnum.TRACE, debug: l.LogLevelEnum.DEBUG, info: l.LogLevelEnum.INFO, warn: l.LogLevelEnum.WARN, error: l.LogLevelEnum.ERROR, off: l.LogLevelEnum.OFF }; let v, o = t.LogService = class extends n.Disposable { get logLevel() { return this._logLevel } constructor(e) { super(), this._optionsService = e, this._logLevel = l.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), v = this } _updateLogLevel() { this._logLevel = _[this._optionsService.rawOptions.logLevel] } _evalLazyOptionalParams(e) { for (let s = 0; s < e.length; s++)typeof e[s] == "function" && (e[s] = e[s]()) } _log(e, s, i) { this._evalLazyOptionalParams(i), e.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + s, ...i) } trace(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.TRACE && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.trace.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.log, e, s) } debug(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.DEBUG && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.debug.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.log, e, s) } info(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.INFO && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.info.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.info, e, s) } warn(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.WARN && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.warn.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.warn, e, s) } error(e, ...s) { var i, r; this._logLevel <= l.LogLevelEnum.ERROR && this._log((r = (i = this._optionsService.options.logger) === null || i === void 0 ? void 0 : i.error.bind(this._optionsService.options.logger)) !== null && r !== void 0 ? r : console.error, e, s) } }; t.LogService = o = c([f(0, l.IOptionsService)], o), t.setTraceLogger = function (e) { v = e }, t.traceCall = function (e, s, i) { if (typeof i.value != "function") throw new Error("not supported"); const r = i.value; i.value = function (...d) { if (v.logLevel !== l.LogLevelEnum.TRACE) return r.apply(this, d); v.trace(`GlyphRenderer#${r.name}(${d.map(p => JSON.stringify(p)).join(", ")})`); const u = r.apply(this, d); return v.trace(`GlyphRenderer#${r.name} return`, u), u } } }, 726: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0; const h = "di$target", c = "di$dependencies"; t.serviceRegistry = new Map, t.getServiceDependencies = function (f) { return f[c] || [] }, t.createDecorator = function (f) { if (t.serviceRegistry.has(f)) return t.serviceRegistry.get(f); const n = function (l, _, v) { if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter"); (function (o, e, s) { e[h] === e ? e[c].push({ id: o, index: s }) : (e[c] = [{ id: o, index: s }], e[h] = e) })(n, l, v) }; return n.toString = () => f, t.serviceRegistry.set(f, n), n } }, 97: (P, t, h) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0; const c = h(726); var f; t.IBufferService = (0, c.createDecorator)("BufferService"), t.ICoreMouseService = (0, c.createDecorator)("CoreMouseService"), t.ICoreService = (0, c.createDecorator)("CoreService"), t.ICharsetService = (0, c.createDecorator)("CharsetService"), t.IInstantiationService = (0, c.createDecorator)("InstantiationService"), function (n) { n[n.TRACE = 0] = "TRACE", n[n.DEBUG = 0] = "DEBUG", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.OFF = 5] = "OFF" }(f || (t.LogLevelEnum = f = {})), t.ILogService = (0, c.createDecorator)("LogService"), t.IOptionsService = (0, c.createDecorator)("OptionsService"), t.IOscLinkService = (0, c.createDecorator)("OscLinkService"), t.IUnicodeService = (0, c.createDecorator)("UnicodeService"), t.IDecorationService = (0, c.createDecorator)("DecorationService") }
    }, ie = {}; function J(P) { var t = ie[P]; if (t !== void 0) return t.exports; var h = ie[P] = { exports: {} }; return ae[P].call(h.exports, h, h.exports, J), h.exports } var re = {}; return (() => { var P = re; Object.defineProperty(P, "__esModule", { value: !0 }), P.WebglAddon = void 0; const t = J(345), h = J(859), c = J(399), f = J(666), n = J(776); class l extends h.Disposable { constructor(v) { if (c.isSafari && (0, c.getSafariVersion)() < 16) throw new Error("Webgl2 is only supported on Safari 16 and above"); super(), this._preserveDrawingBuffer = v, this._onChangeTextureAtlas = this.register(new t.EventEmitter), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new t.EventEmitter), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new t.EventEmitter), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onContextLoss = this.register(new t.EventEmitter), this.onContextLoss = this._onContextLoss.event } activate(v) { const o = v._core; if (!v.element) return void this.register(o.onWillOpen(() => this.activate(v))); this._terminal = v; const e = o.coreService, s = o.optionsService, i = o, r = i._renderService, d = i._characterJoinerService, u = i._charSizeService, p = i._coreBrowserService, S = i._decorationService, a = i._logService, g = i._themeService; (0, n.setTraceLogger)(a), this._renderer = this.register(new f.WebglRenderer(v, d, u, p, e, S, s, g, this._preserveDrawingBuffer)), this.register((0, t.forwardEvent)(this._renderer.onContextLoss, this._onContextLoss)), this.register((0, t.forwardEvent)(this._renderer.onChangeTextureAtlas, this._onChangeTextureAtlas)), this.register((0, t.forwardEvent)(this._renderer.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas)), this.register((0, t.forwardEvent)(this._renderer.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)), r.setRenderer(this._renderer), this.register((0, h.toDisposable)(() => { const w = this._terminal._core._renderService; w.setRenderer(this._terminal._core._createRenderer()), w.handleResize(v.cols, v.rows) })) } get textureAtlas() { var v; return (v = this._renderer) === null || v === void 0 ? void 0 : v.textureAtlas } clearTextureAtlas() { var v; (v = this._renderer) === null || v === void 0 || v.clearTextureAtlas() } } P.WebglAddon = l })(), re
  })())
})(ye); var Re = ye.exports, Le = { exports: {} }; (function (ue, pe) { (function (ae, ie) { ue.exports = ie() })(self, () => (() => { var ae = { 345: (P, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class { constructor() { this._listeners = [], this._disposed = !1 } get event() { return this._event || (this._event = h => (this._listeners.push(h), { dispose: () => { if (!this._disposed) { for (let c = 0; c < this._listeners.length; c++)if (this._listeners[c] === h) return void this._listeners.splice(c, 1) } } })), this._event } fire(h, c) { const f = []; for (let n = 0; n < this._listeners.length; n++)f.push(this._listeners[n]); for (let n = 0; n < f.length; n++)f[n].call(void 0, h, c) } dispose() { this.clearListeners(), this._disposed = !0 } clearListeners() { this._listeners && (this._listeners.length = 0) } }, t.forwardEvent = function (h, c) { return h(f => c.fire(f)) } }, 859: (P, t) => { function h(c) { for (const f of c) f.dispose(); c.length = 0 } Object.defineProperty(t, "__esModule", { value: !0 }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.MutableDisposable = t.Disposable = void 0, t.Disposable = class { constructor() { this._disposables = [], this._isDisposed = !1 } dispose() { this._isDisposed = !0; for (const c of this._disposables) c.dispose(); this._disposables.length = 0 } register(c) { return this._disposables.push(c), c } unregister(c) { const f = this._disposables.indexOf(c); f !== -1 && this._disposables.splice(f, 1) } }, t.MutableDisposable = class { constructor() { this._isDisposed = !1 } get value() { return this._isDisposed ? void 0 : this._value } set value(c) { var f; this._isDisposed || c === this._value || ((f = this._value) === null || f === void 0 || f.dispose(), this._value = c) } clear() { this.value = void 0 } dispose() { var c; this._isDisposed = !0, (c = this._value) === null || c === void 0 || c.dispose(), this._value = void 0 } }, t.toDisposable = function (c) { return { dispose: c } }, t.disposeArray = h, t.getDisposeArrayDisposable = function (c) { return { dispose: () => h(c) } } } }, ie = {}; function J(P) { var t = ie[P]; if (t !== void 0) return t.exports; var h = ie[P] = { exports: {} }; return ae[P](h, h.exports, J), h.exports } var re = {}; return (() => { var P = re; Object.defineProperty(P, "__esModule", { value: !0 }), P.SearchAddon = void 0; const t = J(345), h = J(859), c = " ~!@#$%^&*()+`-=[]{}|\\;:\"',./<>?"; class f extends h.Disposable { constructor(l) { var _; super(), this._highlightedLines = new Set, this._highlightDecorations = [], this._selectedDecoration = this.register(new h.MutableDisposable), this._linesCacheTimeoutId = 0, this._onDidChangeResults = this.register(new t.EventEmitter), this.onDidChangeResults = this._onDidChangeResults.event, this._highlightLimit = (_ = l?.highlightLimit) !== null && _ !== void 0 ? _ : 1e3 } activate(l) { this._terminal = l, this.register(this._terminal.onWriteParsed(() => this._updateMatches())), this.register(this._terminal.onResize(() => this._updateMatches())), this.register((0, h.toDisposable)(() => this.clearDecorations())) } _updateMatches() { var l; this._highlightTimeout && window.clearTimeout(this._highlightTimeout), this._cachedSearchTerm && (!((l = this._lastSearchOptions) === null || l === void 0) && l.decorations) && (this._highlightTimeout = setTimeout(() => { const _ = this._cachedSearchTerm; this._cachedSearchTerm = void 0, this.findPrevious(_, Object.assign(Object.assign({}, this._lastSearchOptions), { incremental: !0, noScroll: !0 })) }, 200)) } clearDecorations(l) { this._selectedDecoration.clear(), (0, h.disposeArray)(this._highlightDecorations), this._highlightDecorations = [], this._highlightedLines.clear(), l || (this._cachedSearchTerm = void 0) } findNext(l, _) { if (!this._terminal) throw new Error("Cannot use addon until it has been loaded"); this._lastSearchOptions = _, _?.decorations && (this._cachedSearchTerm !== void 0 && l === this._cachedSearchTerm || this._highlightAllMatches(l, _)); const v = this._findNextAndSelect(l, _); return this._fireResults(_), this._cachedSearchTerm = l, v } _highlightAllMatches(l, _) { if (!this._terminal) throw new Error("Cannot use addon until it has been loaded"); if (!l || l.length === 0) return void this.clearDecorations(); _ = _ || {}, this.clearDecorations(!0); const v = []; let o, e = this._find(l, 0, 0, _); for (; e && (o?.row !== e.row || o?.col !== e.col) && !(v.length >= this._highlightLimit);)o = e, v.push(o), e = this._find(l, o.col + o.term.length >= this._terminal.cols ? o.row + 1 : o.row, o.col + o.term.length >= this._terminal.cols ? 0 : o.col + 1, _); for (const s of v) { const i = this._createResultDecoration(s, _.decorations); i && (this._highlightedLines.add(i.marker.line), this._highlightDecorations.push({ decoration: i, match: s, dispose() { i.dispose() } })) } } _find(l, _, v, o) { var e; if (!this._terminal || !l || l.length === 0) return (e = this._terminal) === null || e === void 0 || e.clearSelection(), void this.clearDecorations(); if (v > this._terminal.cols) throw new Error(`Invalid col: ${v} to search in terminal of ${this._terminal.cols} cols`); let s; this._initLinesCache(); const i = { startRow: _, startCol: v }; if (s = this._findInLine(l, i, o), !s) for (let r = _ + 1; r < this._terminal.buffer.active.baseY + this._terminal.rows && (i.startRow = r, i.startCol = 0, s = this._findInLine(l, i, o), !s); r++); return s } _findNextAndSelect(l, _) { var v; if (!this._terminal || !l || l.length === 0) return (v = this._terminal) === null || v === void 0 || v.clearSelection(), this.clearDecorations(), !1; const o = this._terminal.getSelectionPosition(); this._terminal.clearSelection(); let e = 0, s = 0; o && (this._cachedSearchTerm === l ? (e = o.end.x, s = o.end.y) : (e = o.start.x, s = o.start.y)), this._initLinesCache(); const i = { startRow: s, startCol: e }; let r = this._findInLine(l, i, _); if (!r) for (let d = s + 1; d < this._terminal.buffer.active.baseY + this._terminal.rows && (i.startRow = d, i.startCol = 0, r = this._findInLine(l, i, _), !r); d++); if (!r && s !== 0) for (let d = 0; d < s && (i.startRow = d, i.startCol = 0, r = this._findInLine(l, i, _), !r); d++); return !r && o && (i.startRow = o.start.y, i.startCol = 0, r = this._findInLine(l, i, _)), this._selectResult(r, _?.decorations, _?.noScroll) } findPrevious(l, _) { if (!this._terminal) throw new Error("Cannot use addon until it has been loaded"); this._lastSearchOptions = _, _?.decorations && (this._cachedSearchTerm !== void 0 && l === this._cachedSearchTerm || this._highlightAllMatches(l, _)); const v = this._findPreviousAndSelect(l, _); return this._fireResults(_), this._cachedSearchTerm = l, v } _fireResults(l) { if (l?.decorations) { let _ = -1; if (this._selectedDecoration.value) { const v = this._selectedDecoration.value.match; for (let o = 0; o < this._highlightDecorations.length; o++) { const e = this._highlightDecorations[o].match; if (e.row === v.row && e.col === v.col && e.size === v.size) { _ = o; break } } } this._onDidChangeResults.fire({ resultIndex: _, resultCount: this._highlightDecorations.length }) } } _findPreviousAndSelect(l, _) { var v; if (!this._terminal) throw new Error("Cannot use addon until it has been loaded"); if (!this._terminal || !l || l.length === 0) return (v = this._terminal) === null || v === void 0 || v.clearSelection(), this.clearDecorations(), !1; const o = this._terminal.getSelectionPosition(); this._terminal.clearSelection(); let e = this._terminal.buffer.active.baseY + this._terminal.rows - 1, s = this._terminal.cols; const i = !0; this._initLinesCache(); const r = { startRow: e, startCol: s }; let d; if (o && (r.startRow = e = o.start.y, r.startCol = s = o.start.x, this._cachedSearchTerm !== l && (d = this._findInLine(l, r, _, !1), d || (r.startRow = e = o.end.y, r.startCol = s = o.end.x))), d || (d = this._findInLine(l, r, _, i)), !d) { r.startCol = Math.max(r.startCol, this._terminal.cols); for (let u = e - 1; u >= 0 && (r.startRow = u, d = this._findInLine(l, r, _, i), !d); u--); } if (!d && e !== this._terminal.buffer.active.baseY + this._terminal.rows - 1) for (let u = this._terminal.buffer.active.baseY + this._terminal.rows - 1; u >= e && (r.startRow = u, d = this._findInLine(l, r, _, i), !d); u--); return this._selectResult(d, _?.decorations, _?.noScroll) } _initLinesCache() { const l = this._terminal; this._linesCache || (this._linesCache = new Array(l.buffer.active.length), this._cursorMoveListener = l.onCursorMove(() => this._destroyLinesCache()), this._resizeListener = l.onResize(() => this._destroyLinesCache())), window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), 15e3) } _destroyLinesCache() { this._linesCache = void 0, this._cursorMoveListener && (this._cursorMoveListener.dispose(), this._cursorMoveListener = void 0), this._resizeListener && (this._resizeListener.dispose(), this._resizeListener = void 0), this._linesCacheTimeoutId && (window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = 0) } _isWholeWord(l, _, v) { return (l === 0 || c.includes(_[l - 1])) && (l + v.length === _.length || c.includes(_[l + v.length])) } _findInLine(l, _, v = {}, o = !1) { var e; const s = this._terminal, i = _.startRow, r = _.startCol, d = s.buffer.active.getLine(i); if (d?.isWrapped) return o ? void (_.startCol += s.cols) : (_.startRow--, _.startCol += s.cols, this._findInLine(l, _, v)); let u = (e = this._linesCache) === null || e === void 0 ? void 0 : e[i]; u || (u = this._translateBufferLineToStringWithWrap(i, !0), this._linesCache && (this._linesCache[i] = u)); const [p, S] = u, a = this._bufferColsToStringOffset(i, r), g = v.caseSensitive ? l : l.toLowerCase(), w = v.caseSensitive ? p : p.toLowerCase(); let m = -1; if (v.regex) { const C = RegExp(g, "g"); let L; if (o) for (; L = C.exec(w.slice(0, a));)m = C.lastIndex - L[0].length, l = L[0], C.lastIndex -= l.length - 1; else L = C.exec(w.slice(a)), L && L[0].length > 0 && (m = a + (C.lastIndex - L[0].length), l = L[0]) } else o ? a - g.length >= 0 && (m = w.lastIndexOf(g, a - g.length)) : m = w.indexOf(g, a); if (m >= 0) { if (v.wholeWord && !this._isWholeWord(m, w, l)) return; let C = 0; for (; C < S.length - 1 && m >= S[C + 1];)C++; let L = C; for (; L < S.length - 1 && m + l.length >= S[L + 1];)L++; const R = m - S[C], D = m + l.length - S[L], M = this._stringLengthToBufferSize(i + C, R); return { term: l, col: M, row: i + C, size: this._stringLengthToBufferSize(i + L, D) - M + s.cols * (L - C) } } } _stringLengthToBufferSize(l, _) { const v = this._terminal.buffer.active.getLine(l); if (!v) return 0; for (let o = 0; o < _; o++) { const e = v.getCell(o); if (!e) break; const s = e.getChars(); s.length > 1 && (_ -= s.length - 1); const i = v.getCell(o + 1); i && i.getWidth() === 0 && _++ } return _ } _bufferColsToStringOffset(l, _) { const v = this._terminal; let o = l, e = 0, s = v.buffer.active.getLine(o); for (; _ > 0 && s;) { for (let i = 0; i < _ && i < v.cols; i++) { const r = s.getCell(i); if (!r) break; r.getWidth() && (e += r.getCode() === 0 ? 1 : r.getChars().length) } if (o++, s = v.buffer.active.getLine(o), s && !s.isWrapped) break; _ -= v.cols } return e } _translateBufferLineToStringWithWrap(l, _) { var v; const o = this._terminal, e = [], s = [0]; let i = o.buffer.active.getLine(l); for (; i;) { const r = o.buffer.active.getLine(l + 1), d = !!r && r.isWrapped; let u = i.translateToString(!d && _); if (d && r) { const p = i.getCell(i.length - 1); p && p.getCode() === 0 && p.getWidth() === 1 && ((v = r.getCell(0)) === null || v === void 0 ? void 0 : v.getWidth()) === 2 && (u = u.slice(0, -1)) } if (e.push(u), !d) break; s.push(s[s.length - 1] + u.length), l++, i = r } return [e.join(""), s] } _selectResult(l, _, v) { const o = this._terminal; if (this._selectedDecoration.clear(), !l) return o.clearSelection(), !1; if (o.select(l.col, l.row, l.size), _) { const e = o.registerMarker(-o.buffer.active.baseY - o.buffer.active.cursorY + l.row); if (e) { const s = o.registerDecoration({ marker: e, x: l.col, width: l.size, backgroundColor: _.activeMatchBackground, layer: "top", overviewRulerOptions: { color: _.activeMatchColorOverviewRuler } }); if (s) { const i = []; i.push(e), i.push(s.onRender(r => this._applyStyles(r, _.activeMatchBorder, !0))), i.push(s.onDispose(() => (0, h.disposeArray)(i))), this._selectedDecoration.value = { decoration: s, match: l, dispose() { s.dispose() } } } } } if (!v && (l.row >= o.buffer.active.viewportY + o.rows || l.row < o.buffer.active.viewportY)) { let e = l.row - o.buffer.active.viewportY; e -= Math.floor(o.rows / 2), o.scrollLines(e) } return !0 } _applyStyles(l, _, v) { l.classList.contains("xterm-find-result-decoration") || (l.classList.add("xterm-find-result-decoration"), _ && (l.style.outline = `1px solid ${_}`)), v && l.classList.add("xterm-find-active-result-decoration") } _createResultDecoration(l, _) { const v = this._terminal, o = v.registerMarker(-v.buffer.active.baseY - v.buffer.active.cursorY + l.row); if (!o) return; const e = v.registerDecoration({ marker: o, x: l.col, width: l.size, backgroundColor: _.matchBackground, overviewRulerOptions: this._highlightedLines.has(o.line) ? void 0 : { color: _.matchOverviewRuler, position: "center" } }); if (e) { const s = []; s.push(o), s.push(e.onRender(i => this._applyStyles(i, _.matchBorder, !1))), s.push(e.onDispose(() => (0, h.disposeArray)(s))) } return e } } P.SearchAddon = f })(), re })()) })(Le); var De = Le.exports; export { xe as a, De as b, Re as c, Ee as x };
